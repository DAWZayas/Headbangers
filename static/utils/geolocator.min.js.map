{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///geolocator.min.js","webpack:///webpack/bootstrap d48e29f068e0ebc407bd","webpack:///./src/lib/utils.js","webpack:///./src/core/enums.js","webpack:///./src/core/geo.error.js","webpack:///./src/lib/fetch.js","webpack:///./src/core/geolocator.js","webpack:///./src/core/geo.helper.js","webpack:///./src/core/geo.watcher.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_typeof","Symbol","iterator","obj","constructor","_toString","toString","utils","noop","isString","isStringSet","trim","length","isNumber","isObject","type","Boolean","isFunction","isArray","isFilledArray","array","isPlainObject","isDate","isElement","HTMLElement","nodeType","isNode","Node","isJQueryObject","window","jQuery","isPositionError","isError","Error","removeQuery","str","replace","removeProtocol","setProtocol","url","https","undefined","location","protocol","trimDots","encodeURI","encodeURIComponent","decodeURI","decodeURIComponent","String","randomString","len","Math","abs","random","slice","abbr","options","extend","upper","dots","match","join","toUpperCase","params","keys","encode","operator","separator","include","exclude","inc","exc","forIn","key","indexOf","v","k","push","notateGlobalObj","notation","levels","split","shift","forEach","note","callback","destination","_len","arguments","sources","Array","_key","source","concat","Date","clone","own","cloned","mapToSchema","schema","mapped","safeJsonParse","JSON","parse","e","time","seconds","ts","now","parseInt","default","GOOGLE_MAPS_API_BASE","enums","freeze","URL","IP","FLAG","GOOGLE_MAPS_API","GOOGLE_SATATIC_MAP","GOOGLE_GEOLOCATION","GOOGLE_GEOCODE","GOOGLE_TIMEZONE","GOOGLE_DISTANCE_MATRIX","MapTypeId","HYBRID","ROADMAP","SATELLITE","TERRAIN","LocationType","ROOFTOP","RANGE_INTERPOLATED","GEOMETRIC_CENTER","APPROXIMATE","TravelMode","DRIVING","WALKING","BICYCLING","TRANSIT","UnitSystem","METRIC","IMPERIAL","RadioType","LTE","GSM","CDMA","WCDMA","DistanceFormula","HAVERSINE","PYTHAGOREAN","ImageFormat","PNG","PNG_8","PNG_32","GIF","JPG","JPG_BASELINE","_interopRequireDefault","_classCallCheck","instance","Constructor","TypeError","errorCodeFromStatus","status","GeoError","Code","NOT_FOUND","INVALID_RESPONSE","errorCodeFromReason","reason","INVALID_REQUEST","DAILY_LIMIT_EXCEEDED","GOOGLE_KEY_INVALID","USER_RATE_LIMIT_EXCEEDED","PARSE_ERROR","_createClass","defineProperties","target","props","descriptor","writable","protoProps","staticProps","_utils","_utils2","code","UNKNOWN_ERROR","message","captureStackTrace","stack","err","msg","PERMISSION_DENIED","POSITION_UNAVAILABLE","TIMEOUT","isValidErrorCode","response","errCode","errMsg","error_message","errorMessage","error","errors","errorCode","prop","setPrototypeOf","create","GEOLOCATION_NOT_SUPPORTED","INVALID_GEO_IP_SOURCE","INVALID_PARAMETERS","REQUEST_DENIED","REQUEST_FAILED","GOOGLE_API_FAILED","OVER_QUERY_LIMIT","MAX_ELEMENTS_EXCEEDED","MAX_DIMENSIONS_EXCEEDED","MAX_WAYPOINTS_EXCEEDED","INTERNAL_ERROR","_xhr","method","fetch","xhr","execCb","timeUp","timeout","clearTimeout","clean","script","parentNode","removeChild","rootNameSet","cbFnName","async","defer","document","createElement","cbParamSet","callbackParam","rootName","query","qMark","fn","readyState","onreadystatechange","onload","onerror","charset","crossorigin","src","getElementsByTagName","appendChild","setTimeout","XMLHttpRequest","hasCallback","data","withCredentials","mimeType","username","password","XHR_READY_STATE","DONE","crossDomain","ontimeout","open","headers","setRequestHeader","overrideMimeType","send","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","invalidOriginOrDest","getXHRResponse","_geo4","responseText","fromResponse","checkGoogleKey","addressLookup","timezone","map","staticMap","geolocator","_","config","google","getMapOpts","mapOptions","center","coords","element","formattedAddress","title","zoom","accuracy","configCreateMap","elem","mapData","_geolocatorMapData","marker","infoWindow","maps","LatLng","latitude","longitude","mapTypeId","styles","setOptions","Map","Marker","event","clearInstanceListeners","setMap","position","InfoWindow","setContent","addListener","setLocationURLs","address","cc","countryCode","country","flag","_enums2","toLowerCase","opts","getStaticMap","callbackMap","createMap","geocode","reverse","_geo2","fetchAddressAndTimezone","getTZ","cb","getTimeZone","loc","timestamp","reverseGeocode","result","locateAccurate","onPositionReceived","onPositionError","complete","watcher","onProgress","watch","clear","cycle","desiredAccuracy","maximumWait","getStyles","conf","_fetch","_fetch2","_geo","_geo3","_geo5","_geo6","_enums","EARTH_RADIUS_KM","EARTH_RADIUS_MI","defaultConfig","language","version","size","width","height","scale","format","region","color","mapStylesToParams","getElementById","isGoogleLoaded","getDiv","ensureGoogleLoaded","fallbackToIP","locateByIP","enableHighAccuracy","maximumAge","isGeolocationSupported","navigator","geolocation","getCurrentPosition","homeMobileCountryCode","homeMobileNetworkCode","radioType","carrier","cellTowers","wifiAccessPoints","raw","considerIp","xhrOpts","Content-Type","stringify","post","isGeoError","lat","lng","geoIpSource","jsonpOpts","globalVar","jsonp","provider","Number","onPositionChanged","pos","distance","calcDistance","from","to","formula","unitSystem","targetReached","radius","clearOnError","id","timeZoneId","timeZoneName","dstOffset","rawOffset","origins","origin","destinations","toPointList","travelMode","avoidFerries","avoidHighways","avoidTolls","DistanceMatrixService","getDistanceMatrix","DistanceMatrixStatus","OK","formatDistanceResults","dLat","degToRad","dLng","a","sin","cos","atan2","sqrt","latA","latB","lngA","lngB","x","y","km","mi","degrees","PI","radians","dec","isLng","sign","sn","we","nsew","absValue","round","floor","setGeoIPSource","ip","city","state","stateCode","postalCode","geoHelper","toGoogleCoords","fromGoogleCoords","arr","getGeocodeComps","comp","route","locality","administrative_area","administrativeArea","postal_code","buildGeocodeParams","placeId","geoComps","b","bounds","southwestLat","southwestLng","northeastLat","northeastLng","formatGeocodeResults","results","comps","address_components","types","long_name","short_name","geometry","commonName","point_of_interest","premise","subpremise","colloquial_area","streetNumber","street_number","street","administrative_area_level_4","administrative_area_level_3","neighborhood","administrative_area_level_5","town","sublocality","administrative_area_level_2","administrative_area_level_1","administrative_area_level_1_s","country_s","formatted_address","location_type","place_id","coordsSet","gErr","originAddresses","dests","destinationAddresses","rows","oIndex","dest","dIndex","elements","duration","fare","style","stylers","featureType","elementType","val","propName","GeoWatcher","onChange","onError","_this","isCleared","_timer","watchPosition","clearWatch","delay","_this2","_clear","_geolocator","_geolocator2"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,gBAAAH,GACA,gBAAAC,SACAA,QAAA,WAAAD,IAEAD,EAAA,WAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAV,WAUA,OANAK,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,GAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KA+DA,OAnCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAG,EAAA,SAAAK,GAA2C,MAAAA,IAG3CR,EAAAS,EAAA,SAAAf,EAAAgB,EAAAC,GACAX,EAAAY,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAX,EAAAkB,EAAA,SAAAvB,GACA,GAAAgB,GAAAhB,KAAAwB,WACA,WAA2B,MAAAxB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAK,GAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDrB,EAAAwB,EAAA,QAGAxB,IAAAyB,EAAA,KDgBM,SAAU9B,EAAQD,EAASM,GAEjC,YAGAa,QAAOC,eAAepB,EAAS,cAC3Bc,OAAO,GAGX,IAAIkB,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOL,UAAY,eAAkBO,IExFlQE,EAAYlB,OAAOS,UAAUU,SAW3BC,GAEFC,KAFU,aAeVC,SAfU,SAeD3B,GACL,MAAwB,gBAAVA,IAGlB4B,YAnBU,SAmBE5B,GACR,MAAwB,gBAAVA,IAAsBA,EAAM6B,OAAOC,OAAS,GAU9DC,SA9BU,SA8BD/B,GACL,MAAwB,gBAAVA,IAUlBgC,SAzCU,SAyCDhC,GACL,GAAIiC,GAAA,SAAcjC,EAAd,YAAAkB,EAAclB,EAClB,OAAOkC,SAAQlC,KAAoB,WAATiC,GAA8B,aAATA,IAUnDE,WArDU,SAqDCnC,GACP,MAAwB,kBAAVA,IAUlBoC,QAhEU,SAgEFpC,GACJ,MAAOkC,SAAQlC,IAAoC,mBAA1BuB,EAAU1B,KAAKG,IAU5CqC,cA3EU,SA2EIC,GACV,MAAOb,GAAMW,QAAQE,IAAUA,EAAMR,OAAS,GAUlDS,cAtFU,SAsFIvC,GACV,MAAOkC,SAAQlC,IACS,YAAjB,SAAOA,EAAP,YAAAkB,EAAOlB,KACmB,oBAA1BuB,EAAU1B,KAAKG,IAU1BwC,OAnGU,SAmGHxC,GACH,MAAOkC,SAAQlC,IAAoC,kBAA1BuB,EAAU1B,KAAKG,IAU5CyC,UA9GU,SA8GA7B,GACN,QAAKA,IACEA,YAAkB8B,cACC,YAAlB,SAAO9B,EAAP,YAAAM,EAAON,KAA2C,IAApBA,EAAO+B,WAUjDC,OA3HU,SA2HHhC,GACH,QAAKA,IACEA,YAAkBiC,OACC,YAAlB,SAAOjC,EAAP,YAAAM,EAAON,KAAkD,gBAApBA,GAAO+B,WAWxDG,eAzIU,SAyIKlC,GACX,QAAKA,IACG,UAAYmC,SAAUnC,YAAkBmC,QAAOC,QAAUd,QAAQtB,EAAO,MAYpFqC,gBAvJU,SAuJMjD,GACZ,MAAOkC,SAAQlC,IAAoC,2BAA1BuB,EAAU1B,KAAKG,IAU5CkD,QAlKU,SAkKFlD,GACJ,MAAQA,aAAiBmD,QAAU1B,EAAMwB,gBAAgBjD,IAc7DoD,YAjLU,SAiLEC,GACR,MAAOA,GAAIC,QAAQ,QAAS,KAUhCC,eA5LU,SA4LKF,GACX,MAAOA,GAAIC,QAAQ,cAAe,KAetCE,YA5MU,SA4MEC,EAAKC,GACb,GAAI1C,SAOJ,OALIA,GADU2C,SAAVD,GAAiC,OAAVA,EACnBX,OAAOa,SAASC,SAEhBH,EAAQ,SAAW,QAE3BD,EAAMhC,EAAM8B,eAAeE,GACjBzC,EAAV,KAAgByC,GAUpBK,SA9NU,SA8NDT,GACL,MAAOA,GAAIC,QAAQ,mBAAoB,OAW3CS,UA1OU,SA0OAV,GACN,MAAOW,oBAAmBX,GAAKC,QAAQ,OAAQ,MAWnDW,UAtPU,SAsPAZ,GACN,MAAOa,oBAAmBb,EAAIC,QAAQ,MAAO,SAajD9B,SApQU,SAoQDxB,GACL,MAAc,QAAVA,GAA4B2D,SAAV3D,EAA4B,GAC9CA,EAAMwB,UAAYC,EAAMU,WAAWnC,EAAMwB,UAClCxB,EAAMwB,WAEV2C,OAAOnE,IAUlBoE,aAnRU,SAmRGC,GAGT,MAFKA,IAAQ5C,EAAMM,SAASsC,KAAMA,EAAM,GACxCA,GAAOC,KAAKC,IAAIF,GACTC,KAAKE,SAAShD,SAAS,IAAIiD,MAAMJ,IAkB5CK,KAxSU,SAwSLrB,EAAKsB,GACNA,EAAUlD,EAAMmD,QACZC,OAAO,EACPC,MAAM,GACPH,EACH,IAAI1E,GAAI0E,EAAQG,KAAO,IAAM,GACzB7D,EAAIoC,EAAI0B,MAAM,YAAYC,KAAK/E,GAAKA,CACxC,OAAO0E,GAAQE,MAAQ5D,EAAEgE,cAAgBhE,GAsB7CiE,OArUU,QAAAA,GAqUH7D,EAAKsD,GACR,IAAKlD,EAAMc,cAAclB,IAAoC,IAA5BhB,OAAO8E,KAAK9D,GAAKS,OAC9C,MAAO,EAGX6C,GAAUlD,EAAMmD,QACZQ,QAAQ,EACRC,SAAU,IACVC,UAAW,IACXC,QAAS5B,OACT6B,QAAS7B,QACVgB,EAEH,IAAIO,MACAO,EAAMhE,EAAMW,QAAQuC,EAAQY,SAAWZ,EAAQY,QAAU,KACzDG,GAAOD,GAAOhE,EAAMW,QAAQuC,EAAQa,SAAWb,EAAQa,QAAU,IAWrE,OAVA/D,GAAMkE,MAAMtE,EAAK,SAACrB,EAAO4F,GACrB,KAAMH,GAAOA,EAAII,QAAQD,IAAQ,MACpBF,GAAOA,EAAIG,QAAQD,GAAO,GAAI,CACvC,GAAIE,GAAIrE,EAAMD,SAASxB,EACvB8F,GAAInB,EAAQS,OAAS3D,EAAMsC,UAAU+B,GAAKA,CAC1C,IAAIC,GAAIpB,EAAQS,OAAS3D,EAAMsC,UAAU6B,GAAOA,CAChDV,GAAOc,KAAKD,EAAIpB,EAAQU,SAAWS,MAIpCZ,EAAOF,KAAKL,EAAQW,YAU/BW,gBAzWU,SAyWMC,GACZA,EAAWzE,EAAMqC,SAASoC,EAC1B,IAAIC,GAASD,EAASE,MAAM,KACxBhG,EAAI2C,MAOR,OANkB,WAAdoD,EAAO,IAAiC,aAAdA,EAAO,IACjCA,EAAOE,QAEXF,EAAOG,QAAQ,SAAAC,GACXnG,EAAIA,EAAEmG,KAEHnG,GAoBXuF,MAvYU,SAuYJtE,EAAKmF,GACP,GAAIT,SACJ,KAAKA,IAAK1E,GAEN,GAAImF,EAASnF,EAAI0E,GAAIA,EAAG1E,MAAS,EAAO,OAkBhDuD,OA7ZU,SA6ZH6B,GACH,IAAKhF,EAAMO,SAASyE,GAAc,QADN,QAExBb,UAAK5F,SAFmB0G,EAAAC,UAAA7E,OAAT8E,EAASC,MAAAH,EAAA,EAAAA,EAAA,KAAAI,EAAA,EAAAA,EAAAJ,EAAAI,IAATF,EAASE,EAAA,GAAAH,UAAAG,EAmB5B,OAhBAF,GAAQN,QAAQ,SAAAS,GACZ,IAAKnB,IAAOmB,GACR/G,EAAQ+G,EAAOnB,GACXnE,EAAMW,QAAQpC,GACdyG,EAAYb,GAAO5F,EAAMgH,SAClBvF,EAAMe,OAAOxC,GACpByG,EAAYb,GAAO,GAAIqB,MAAKjH,GACrByB,EAAMU,WAAWnC,GACxByG,EAAYb,GAAO5F,EACZyB,EAAMO,SAAShC,GACtByG,EAAYb,GAAOnE,EAAMmD,UAAW5E,GAEpCyG,EAAYb,GAAO5F,IAIxByG,GAoBXS,MApcU,SAocJ7F,EAAKsD,GACP,IAAKtD,EAAK,QAENI,GAAMW,QAAQuC,KACdA,GAAYQ,KAAMR,IAEtBA,EAAUlD,EAAMmD,QACZO,KAAM,KACNgC,KAAK,GACNxC,EAEH,IAAIY,UACA6B,IAcJ,OAZA3F,GAAMkE,MAAMtE,EAAK,SAACrB,EAAO4F,IACrBL,EAAUZ,EAAQQ,KACZR,EAAQQ,KAAKU,QAAQD,IAAQ,EAC5BjB,EAAQwC,KAAO9F,EAAIN,eAAe6E,KAAUjB,EAAQwC,OAEnD1F,EAAMO,SAAShC,GACfoH,EAAOxB,GAAOnE,EAAMyF,MAAMlH,EAAO2E,GAEjCyC,EAAOxB,GAAO5F,KAInBoH,GAeXC,YA7eU,SA6eEhG,EAAKiG,GACb,GAAIC,KAQJ,OAPA9F,GAAMkE,MAAM2B,EAAQ,SAACtH,EAAO4F,GACpBnE,EAAMc,cAAcvC,GACpBuH,EAAO3B,GAAOnE,EAAM4F,YAAYhG,EAAKrB,GAErCuH,EAAO3B,GAAOvE,EAAIrB,KAGnBuH,GAiBXC,cAvgBU,SAugBInE,GACV,GAAIjD,GAAI,IACR,KACIA,EAAIqH,KAAKC,MAAMrE,GACjB,MAAOsE,IACT,MAAOvH,IAeXwH,KA3hBU,SA2hBLC,GACD,GAAIC,GAAKb,KAAKc,KACd,OAAOF,GAAUG,SAASF,EAAK,IAAM,IAAMA,GF2HnD5I,GAAQ+I,QEtHOxG,GF0HT,SAAUtC,EAAQD,EAASM,GAEjC,YAGAa,QAAOC,eAAepB,EAAS,cAC7Bc,OAAO,GG9qBT,IAAMkI,GAAuB,iCAUvBC,EAAQ9H,OAAO+H,QAQjBC,KAMIC,GAAI,kBAOJC,KAAM,kEAUNC,gBAAiBN,EAAuB,MAMxCO,mBAAoBP,EAAuB,aAM3CQ,mBAAoB,gDAMpBC,eAAgB,8CAMhBC,gBAAiB,+CAMjBC,uBAAwB,sDAS5BC,WAMIC,OAAQ,SAKRC,QAAS,UAKTC,UAAW,YAMXC,QAAS,WASbC,cAOIC,QAAS,UAQTC,mBAAoB,qBAOpBC,iBAAkB,mBAKlBC,YAAa,eASjBC,YAKIC,QAAS,UAMTC,QAAS,UAMTC,UAAW,YAYXC,QAAS,WAsBbC,YAKIC,OAAQ,EAKRC,SAAU,GASdC,WAKIC,IAAK,MAKLC,IAAK,MAKLC,KAAM,OAKNC,MAAO,SAYXC,iBAOIC,UAAW,YAQXC,YAAa,eASjBC,aAMIC,IAAK,MAMLC,MAAO,OAKPC,OAAQ,QAKRC,IAAK,MAKLC,IAAK,MAKLC,aAAc,iBHorBtB5L,GAAQ+I,QGhrBOE,GHorBT,SAAUhJ,EAAQD,EAASM,GAEjC,YAeA,SAASuL,GAAuB1J,GAAO,MAAOA,IAAOA,EAAIV,WAAaU,GAAQ4G,QAAS5G,GAEvF,QAAS2J,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCIhlBhH,QAASC,GAAoBC,GACzB,MAAKA,GACU,OAAXA,EAAwB,KACb,iBAAXA,EAAkCC,EAASC,KAAKC,UAChDF,EAASC,KAAKxK,eAAesK,GAAgBA,EAC1C,KAJaC,EAASC,KAAKE,iBAgBtC,QAASC,GAAoBC,GACzB,OAAQA,GACJ,IAAK,UACD,MAAOL,GAASC,KAAKK,eACzB,KAAK,qBACD,MAAON,GAASC,KAAKM,oBACzB,KAAK,aACD,MAAOP,GAASC,KAAKO,kBACzB,KAAK,wBACD,MAAOR,GAASC,KAAKQ,wBACzB,KAAK,WACD,MAAOT,GAASC,KAAKC,SACzB,KAAK,aACD,MAAOF,GAASC,KAAKS,WACzB,SACI,MAAO,OJkiBnB3L,OAAOC,eAAepB,EAAS,cAC3Bc,OAAO,GAGX,IAAIkB,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOL,UAAY,eAAkBO,IAElQ4K,EAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIzM,GAAI,EAAGA,EAAIyM,EAAMtK,OAAQnC,IAAK,CAAE,GAAI0M,GAAaD,EAAMzM,EAAI0M,GAAW7L,WAAa6L,EAAW7L,aAAc,EAAO6L,EAAW9L,cAAe,EAAU,SAAW8L,KAAYA,EAAWC,UAAW,GAAMjM,OAAOC,eAAe6L,EAAQE,EAAWzG,IAAKyG,IAAiB,MAAO,UAAUnB,EAAaqB,EAAYC,GAAiJ,MAA9HD,IAAYL,EAAiBhB,EAAYpK,UAAWyL,GAAiBC,GAAaN,EAAiBhB,EAAasB,GAAqBtB,MIp/BhiBuB,EAAAjN,EAAA,GJw/BIkN,EAAU3B,EAAuB0B,GI3+B/BnB,EJ4/BS,WIx+BX,QAAAA,KAAyD,GAA7CqB,GAA6ChG,UAAA7E,OAAA,GAAA6B,SAAAgD,UAAA,GAAAA,UAAA,GAAtC2E,EAASC,KAAKqB,cAAeC,EAASlG,UAAA,EAAAqE,GAAA1L,KAAAgM,GACrDuB,EAAUA,GAAW1I,OAAOwI,GAQ5BtM,OAAOC,eAAehB,KAAM,QACxBkB,YAAY,EACZ8L,UAAU,EACVtM,MAAO,aAUXK,OAAOC,eAAehB,KAAM,QACxBkB,YAAY,EACZ8L,UAAU,EACVtM,MAAO2M,IASXtM,OAAOC,eAAehB,KAAM,WACxBkB,YAAY,EACZ8L,UAAU,EACVtM,MAAO6M,IAGP1J,MAAMpC,eAAe,qBACrBoC,MAAM2J,kBAAkBxN,KAAMA,KAAKgC,aAOnCjB,OAAOC,eAAehB,KAAM,SACxBkB,YAAY,EACZ8L,UAAU,EACVtM,MAAQ,GAAImD,OAAM0J,GAAUE,QJgsCxC,MAnKAd,GAAaX,EAAU,OACnB1F,IAAK,SACL5F,MAAO,SIvgCGgN,GACV,GAAIA,YAAe1B,GACf,MAAO0B,EAGX,IAAIL,UAAMM,QAEV,IAAIP,EAAAzE,QAAMhF,gBAAgB+J,IAAQA,EAAIL,KAAM,CACxC,OAAQK,EAAIL,MACR,IAAK,GACDA,EAAOrB,EAASC,KAAK2B,iBACrB,MACJ,KAAK,GACDP,EAAOrB,EAASC,KAAK4B,oBACrB,MACJ,KAAK,GACDR,EAAOrB,EAASC,KAAK6B,OACrB,MACJ,SACIT,EAAOrB,EAASC,KAAKqB,cAG7B,MAAO,IAAItB,GAASqB,EAAMK,EAAIH,SAAW,IAS7C,MANmB,gBAARG,GACPL,EAAOM,EAAMD,EACS,YAAf,SAAOA,EAAP,YAAA9L,EAAO8L,MACdL,EAAOK,EAAIL,MAAQK,EAAIH,QACvBI,EAAMD,EAAIH,SAAWG,EAAIL,MAEzBA,GAAQrB,EAAS+B,iBAAiBV,GAC3B,GAAIrB,GAASqB,EAAMM,GAGvB,GAAI3B,GAASA,EAASC,KAAKqB,cAAeK,MJmiCjDrH,IAAK,eACL5F,MAAO,SI3gCSsN,GAAwB,GAAdT,GAAclG,UAAA7E,OAAA,GAAA6B,SAAAgD,UAAA,GAAAA,UAAA,GAAJ,EAqBpC,KAAK2G,EAAU,MAAO,IAAIhC,GAASA,EAASC,KAAKE,iBAEjD,IAAI8B,SAEJ,IAAIb,EAAAzE,QAAMtG,SAAS2L,KACfC,EAAUnC,EAAoBkC,IACjB,MAAO,IAAIhC,GAASiC,EAASV,GAAWS,EAGzD,KAAKZ,EAAAzE,QAAMjG,SAASsL,GAAW,MAAO,KAEtC,IAAIE,GAASF,EAASG,eACfH,EAASI,cACPJ,EAASK,OAASL,EAASK,MAAMd,SAAY,IAC/C,EAEP,IAAIS,EAASjC,SACTkC,EAAUnC,EAAoBkC,EAASjC,SAC1B,MAAO,IAAIC,GAASiC,EAASC,GAAUX,GAAWS,EAASjC,OAG5E,IAAIiC,EAASK,MAAO,CAChB,GAAIhC,GAAS2B,EAAS3B,QAAU2B,EAASK,MAAMhC,MAC/C,KAAKA,EAAQ,CACT,GAAIiC,GAASN,EAASK,MAAMC,MACxBlB,GAAAzE,QAAM7F,QAAQwL,IAAWA,EAAO9L,OAAS,IACzC6J,EAASiC,EAAO,GAAGjC,OACnB6B,EAASA,GAAUI,EAAO,GAAGf,SAIrC,MADAU,GAAU7B,EAAoBC,IAAWL,EAASC,KAAKqB,cAChD,GAAItB,GAASiC,EAASC,GAAU7B,GAAUkB,GAGrD,MAAIW,IACAD,EAAUnC,EAAoBoC,IAAWlC,EAASC,KAAKqB,cAChD,GAAItB,GAASiC,EAASC,GAAUX,IAGpC,QJshCPjH,IAAK,aACL5F,MAAO,SI7gCOgN,GACd,MAAOA,aAAe1B,MJyhCtB1F,IAAK,mBACL5F,MAAO,SIhhCa6N,GACpB,GAAIC,SACJ,KAAKA,IAAQxC,GAASC,KAClB,GAAID,EAASC,KAAKxK,eAAe+M,IACtBD,IAAcvC,EAASC,KAAKuC,GACnC,OAAO,CAGf,QAAO,MJmhCJxC,II1gCXA,GAASxK,UAAUU,SAAW,WAC1B,GAAIyL,GAAM3N,KAAKqN,OAASrN,KAAKuN,QAAnB,KAAkCvN,KAAKuN,QAAvC,IAAoD,EAC9D,OAAUvN,MAAKY,KAAf,KAAwBZ,KAAKqN,KAAOM,GAOH,kBAA1B5M,QAAO0N,eACd1N,OAAO0N,eAAezC,EAASxK,UAAWqC,MAAMrC,WAEhDwK,EAASxK,UAAYT,OAAO2N,OAAO7K,MAAMrC,WAa7CwK,EAASC,MAKL0C,0BAA2B,4BAK3BC,sBAAuB,wBAMvBhB,kBAAmB,oBAMnBC,qBAAsB,uBAOtBC,QAAS,UAKTe,mBAAoB,qBAKpB1C,iBAAkB,mBAMlBG,gBAAiB,kBAOjBwC,eAAgB,iBAMhBC,eAAgB,iBAKhBC,kBAAmB,oBAKnBC,iBAAkB,mBAQlBxC,yBAA0B,2BAK1BF,qBAAsB,uBAOtBC,mBAAoB,qBAOpB0C,sBAAuB,wBAMvBC,wBAAyB,0BAKzBC,uBAAwB,yBAKxB1C,YAAa,cAMbR,UAAW,YAKXmD,eAAgB,iBAKhB/B,cAAe,iBJskCnB1N,EAAQ+I,QIphCOqD,GJwhCT,SAAUnM,EAAQD,EAASM,GAEjC,YAaA,SAASuL,GAAuB1J,GAAO,MAAOA,IAAOA,EAAIV,WAAaU,GAAQ4G,QAAS5G,GAEvF,QAAS2J,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCKnjChH,QAASyD,GAAKC,EAAQlK,EAAS6B,GAK3B,MAJA7B,GAAU+H,EAAAzE,QAAMtG,SAASgD,IACjBlB,IAAKkB,GACPA,MACNA,EAAQkK,OAASA,EACVC,EAAMC,IAAIpK,EAAS6B,GLkiC9BnG,OAAOC,eAAepB,EAAS,cAC3Bc,OAAO,GAGX,IAAIiM,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIzM,GAAI,EAAGA,EAAIyM,EAAMtK,OAAQnC,IAAK,CAAE,GAAI0M,GAAaD,EAAMzM,EAAI0M,GAAW7L,WAAa6L,EAAW7L,aAAc,EAAO6L,EAAW9L,cAAe,EAAU,SAAW8L,KAAYA,EAAWC,UAAW,GAAMjM,OAAOC,eAAe6L,EAAQE,EAAWzG,IAAKyG,IAAiB,MAAO,UAAUnB,EAAaqB,EAAYC,GAAiJ,MAA9HD,IAAYL,EAAiBhB,EAAYpK,UAAWyL,GAAiBC,GAAaN,EAAiBhB,EAAasB,GAAqBtB,MKr/ChiBuB,EAAAjN,EAAA,GLy/CIkN,EAAU3B,EAAuB0B,GKj/C/BqC,EL6/CM,WACR,QAASA,KACL9D,EAAgB1L,KAAMwP,GAyc1B,MAtcA7C,GAAa6C,EAAO,OAChBlJ,IAAK,QA0GL5F,MAAO,SKpgDE2E,EAAS6B,GAoDlB,QAASwI,GAAOhC,EAAKiC,EAAQ5N,GACrB6N,IACAC,aAAaD,GACbA,EAAU,OAETD,GAAUtK,EAAQyK,QAAUC,EAAOC,YACpCD,EAAOC,WAAWC,YAAYF,GAG9BG,SACOxQ,GAAKyQ,GAEhBjJ,EAASwG,EAAK3L,GA/DlB,GAAI6N,SAUJ,IARA1I,EAAWkG,EAAAzE,QAAM9F,WAAWqE,GACtBA,EACAkG,EAAAzE,QAAMvG,KAERgL,EAAAzE,QAAMtG,SAASgD,KACfA,GAAYlB,IAAKkB,KAGjB+H,EAAAzE,QAAM1F,cAAcoC,GAapB,MAAO6B,GAAS,GAAIrD,OAAM,yCAG9B,IAfIwB,EAAU+H,EAAAzE,QAAMrD,QAEZ8K,OAAO,EACPC,OAAO,EAEPT,QAAS,EACThK,UAGAkK,OAAO,GACRzK,GAKH+H,EAAAzE,QAAMtG,SAASgD,EAAQlB,QAAS,GAAgC,KAAvBkB,EAAQlB,IAAI5B,OACrD,MAAO2E,GAAS,GAAIrD,OAAM,8BAG9B,IAAIkM,GAASO,SAASC,cAAc,UAChCC,EAAapD,EAAAzE,QAAMtG,SAASgD,EAAQoL,gBACI,KAAjCpL,EAAQoL,cAAclO,OAC7B4N,SACAzQ,SACAwQ,EAAc9C,EAAAzE,QAAMtG,SAASgD,EAAQqL,WACT,WAArBrL,EAAQqL,UACa,aAArBrL,EAAQqL,UACoB,KAA5BrL,EAAQqL,SAASnO,MAExBiO,KACAL,EAAW,UAAY/C,EAAAzE,QAAM7D,aAAa,IAC1CO,EAAQO,OAAOP,EAAQoL,eAAiBP,EAC/B7K,EAAQqL,SADuB,IACXP,EACvBA,EAEV,IAAIQ,GAAQvD,EAAAzE,QAAM/C,OAAOP,EAAQO,SAAW,GACxCgL,EAAQvL,EAAQlB,IAAIoC,QAAQ,MAAQ,EAAI,IAAM,IAC9CpC,EAAMwM,KAAWtL,EAAQlB,IAAMyM,EAAQD,EAAUtL,EAAQlB,GAkB7D,IAAIgM,EAAU,CACV,GAAIU,GAAK,SAAA9O,GACL2N,EAAO,MAAM,EAAO3N,GAExBrC,GAAOwQ,EAED9C,EAAAzE,QAAMhC,gBAAgBtB,EAAQqL,UAC9BjN,OACN/D,EAAKyQ,GAAYU,MACVd,GAAOe,WACdf,EAAOgB,mBAAqB,WACE,WAAtBhB,EAAOe,YACsB,aAAtBf,EAAOe,aACdf,EAAOgB,mBAAqB,KAC5BrB,EAAO,QAIfK,EAAOiB,OAAS,WACZtB,EAAO,MAIfK,GAAOkB,QAAU,SAAA5C,GACb,GAAIH,GAAS,4BAA8Bd,EAAAzE,QAAM7E,YAAYuB,EAAQlB,IACjEkK,KACAH,GAAU,MAAQG,EAAMd,SAAWc,IAEvCqB,EAAO,GAAI7L,OAAMqK,KAGjB7I,EAAQ1C,OACRoN,EAAOpN,KAAO0C,EAAQ1C,MAEtB0C,EAAQ6L,UACRnB,EAAOmB,QAAU7L,EAAQ6L,SAEzB7L,EAAQ+K,QACRL,EAAOK,OAAQ,GAEf/K,EAAQgL,QACRN,EAAOM,OAAQ,GAEfhL,EAAQ8L,cACRpB,EAAOoB,YAAc9L,EAAQ8L,aAGjCpB,EAAOqB,IAAMjN,EACbmM,SAASe,qBAAqB,QAAQ,GAAGC,YAAYvB,GAGjD3C,EAAAzE,QAAMlG,SAAS4C,EAAQuK,UAAYvK,EAAQuK,QAAU,IACrDA,EAAU2B,WAAW,WACjBxB,EAAOqB,IAAM,GACb1B,EAAO,GAAI7L,OAAM,yBAAyB,IAC3CwB,EAAQuK,aLsjDftJ,IAAK,MACL5F,MAAO,QAAS+O,GKhgDTpK,EAAS6B,GAChB,GAAIuI,UAAK/B,QAET,MAAI,kBAAoBjK,SAGpB,KAAM,IAAII,OAAM,mCAFhB4L,GAAM,GAAI+B,eAKd,IAAIC,GAAcrE,EAAAzE,QAAM9F,WAAWqE,EACnCA,GAAWuK,EACLvK,EACAkG,EAAAzE,QAAMvG,KAERgL,EAAAzE,QAAMtG,SAASgD,KACfA,GAAYlB,IAAKkB,IAGjB+H,EAAAzE,QAAM1F,cAAcoC,GACpBA,EAAU+H,EAAAzE,QAAMrD,QACZiK,OAAQ,MACRmC,KAAMrN,OACN+L,OAAO,EACPR,QAAS,EACT+B,iBAAiB,EACjBC,SAAUvN,OACVwN,SAAU,GACVC,SAAU,IACXzM,GAEH6B,EAAS,GAAIrD,OAAM,0CAGnBuJ,EAAAzE,QAAMtG,SAASgD,EAAQlB,QAAS,GAChC+C,EAAS,GAAIrD,OAAM,+BAGvBwB,EAAQwM,SAAWhN,OAAOQ,EAAQwM,UAClCxM,EAAQyM,SAAWjN,OAAOQ,EAAQyM,UAClCzM,EAAQkK,OAASlK,EAAQkK,OAAO5J,cACT,SAAnBN,EAAQkK,QAAwC,QAAnBlK,EAAQkK,SACrClK,EAAQqM,KAAOrN,QAIfoN,IACAhC,EAAIsB,mBAAqB,WACrB,GAAItB,EAAIqB,aAAetB,EAAMuC,gBAAgBC,KACzC,GAAmB,MAAfvC,EAAI1D,OACJ7E,EAAS,KAAMuI,OACZ,CAGH,GAAIwC,GAA6B,IAAfxC,EAAI1D,OAChB,qEACA,EACN2B,GAAM,GAAI7J,OAAJ,gCAA0C4L,EAAI1D,OAASkG,GAE7D/K,EAASwG,EAAK+B,KAKtBrC,EAAAzE,QAAMlG,SAAS4C,EAAQuK,UAAYvK,EAAQuK,QAAU,IACrDH,EAAIG,QAAUvK,EAAQuK,QACtBH,EAAIyC,UAAY,WAEZxE,EAAM,GAAI7J,OAAM,8BAChBqD,EAASwG,EAAK+B,MAK1BA,EAAI0C,KAAK9M,EAAQkK,OAAQlK,EAAQlB,IAAKkB,EAAQ+K,MAAO/K,EAAQwM,SAAUxM,EAAQyM,UAI3E1E,EAAAzE,QAAM1F,cAAcoC,EAAQ+M,UAC5BrR,OAAO8E,KAAKR,EAAQ+M,SAASpL,QAAQ,SAAAV,GACjC,GAAI5F,GAAQ2E,EAAQ+M,QAAQ9L,EAC5BmJ,GAAI4C,iBAAiB/L,EAAK5F,KAK9B2E,EAAQuM,UACRnC,EAAI6C,iBAAiBjN,EAAQuM,UAGjCnC,EAAI8C,KAAKlN,EAAQqM,SLghDjBpL,IAAK,MACL5F,MAAO,SKhgDA2E,EAAS6B,GAChB,MAAOsI,GAAMC,IAAIpK,EAAS6B,MLmhD1BZ,IAAK,OACL5F,MAAO,SKngDC2E,EAAS6B,GACjB,MAAOoI,GAAK,OAAQjK,EAAS6B,MLshD7BZ,IAAK,MACL5F,MAAO,SKtgDA2E,EAAS6B,GAChB,MAAOoI,GAAK,MAAOjK,EAAS6B,MLyhD5BZ,IAAK,SACL5F,MAAO,SKzgDG2E,EAAS6B,GACnB,MAAOoI,GAAK,SAAUjK,EAAS6B,OL6gD5BsI,IKv/CXA,GAAMuC,iBAKFS,OAAQ,EAKRC,OAAQ,EAKRC,iBAAkB,EAKlBC,QAAS,EAKTX,KAAM,GL+gDVpS,EAAQ+I,QK5gDO6G,GLghDT,SAAU3P,EAAQD,EAASM,GAEjC,YAmCA,SAASuL,GAAuB1J,GAAO,MAAOA,IAAOA,EAAIV,WAAaU,GAAQ4G,QAAS5G,GAEvF,QAAS2J,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCM1OhH,QAAS+G,GAAoBlS,GACzB,OAAQ0M,EAAAzE,QAAMtG,SAAS3B,KACf0M,EAAAzE,QAAM7F,QAAQpC,KACd0M,EAAAzE,QAAM1F,cAAcvC,GAehC,QAASmS,GAAenF,EAAK+B,GACzB,GAAI/B,EAAK,MAAOoF,GAAAnK,QAAS+F,OAAOhB,EAChC,KAAK+B,EAAK,MAAO,IAAAqD,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK8C,eAC5C,IAAIf,GAAWZ,EAAAzE,QAAMT,cAAcuH,EAAIsD,aAGvC,OAAOD,GAAAnK,QAASqK,aAAahF,IAAaA,EAW9C,QAASiF,GAAe5N,GACpB,KAAKA,GAAYA,EAAQ6N,eAAiB7N,EAAQ8N,UAAY9N,EAAQ+N,KAAO/N,EAAQgO,aAC5EC,EAAWC,EAAEC,OAAOC,OAAOnN,IAC5B,KAAM,IAAAwM,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAKO,mBAAoB,2DAkBjE,QAASkH,GAAWC,EAAYrP,GAoB5B,MAnBI8I,GAAAzE,QAAMjG,SAASiR,GACfA,EAAWC,OAAStP,EAASuP,OAE7BF,GACIG,QAASH,EACTC,OAAQtP,EAASuP,QAIrBvP,EAASyP,mBACTJ,EAAWK,MAAQ1P,EAASyP,mBAG3BJ,EAAWM,MACL3P,EAASuP,QACTzG,EAAAzE,QAAMlG,SAAS6B,EAASuP,OAAOK,WAC/B5P,EAASuP,OAAOK,SAAW,OAClCP,EAAWM,KAAO,IAEfN,EAeX,QAASQ,GAAgB9O,GACrB,GAAI+O,GAAO/O,EAAQyO,QAKfO,EAAUD,EAAKE,mBACflB,EAAOiB,GAAWA,EAAQ1I,UAAa,KACvC4I,EAAUF,GAAWA,EAAQE,QAAW,KACxCC,EAAcH,GAAWA,EAAQG,YAAe,KAChDZ,EAAS,GAAIH,QAAOgB,KAAKC,OAAOrP,EAAQuO,OAAOe,SAAUtP,EAAQuO,OAAOgB,WACxEjB,GACIkB,UAAWxP,EAAQwP,UACnBjB,OAAQA,EACRK,KAAM5O,EAAQ4O,KACda,OAAQzP,EAAQyP,QAAU,KA6ClC,OAxCI1B,GACAA,EAAI2B,WAAWpB,GAEfP,EAAM,GAAIK,QAAOgB,KAAKO,IAAI3P,EAAQyO,QAASH,GAI3Ca,IAAYA,EAAa,MACzBD,GAAUA,YAAkBd,QAAOgB,KAAKQ,SACxCxB,OAAOgB,KAAKS,MAAMC,uBAAuBZ,GACzCA,EAAOa,OAAO,MACdb,EAAS,MAKTlP,EAAQkP,SACRA,EAAS,GAAId,QAAOgB,KAAKQ,QACrBI,SAAU1B,EAAWC,OACrBR,IAAKA,IAEL/N,EAAQ2O,QACRQ,EAAa,GAAIf,QAAOgB,KAAKa,WAC7Bd,EAAWe,WAAWlQ,EAAQ2O,OAE9BP,OAAOgB,KAAKS,MAAMM,YAAYjB,EAAQ,QAAS,WAC3CC,EAAWrC,KAAKiB,EAAKmB,OAKjCF,GACIP,QAASM,EACTzI,SAAUyH,EACVmB,OAAQA,EACRC,WAAYA,EACZnP,QAASsO,GAGbS,EAAKE,mBAAqBD,EACnBA,EAUX,QAASoB,GAAgBnR,EAAUe,GAC/B,GAAKf,GAAaA,EAASoR,QAA3B,CACA,GAAIC,UACAD,EAAUpR,EAASoR,OAMvB,IALItI,EAAAzE,QAAMtG,SAASqT,EAAQE,cAA+C,IAA/BF,EAAQE,YAAYpT,OAC3DmT,EAAKD,EAAQE,YACNxI,EAAAzE,QAAMtG,SAASqT,EAAQG,UAAuC,IAA3BH,EAAQG,QAAQrT,SAC1DmT,EAAKD,EAAQG,SAEZF,IACLrR,EAASwR,KAAOC,EAAApN,QAAMI,IAAIE,KAAO0M,EAAGK,cAAgB,OAChD3Q,EAAQgO,WAAW,CACnB,GAAI4C,GAAO7I,EAAAzE,QAAM1F,cAAcoC,EAAQgO,WACjCjG,EAAAzE,QAAMf,MAAMvC,EAAQgO,aAE1B4C,GAAKrC,OAAStP,EAASuP,OACvBvP,EAAS+O,UAAYC,EAAW4C,aAAaD,KAerD,QAASE,GAAY9Q,EAAS6B,GAC1B,MAAO,UAAYwG,EAAKpJ,GACpB,MAAIoJ,GAAYxG,EAAS4L,EAAAnK,QAAS+F,OAAOhB,GAAM,OAC/C+H,EAAgBnR,EAAUe,GACrBA,EAAQ+N,KACb/N,EAAQ+N,IAAMM,EAAWrO,EAAQ+N,IAAK9O,OACtCgP,GAAW8C,UAAU/Q,EAAQ+N,IAAK,SAAC/E,EAAO+E,GACtC,MAAI/E,GAAcnH,EAASmH,EAAO,OAClC/J,EAAS8O,IAAMA,EACRlM,EAAS,KAAM5C,OALD4C,EAAS,KAAM5C,KAqBhD,QAAS+R,GAAQC,EAASjR,EAAS6B,GAC/B+L,IACAsD,EAAA5N,QAAU0N,QACNC,EACAhD,EAAWC,EAAEC,OACbnO,EACA8Q,EAAY9Q,EAAS6B,IAe7B,QAASsP,GAAwBlS,EAAUe,EAAS6B,GAKhD,QAASuP,GAAMC,GACXpD,EAAWqD,YAAYC,EAAI/C,OAAQ,SAACnG,EAAKyF,GACrC,GAAIzF,EACA,MAAOgJ,GAAGhJ,EAAK,YAEZyF,GAAS0D,UAChBD,EAAIzD,SAAWA,EACfyD,EAAIC,UAAYzJ,EAAAzE,QAAML,OACtBoO,EAAG,KAAME,KAZjB,GAAIA,GAAMxJ,EAAAzE,QAAMf,MAAMtD,GAAYuD,KAAK,GACvC,KAAKxC,EAAQ6N,gBAAkB7N,EAAQ8N,SACnC,MAAOjM,GAAS,KAAM0P,EAatBvR,GAAQ6N,cACRI,EAAWwD,eAAeF,EAAI/C,OAAQ,SAACnG,EAAKqJ,GACxC,GAAIrJ,EAAK,MAAOxG,GAASwG,EAAK,KAC9BkJ,GAAMxJ,EAAAzE,QAAMrD,UAAWyR,EAAQH,GAC/BA,EAAIlB,QAAUqB,EAAOrB,QACrBkB,EAAIC,UAAYzJ,EAAAzE,QAAML,OACjBjD,EAAQ8N,SAGTsD,EAAMvP,GAFNA,EAASwG,EAAKkJ,KAKfvR,EAAQ8N,SACfsD,EAAMvP,GAENA,EAAS,KAAM0P,GAgBvB,QAASI,GAAe3R,EAAS4R,EAAoBC,GAOjD,QAASC,KACAP,EAGDK,EAAmBL,GAFnBM,EAAgB,GAAApE,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK4B,uBARnD,GAAI+I,UACAQ,SACAC,EAAcjK,EAAAzE,QAAM9F,WAAWwC,EAAQgS,YAEjChS,EAAQgS,WADRjK,EAAAzE,QAAMvG,IAWhBgV,GAAU9D,EAAWgE,MAAMjS,EAAS,SAACqI,EAAKpJ,GACtC,GAAIoJ,EACA,MAAO0J,GAAQG,MAAM,WACjBL,EAAgBxJ,IAGxBkJ,GAAMtS,EAED8S,EAAQI,MAAQ,GAAOZ,EAAI/C,OAAOK,UAAY7O,EAAQoS,gBACvDL,EAAQG,MAAMJ,GAEdE,EAAWT,KAGnBQ,EAAQG,MAAMlS,EAAQqS,YAAc,IAAKP,GAG7C,QAASQ,GAAUtS,GACf,GAAIuS,GAAOtE,EAAWC,EAAEC,MACxB,OAAQpG,GAAAzE,QAAM5F,cAAcsC,EAAQyP,QAE9BzP,EAAQyP,OADP1H,EAAAzE,QAAM5F,cAAc6U,EAAKnE,OAAOqB,QAAU8C,EAAKnE,OAAOqB,OAAS,KNxH1E/T,OAAOC,eAAepB,EAAS,cAC3Bc,OAAO,GAGX,IAAIkB,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOL,UAAY,eAAkBO,IAElQ4K,EAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIzM,GAAI,EAAGA,EAAIyM,EAAMtK,OAAQnC,IAAK,CAAE,GAAI0M,GAAaD,EAAMzM,EAAI0M,GAAW7L,WAAa6L,EAAW7L,aAAc,EAAO6L,EAAW9L,cAAe,EAAU,SAAW8L,KAAYA,EAAWC,UAAW,GAAMjM,OAAOC,eAAe6L,EAAQE,EAAWzG,IAAKyG,IAAiB,MAAO,UAAUnB,EAAaqB,EAAYC,GAAiJ,MAA9HD,IAAYL,EAAiBhB,EAAYpK,UAAWyL,GAAiBC,GAAaN,EAAiBhB,EAAasB,GAAqBtB,MMhhEhiBuB,EAAAjN,EAAA,GNohEIkN,EAAU3B,EAAuB0B,GMnhErC0K,EAAA3X,EAAA,GNuhEI4X,EAAUrM,EAAuBoM,GMthErCE,EAAA7X,EAAA,GN0hEIqW,EAAQ9K,EAAuBsM,GMzhEnCC,EAAA9X,EAAA,GN6hEI4S,EAAQrH,EAAuBuM,GM5hEnCC,EAAA/X,EAAA,GNgiEIgY,EAAQzM,EAAuBwM,GM/hEnCE,EAAAjY,EAAA,GNmiEI6V,EAAUtK,EAAuB0M,GM5hE/BC,EAAkB,KAOlBC,EAAkB,KAQlBC,GACFC,SAAU,KACVnU,OAAO,EACPqP,QACI+E,QAAS,IACTlS,IAAK,GACLwO,OAAQ,OA8BVxB,ENwiEW,WACb,QAASA,KACL5H,EAAgB1L,KAAMsT,GAy0D1B,MAt0DA3G,GAAa2G,EAAY,OACrBhN,IAAK,SA0DL5F,MAAO,SMj+DG2E,GAIV,MAHIA,KACAiO,EAAWC,EAAEC,OAASpG,EAAAzE,QAAMrD,OAAOgT,EAAejT,IAE/CiO,EAAWC,EAAEC,UNslEpBlN,IAAK,eACL5F,MAAO,SMp+DS2E,EAAS6B,GACzB,IAAKkG,EAAAzE,QAAM1F,cAAcoC,KAAaA,EAAQuO,OAC1C,KAAM,IAAAd,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK4C,mBAC7B,gDAGR,IAAIzB,EAAAzE,QAAMtG,SAASgD,EAAQuO,QACvB,MAAON,GAAW+C,QAAQhR,EAAQuO,OAAQ,SAAClG,EAAKpJ,GACxCoJ,GAAKxG,EAASwG,GAClBrI,EAAQuO,OAAStP,EAASuP,OAC1B3M,EAAS,KAAMoM,EAAW4C,aAAa7Q,KAI/C,IAAIuS,GAAOtE,EAAWC,EAAEC,OACpByC,EAAO7I,EAAAzE,QAAMrD,QACbuP,UAAWkB,EAAApN,QAAMa,UAAUE,QAC3B+O,MACIC,MAAO,IACPC,OAAQ,KAEZC,MAAO,EACP3E,KAAM,EACNM,OAAQ,MACRsE,OAAQ9C,EAAApN,QAAMuC,YAAYC,IAC1BoN,SAAUX,EAAKW,UAAY,KAC3BO,OAAQ,MACTzT,GAECuO,EAASxG,EAAAzE,QAAM1F,cAAcgT,EAAKrC,QAC7BqC,EAAKrC,OAAOe,SADR,IACoBsB,EAAKrC,OAAOgB,UACvC/P,OAAOoR,EAAKrC,QAEd6E,EAAOrL,EAAAzE,QAAM1F,cAAcgT,EAAKwC,MAC3BxC,EAAKwC,KAAKC,MADR,IACiBzC,EAAKwC,KAAKE,OAChC9T,OAAOoR,EAAKwC,MAEdtU,EAAM4R,EAAApN,QAAMI,IAAII,mBAAV,WACOyK,EADP,YACyBqC,EAAKpB,UAD9B,SAEK4D,EAFL,UAEmBxC,EAAK2C,MAFxB,SAEsC3C,EAAKhC,KAF3C,WAGOgC,EAAK4C,OAHZ,aAG+B5C,EAAKsC,QAE9C,IAAItC,EAAK1B,OAAQ,CACb,GAAIwE,GAAQ3L,EAAAzE,QAAMtG,SAAS4T,EAAK1B,QAAU0B,EAAK1B,OAAS,KACxDpQ,IAAO,YAAcO,4BAA4BqU,EAA5B,IAAqCnF,GAE1DqC,EAAK6C,SAAQ3U,GAAO,WAAa8R,EAAK6C,QACtClB,EAAKnE,OAAOnN,MAAKnC,GAAO,QAAUyT,EAAKnE,OAAOnN,IAElD,IAAIwO,GAAS6C,EAAU1B,EAGvB,OAFInB,KAAQ3Q,GAAO,IAAMoS,EAAA5N,QAAUqQ,kBAAkBlE,IAEjD1H,EAAAzE,QAAM9F,WAAWqE,GAAkBA,EAAS,KAAM/C,GAC/CA,KNwiEPmC,IAAK,YACL5F,MAAO,SMh+DM2E,EAAS6B,GAGjBkG,EAAAzE,QAAM1F,cAAcoC,KACrBA,GAAYyO,QAASzO,IAGzBA,EAAU+H,EAAAzE,QAAMrD,QACZwO,QAAS,KACTe,UAAWkB,EAAApN,QAAMa,UAAUE,QAC3BsK,MAAO3P,OACPkQ,QAAQ,EACRN,KAAM,GACP5O,EAEH,IAAIgD,GAAIhD,EAAQyO,QACZM,QASJ,IARIhH,EAAAzE,QAAMtG,SAASgG,GACf+L,EAAO9D,SAAS2I,eAAe5Q,GACxB+E,EAAAzE,QAAMnF,eAAe6E,GAC5B+L,EAAO/L,EAAE,GACFiL,EAAW4F,kBAAoB7Q,YAAaoL,QAAOgB,KAAKO,MAC/DZ,EAAO/L,EAAE8Q,WAGR/L,EAAAzE,QAAMxF,UAAUiR,KAAUhH,EAAAzE,QAAMrF,OAAO8Q,GACxC,KAAM,IAAAtB,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK4C,mBAC7B,iEAGR,KAAKzB,EAAAzE,QAAM1F,cAAcoC,EAAQuO,UACrBxG,EAAAzE,QAAMlG,SAAS4C,EAAQuO,OAAOe,YAC9BvH,EAAAzE,QAAMlG,SAAS4C,EAAQuO,OAAOgB,WACtC,KAAM,IAAA9B,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK4C,mBAC7B,mDAGRxJ,GAAQyO,QAAUM,CAElB,IAAIwD,GAAOtE,EAAWC,EAAEC,OACpBlN,EAAMsR,EAAKnE,OAAOnN,GACtBjB,GAAQyP,OAAS6C,EAAUtS,GAE3BiO,EAAW8F,mBAAmB9S,EAAK,SAAAoH,GAC/B,GAAIA,EACA,KAAM,IAAAoF,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK+C,kBAAmBnK,OAAO6I,EAAIH,SAAWG,GAI9ExG,GAAS,KADKiN,EAAgB9O,SNsnElCiB,IAAK,SACL5F,MAAO,SM/9DG2E,EAAS6B,GA2BnB,QAASmS,GAAahL,GAClB,GAAIhJ,EAAQgU,aACR,MAAO/F,GAAWgG,WAAWjU,EAAS,SAACqI,EAAKpJ,GACxC,MAAIoJ,GAAYgJ,EAAGhJ,EAAK,MACjBgJ,EAAG,KAAMpS,IAGxBoS,GAAGrI,EAAO,MAEd,QAAS4I,GAAmB3S,GACxBkS,EAAwBlS,EAAUe,EAASqR,GAE/C,QAASQ,GAAgBxJ,GACrBA,EAAMoF,EAAAnK,QAAS+F,OAAOhB,GACtB2L,EAAa3L,GAxCjBrI,EAAU+H,EAAAzE,QAAMrD,QACZiU,oBAAoB,EACpB3J,QAAS,IACT8H,YAAa,IACb8B,WAAY,EACZ/B,gBAAiB,GACjBJ,WAAYjK,EAAAzE,QAAMvG,KAClBiX,cAAc,EACdnG,eAAe,EACfC,UAAU,EACVC,IAAK/O,OACLgP,WAAW,GACZhO,GAGCA,EAAQkU,qBAAoBlU,EAAQmU,WAAa,GAEjDnU,EAAQuK,QAAU,MAAMvK,EAAQuK,QAAU,KAE1CvK,EAAQqS,YAAcrS,EAAQuK,UAASvK,EAAQqS,YAAcrS,EAAQuK,SAGzEqD,EAAe5N,EAEf,IAAIqR,GAAKP,EAAY9Q,EAAS6B,EAmB9B,IAAIoM,EAAWmG,yBACPpU,EAAQkU,mBACRvC,EAAe3R,EAAS4R,EAAoBC,GAE5CwC,UAAUC,YAAYC,mBAAmB3C,EAAoBC,EAAiB7R,OAE/E,CAEHgU,EADU,GAAAvG,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK0C,gCNmjEzCrI,IAAK,iBACL5F,MAAO,SMl+DW2E,EAAS6B,GAC3B,IAAKkG,EAAAzE,QAAM1F,cAAcoC,GACrB,KAAM,IAAAyN,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK4C,mBAGrC,IAAI6H,GAAKP,EAAY9Q,EAAS6B,EAE9B7B,GAAU+H,EAAAzE,QAAMrD,QACZuU,sBAAuBxV,OACvByV,sBAAuBzV,OACvB0V,UAAW1V,OACX2V,QAAS3V,OACTgV,cAAc,EACdY,WAAY5V,OACZ6V,iBAAkB7V,OAClB6O,eAAe,EACfC,UAAU,EACVC,IAAK/O,OACL8V,KAAK,GACN9U,GAEHA,EAAQ+U,WAAa/U,EAAQgU,aAE7BpG,GAEA,IAAI2E,GAAOtE,EAAWC,EAAEC,OACpBlN,EAAMsR,EAAKnE,OAAOnN,KAAO,GACzBnC,EAAMiJ,EAAAzE,QAAMzE,YAAY6R,EAAApN,QAAMI,IAAIK,mBAAoBwO,EAAKxT,OAC3DiW,GACIlW,IAAQA,EAAR,QAAmBmC,EACnB8L,SACIkI,eAAgB,oBAEpB5I,KAAMvJ,KAAKoS,UAAUlV,GAI7ByS,GAAAnP,QAAM6R,KAAKH,EAAS,SAAC3M,EAAK+B,GACtB,GAAIzB,GAAW6E,EAAenF,EAAK+B,EACnC,IAAIqD,EAAAnK,QAAS8R,WAAWzM,GAAW,MAAO0I,GAAG1I,EAAU,KAEvDA,GAAW3I,EAAQ8U,IAAMnM,GACrB6F,QACIc,SAAU3G,EAAS1J,SAASoW,IAC5B9F,UAAW5G,EAAS1J,SAASqW,IAC7BzG,SAAUlG,EAASkG,UAEvB2C,UAAWzJ,EAAAzE,QAAML,QAGrBkO,EAAwBxI,EAAU3I,EAASqR,QNykE/CpQ,IAAK,aACL5F,MAAO,SMr+DO2E,EAAS6B,GAEvB,GAAIO,GAAS6L,EAAWC,EAAEqH,WAE1B,KAAKxN,EAAAzE,QAAM1F,cAAcwE,GACrB,KAAM,IAAAqL,GAAAnK,QACFmK,EAAAnK,QAASsD,KAAK2C,sBACd,2EAKRqE,GAAe5N,MAEf,IAAIwV,IACA1W,IAAKsD,EAAOtD,IACZiM,OAAO,EACPN,OAAO,EAGX,IAAIrI,EAAOgJ,cACPoK,EAAUpK,cAAgBhJ,EAAOgJ,cACjCoK,EAAUnK,SAAW,sBAClB,KAAKjJ,EAAOqT,UACf,KAAM,IAAAhI,GAAAnK,QACFmK,EAAAnK,QAASsD,KAAK2C,sBACd,qEAGR,OAAOkJ,GAAAnP,QAAMoS,MAAMF,EAAW,SAACnN,EAAKM,GAChC,MAAIN,GACOxG,EAAS4L,EAAAnK,QAAS+F,OAAOhB,GAAM,OAEtCjG,EAAOqT,YACHrX,OAAOgE,EAAOqT,YACd9M,EAAWZ,EAAAzE,QAAMf,MAAMnE,OAAOgE,EAAOqT,kBAC9BrX,QAAOgE,EAAOqT,YAErB9M,EAAW,MAGdA,GAIDZ,EAAAzE,QAAM1F,cAAcwE,EAAOO,UAC3BgG,EAAWZ,EAAAzE,QAAMZ,YAAYiG,EAAUvG,EAAOO,SAElDgG,EAASgN,SAAWvT,EAAOuT,UAAY,UACvCvF,EAAgBzH,EAAU3I,GACtB2I,EAAS6F,SACT7F,EAAS6F,OAAOc,SAAWsG,OAAOjN,EAAS6F,OAAOc,UAClD3G,EAAS6F,OAAOe,UAAYqG,OAAOjN,EAAS6F,OAAOe,gBAGvD4B,GAAwBxI,EAAU3I,EADzB8Q,EAAY9Q,EAAS6B,MAZ1BwG,EAAM,GAAAoF,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAKE,kBAC1BjF,EAASwG,EAAK,aN4hE7BpH,IAAK,iBACL5F,MAAO,SMl+DW2E,GAClB,IAAK+H,EAAAzE,QAAM1F,cAAcoC,GACrB,KAAM,IAAAyN,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK4C,mBAAoB,oCAEzD,KAAKzB,EAAAzE,QAAMrG,YAAY+C,EAAQlB,KAC3B,KAAM,IAAA2O,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK4C,mBAAoB,yCAKzDyE,GAAWC,EAAEqH,YAAc7Z,OAAO+H,OAAOzD,MN6jEzCiB,IAAK,QACL5F,MAAO,SMr+DE2E,EAAS6B,GAsBlB,QAASgU,GAAkB5W,GACvB,GAAI6W,GAAM/N,EAAAzE,QAAMf,MAAMtD,GAAYuD,KAAK,GACvC,IAAIgF,EAAQ,CACR,GAAIuO,GAAW9H,EAAW+H,cACtBC,KAAMhX,EAASuP,OACf0H,GAAI1O,EACJ2O,QAASlI,EAAWvI,gBAAgBC,UACpCyQ,WAAY5O,EAAO4O,YAEvBN,GAAIO,cAAgBN,GAAYvO,EAAO8O,OACnCvE,GAAW+D,EAAIO,eACftE,EAAQG,MAAM,WACV,MAAOrQ,GAAS,KAAMiU,KAIlC,MAAOjU,GAAS,KAAMiU,GAE1B,QAASjE,GAAgBxJ,GACrBxG,EAAS4L,EAAAnK,QAAS+F,OAAOhB,GAAM,MAxCnC,IAAK4F,EAAWmG,yBAEZ,MADAvS,GAAS,GAAA4L,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK0C,2BAA4B,QAIpE,IAAIyI,UAASvK,QAqCb,OAnCAxH,GAAU+H,EAAAzE,QAAMrD,QACZiU,oBAAoB,EACpB3J,QAAS,IACT4J,WAAY,EACZoC,cAAc,GACfvW,GAEC+H,EAAAzE,QAAM1F,cAAcoC,EAAQwH,UAC5BA,EAASO,EAAAzE,QAAMrD,QACXqW,OAAQ,GACRF,WAAYnI,EAAW/I,WAAWC,QACnCnF,EAAQwH,SAwBR,GAAAqL,GAAAvP,QAAeuS,EAAmBhE,EAAiB7R,MN2kE1DiB,IAAK,UACL5F,MAAO,SMz+DI2E,EAAS6B,GACpBmP,GAAQ,EAAOhR,EAAS6B,MNkkExBZ,IAAK,iBACL5F,MAAO,SM5+DW2E,EAAS6B,GAC3BmP,GAAQ,EAAMhR,EAAS6B,MNq/DvBZ,IAAK,gBACL5F,MAAO,SM/+DU2E,EAAS6B,GAC1BoM,EAAWwD,eAAezR,EAAS6B,MNkiEnCZ,IAAK,cACL5F,MAAO,SMl/DQ2E,EAAS6B,GACxB,IAAKkG,EAAAzE,QAAM1F,cAAcoC,KACb+H,EAAAzE,QAAMlG,SAAS4C,EAAQsP,YACvBvH,EAAAzE,QAAMlG,SAAS4C,EAAQuP,WAC/B,KAAM,IAAA9B,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK4C,mBAGrCoE,IAEA,IAAI2E,GAAOtE,EAAWC,EAAEC,MACxBnO,GAAU+H,EAAAzE,QAAMrD,QACZgB,IAAKsR,EAAKnE,OAAOnN,KAAO,GACxBiS,SAAUX,EAAKW,UAAY,KAC3B1B,UAAWzJ,EAAAzE,QAAML,MAAK,GACtB6R,KAAK,GACN9U,EAEH,IAAIlB,GAAMiJ,EAAAzE,QAAMzE,YAAY6R,EAAApN,QAAMI,IAAIO,gBAAiBsO,EAAKxT,OACxDiW,GACIlW,IAAQA,EAAR,aAAwBkB,EAAQsP,SAAhC,IAA4CtP,EAAQuP,UAApD,cAA2EvP,EAAQwR,UAAnF,aAAyGxR,EAAQkT,SAAjH,QAAiIlT,EAAQiB,IAGjJwR,GAAAnP,QAAM8G,IAAI4K,EAAS,SAAC3M,EAAK+B,GACrB,GAAIzB,GAAW6E,EAAenF,EAAK+B,EACnC,IAAIqD,EAAAnK,QAAS8R,WAAWzM,GAAW,MAAO9G,GAAS8G,EAAU,KAE7DA,GAAW3I,EAAQ8U,IAAMnM,GACrB6N,GAAI7N,EAAS8N,WACblb,KAAMoN,EAAS+N,aACf3W,KAAMgI,EAAAzE,QAAMvD,KAAK4I,EAAS+N,cAAgBvW,MAAM,IAChDwW,UAAWhO,EAASgO,UACpBC,UAAWjO,EAASiO,UACpBpF,UAAWxR,EAAQwR,WAEvB3P,EAASwG,EAAKM,QN2kElB1H,IAAK,oBACL5F,MAAO,SMn/Dc2E,EAAS6B,GAC9B+L,GAEA,IAAI3M,GAAMgN,EAAWC,EAAEC,OAAOC,OAAOnN,GACrCgN,GAAW8F,mBAAmB9S,EAAK,SAAAoH,GAC/B,GAAIA,EACA,KAAM,IAAAoF,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK+C,kBAAmBnK,OAAO6I,EAAIH,SAAWG,GAG9E,IAAI5M,GAAIuE,EAAQ6W,SAAW7W,EAAQ8W,QAAU9W,EAAQiW,KACjD3a,EAAI0E,EAAQ+W,cAAgB/W,EAAQ8B,aAAe9B,EAAQkW,EAC/D,KAAKnO,EAAAzE,QAAM1F,cAAcoC,IAAYuN,EAAoB9R,IAAM8R,EAAoBjS,GAC/E,KAAM,IAAAmS,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAK4C,mBAErCxJ,GAAQ6W,QAAU3F,EAAA5N,QAAU0T,YAAYvb,GACxCuE,EAAQ+W,aAAe7F,EAAA5N,QAAU0T,YAAY1b,GAE7C0E,EAAU+H,EAAAzE,QAAMrD,QACZgX,WAAY7I,OAAOgB,KAAKvK,WAAWC,QACnCoS,aAAclY,OACdmY,cAAenY,OACfoY,WAAYpY,OACZoX,WAAYhI,OAAOgB,KAAKlK,WAAWC,QACpCnF,IAEW,GAAIoO,QAAOgB,KAAKiI,uBACtBC,kBAAkBtX,EAAS,SAAC2I,EAAUjC,GAC1C,GAAI2B,GAAM,IACN3B,KAAW0H,OAAOgB,KAAKmI,qBAAqBC,IAC5CnP,EAAMoF,EAAAnK,QAASqK,aAAajH,IACrB+G,EAAAnK,QAASqK,aAAahF,GAC7BA,EAAW,MAEXA,EAAW3I,EAAQ8U,IAAMnM,EAAWuI,EAAA5N,QAAUmU,sBAAsB9O,GAExE9G,EAASwG,EAAKM,UN4hEtB1H,IAAK,eACL5F,MAAO,SMr/DS2E,GAChBA,EAAU+H,EAAAzE,QAAMrD,QACZkW,QAASlI,EAAWvI,gBAAgBC,UACpCyQ,WAAYnI,EAAW/I,WAAWC,QACnCnF,EAEH,IAAIiW,GAAOjW,EAAQiW,KACfC,EAAKlW,EAAQkW,GACbI,EAAStW,EAAQoW,aAAenI,EAAW/I,WAAWC,OAChD4N,EAAkBC,CAE5B,IAAIhT,EAAQmW,UAAYlI,EAAWvI,gBAAgBC,UAAW,CAC1D,GAAI+R,GAAOzJ,EAAW0J,SAASzB,EAAG5G,SAAW2G,EAAK3G,UAC9CsI,EAAO3J,EAAW0J,SAASzB,EAAG3G,UAAY0G,EAAK1G,WAC/CsI,EAAIlY,KAAKmY,IAAIJ,EAAO,GAAK/X,KAAKmY,IAAIJ,EAAO,GACrC/X,KAAKoY,IAAI9J,EAAW0J,SAAS1B,EAAK3G,WAClC3P,KAAKoY,IAAI9J,EAAW0J,SAASzB,EAAG3G,YAChC5P,KAAKmY,IAAIF,EAAO,GAAKjY,KAAKmY,IAAIF,EAAO,EAE7C,OAAOtB,IADC,EAAI3W,KAAKqY,MAAMrY,KAAKsY,KAAKJ,GAAIlY,KAAKsY,KAAK,EAAIJ,KAIvD,GAAIK,GAAOjK,EAAW0J,SAAS1B,EAAK3G,UAChC6I,EAAOlK,EAAW0J,SAASzB,EAAG5G,UAC9B8I,EAAOnK,EAAW0J,SAAS1B,EAAK1G,WAChC8I,EAAOpK,EAAW0J,SAASzB,EAAG3G,WAC9B+I,GAAKD,EAAOD,GAAQzY,KAAKoY,KAAKG,EAAOC,GAAQ,GAC7CI,EAAKJ,EAAOD,CAChB,OAAOvY,MAAKsY,KAAKK,EAAIA,EAAIC,EAAIA,GAAKjC,KN2gElCrV,IAAK,QACL5F,MAAO,SMp/DEwG,GACT,GAAI0Q,GAAOtE,EAAWC,EAAEC,OAEpBqH,GACA1W,IAAKiJ,EAAAzE,QAAMzE,YAAY6R,EAAApN,QAAMI,IAAIC,GAAI4O,EAAKxT,OAC1CgM,OAAO,EACPN,OAAO,EACPlK,QACIiT,OAAQ,SAEZpI,cAAe,WACfC,SAAU,kBAEd,OAAOoH,GAAAnP,QAAMoS,MAAMF,EAAW,SAACnN,EAAKM,GAChC,MAAIN,GACOxG,EAAS4L,EAAAnK,QAAS+F,OAAOhB,GAAM,MAErCM,GAImB,YAApB,SAAOA,EAAP,YAAApM,EAAOoM,MAAuBA,EAAS6I,UAAYzJ,EAAAzE,QAAML,YAC7DpB,GAAS,KAAM8G,KAJXN,EAAM,GAAAoF,GAAAnK,QAAamK,EAAAnK,QAASsD,KAAKE,kBAC1BjF,EAASwG,EAAK,YN4hE7BpH,IAAK,qBACL5F,MAAO,SMv/De4F,EAAKY,GAC3B,GAAIT,SAMJ,IALI2G,EAAAzE,QAAM9F,WAAWyD,GACjBY,EAAWZ,EAEXG,EAAIH,GAEHgN,EAAW4F,iBAAkB,CAC9B,GAAI2B,IACA1W,IAAK4R,EAAApN,QAAMI,IAAIG,gBACfkH,OAAO,EACPK,cAAe,WACf7K,QACIU,IAAKG,GAAK,IAGdiK,SAAU,kBAEd,OAAOoH,GAAAnP,QAAMoS,MAAMF,EAAW3T,GAElCA,ONigEAZ,IAAK,iBACL5F,MAAO,WMz/DP,MAAQ,UAAY+C,SAAWgQ,OAAOgB,QNqgEtCnO,IAAK,kBACL5F,MAAO,SM7/DYqB,GACnB,MAAOqL,GAAAzE,QAAMhF,gBAAgB5B,MNwgE7BuE,IAAK,aACL5F,MAAO,SMhgEOqB,GACd,MAAO+Q,GAAAnK,QAAS8R,WAAW1Y,MN0gE3BuE,IAAK,yBACL5F,MAAO,WMlgEP,MAAOgZ,YAAc,eAAiBA,cN8gEtCpT,IAAK,SACL5F,MAAO,SMtgEGmd,GACV,MAAY,QAALA,KNihEPvX,IAAK,SACL5F,MAAO,SMzgEGod,GACV,MAAOA,GAAK,WNohEZxX,IAAK,WACL5F,MAAO,SM5gEKqd,GACZ,MAAOA,IAAW/Y,KAAKgZ,GAAK,QNuhE5B1X,IAAK,WACL5F,MAAO,SM/gEKud,GACZ,MAAOA,IAAW,IAAMjZ,KAAKgZ,ON8hE7B1X,IAAK,iBACL5F,MAAO,SMlhEWwd,GAAoB,GAAfC,GAAe9W,UAAA7E,OAAA,GAAA6B,SAAAgD,UAAA,IAAAA,UAAA,GAKlC+W,EAAOF,EAAM,GAAI,EAAK,EACtBG,EAAKH,EAAM,EAAI,IAAM,IACrBI,EAAKJ,EAAM,EAAI,IAAM,IACrBK,EAAQJ,EAAaG,EAALD,EAChBG,EAAWxZ,KAAKC,IAAID,KAAKyZ,MAAY,IAANP,GACnC,OAASlZ,MAAK0Z,MAAMF,EAAW,KAAWJ,EAAQ,KAAOpZ,KAAK0Z,MAAgE,IAAxDF,EAAW,IAAWxZ,KAAK0Z,MAAMF,EAAW,OAAkB,KACwC,GAAnKxZ,KAAK0Z,MAAoJ,KAAlF,IAAxDF,EAAW,IAAWxZ,KAAK0Z,MAAMF,EAAW,MAAkBxZ,KAAK0Z,MAAgE,IAAxDF,EAAW,IAAWxZ,KAAK0Z,MAAMF,EAAW,SAAkC,IAAU,KAAQD,KNshEnMjY,IAAK,QAqBLnF,IAAK,WM5wHL,MAAA2R,GAAAnK,WNsxHArC,IAAK,YACLnF,IAAK,WM/wHL,MAAO4U,GAAApN,QAAMa,aNyxHblD,IAAK,eACLnF,IAAK,WMlxHL,MAAO4U,GAAApN,QAAMkB,gBN4xHbvD,IAAK,aACLnF,IAAK,WMrxHL,MAAO4U,GAAApN,QAAMuB,cN+xHb5D,IAAK,aACLnF,IAAK,WMxxHL,MAAO4U,GAAApN,QAAM4B,cNkyHbjE,IAAK,YACLnF,IAAK,WM3xHL,MAAO4U,GAAApN,QAAM+B,aNqyHbpE,IAAK,kBACLnF,IAAK,WM9xHL,MAAO4U,GAAApN,QAAMoC,mBNwyHbzE,IAAK,cACLnF,IAAK,WMjyHL,MAAO4U,GAAApN,QAAMuC,gBNsyHVoI,IMpyDXA,GAAWC,GACPC,OAAQpG,EAAAzE,QAAMrD,UAAWgT,GAEzB5B,OAIJpD,EAAWqL,gBACP3D,SAAU,YACV7W,IAAK,6BACLsM,cAAe,WACfzI,QACI4W,GAAI,KACJ/K,QACIc,SAAU,WACVC,UAAW,aAEfc,SACImJ,KAAM,OACNC,MAAO,cACPC,UAAW,cACXC,WAAY,WACZpJ,YAAa,eACbC,QAAS,eACTiD,OAAQ,eAEZ3F,UACI0I,GAAI,gBNunEhBjc,EAAQ+I,QM9mEO2K,GN60ET,SAAUzT,EAAQD,EAASM,GAEjC,YAuBA,SAASuL,GAAuB1J,GAAO,MAAOA,IAAOA,EAAIV,WAAaU,GAAQ4G,QAAS5G,GApBvFhB,OAAOC,eAAepB,EAAS,cAC3Bc,OAAO,GOrgJX,IAAAyM,GAAAjN,EAAA,GP0gJIkN,EAAU3B,EAAuB0B,GOzgJrC0K,EAAA3X,EAAA,GP6gJI4X,EAAUrM,EAAuBoM,GO5gJrCM,EAAAjY,EAAA,GPghJI6V,EAAUtK,EAAuB0M,GO/gJrCJ,EAAA7X,EAAA,GPmhJIqW,EAAQ9K,EAAuBsM,GOzgJ7BkH,GAEFC,eAFc,SAECrL,GACX,OACI6G,IAAK7G,EAAO6G,KAAO7G,EAAOc,SAC1BgG,IAAK9G,EAAO8G,KAAO9G,EAAOe,YAIlCuK,iBATc,SASGtL,GACb,OACIc,SAAUd,EAAOc,UAAYd,EAAO6G,IACpC9F,UAAWf,EAAOe,WAAaf,EAAO8G,MAK9C0B,YAjBc,SAiBF+C,GAER,MADAA,GAAMhS,EAAAzE,QAAM7F,QAAQsc,GAAOA,GAAOA,GAC3BA,EAAIhM,IAAI,SAAAtS,GACX,MAAOsM,GAAAzE,QAAMtG,SAASvB,GAAKA,EAAIme,EAAUC,eAAepe,MAIhEue,gBAxBc,SAwBEC,GACZ,OACIC,MAAOD,EAAKC,MACZC,SAAUF,EAAKE,SACfC,oBAAqBH,EAAKI,mBAC1BC,YAAaL,EAAKN,WAClBnJ,QAASyJ,EAAKzJ,QACdiD,OAAQwG,EAAKxG,SAYrB8G,mBA3Cc,SA2CKva,EAASiR,GACxB,GAAI1Q,MACAyC,EAAI+E,EAAAzE,QAAMlE,SAEd,IAAI6R,EACIjR,EAAQwa,QACRja,EAAOc,KAAP,YAAwBrB,EAAQwa,SACzBxa,EAAQsP,UAAYtP,EAAQuP,WACnChP,EAAOc,KAAP,UAAsBrB,EAAQsP,SAA9B,IAA0CtP,EAAQuP,eAEnD,CACCvP,EAAQqQ,SACR9P,EAAOc,KAAP,WAAuB2B,EAAEhD,EAAQqQ,SAGrC,IAAIoK,GAAWb,EAAUI,gBAAgBha,EACzCya,GAAW1S,EAAAzE,QAAM/C,OAAOka,GAAY/Z,SAAU,IAAKC,UAAW,MAC9DJ,EAAOc,KAAP,cAA0BoZ,EAE1B,IAAIC,GAAI1a,EAAQ2a,MACZ5S,GAAAzE,QAAM7F,QAAQid,IAAmB,IAAbA,EAAEvd,OACtBoD,EAAOc,KAAP,UAAsBqZ,EAAE,GAAxB,IAA8BA,EAAE,GAAhC,IAAsCA,EAAE,GAAxC,IAA8CA,EAAE,IACzC3S,EAAAzE,QAAM1F,cAAc8c,IAAgC,IAA1Bhf,OAAO8E,KAAKka,GAAGvd,QAChDoD,EAAOc,KAAP,UAAsBqZ,EAAEE,aAAxB,IAAwCF,EAAEG,aAA1C,IAA0DH,EAAEI,aAA5D,IAA4EJ,EAAEK,cAMtF,MAFAxa,GAAOc,KAAP,YAAwBrB,EAAQkT,UAChC3S,EAAOc,KAAP,OAAmBrB,EAAQiB,KACpBV,EAAOF,KAAK,MAIvB2a,qBA5Ec,SA4EOC,GACjB,IAAKlT,EAAAzE,QAAM7F,QAAQwd,IAAYA,EAAQ9d,QAAU,EAC7C,OACI8B,SAAU,KACVoR,QAAS,KACT3B,iBAAkB,GAClBpR,KAAM,KACNkd,QAAS,GAIjB,IAAIxf,UAAGI,SACHK,KACA4Q,EAAO4O,EAAQ,GACfC,EAAQ7O,EAAK8O,kBAEjB,KAAKngB,EAAI,EAAGA,EAAIkgB,EAAM/d,OAAQnC,GAAK,EAC/BI,EAAI8f,EAAMlgB,GACNI,EAAEggB,OAAShgB,EAAEggB,MAAMje,OAAS,IAC5B1B,EAAEL,EAAEggB,MAAM,IAAMhgB,EAAEigB,UAClB5f,EAAEL,EAAEggB,MAAM,GAAK,MAAQhgB,EAAEkgB,WAIjC,IAAIC,GAAWlP,EAAKkP,QACpB,QACI/M,OAAQ+M,GAAYA,EAAStc,UACzBqQ,SAAUiM,EAAStc,SAASoW,IAC5B9F,UAAWgM,EAAStc,SAASqW,KAC7B,KACJjF,SACImL,WAAY/f,EAAEggB,mBACPhgB,EAAEigB,SACFjgB,EAAEkgB,YACFlgB,EAAEmgB,iBACF,GACPC,aAAcpgB,EAAEqgB,eAAiB,GACjCC,OAAQtgB,EAAEugB,6BACHvgB,EAAEwgB,6BACFxgB,EAAEye,OACF,GACPA,MAAOze,EAAEye,OAAS,GAClBgC,aAAczgB,EAAEygB,cACTzgB,EAAE0gB,6BACF1gB,EAAEugB,6BACF,GACPI,KAAM3gB,EAAE4gB,aAAe5gB,EAAE6gB,6BAA+B,GACxD9C,KAAM/d,EAAE0e,UAAY1e,EAAE8gB,6BAA+B,GACrD9I,OAAQhY,EAAE6gB,6BACH7gB,EAAE8gB,6BACF,GACP5C,WAAYle,EAAE6e,aAAe,GAC7Bb,MAAOhe,EAAE8gB,6BAA+B,GACxC7C,UAAWje,EAAE+gB,+BAAiC,GAC9ChM,QAAS/U,EAAE+U,SAAW,GACtBD,YAAa9U,EAAEghB,WAAa,IAEhC/N,iBAAkBrC,EAAKqQ,kBACvBpf,KAAMie,EAASoB,eAAiB,GAChCnC,QAASnO,EAAKuQ,SACdpL,UAAWzJ,EAAAzE,QAAML,SAIzB+N,QA5Ic,SA4INC,EAASsB,EAAMvS,EAAS6B,GAC5B,GAAI+O,KACJ,IAAI7I,EAAAzE,QAAMtG,SAASgD,GAAU,CACzB4Q,IAEAA,GADWK,EAAU,UAAY,WACpBjR,MACV,KAAI+H,EAAAzE,QAAM1F,cAAcoC,GAG3B,KAAM,IAAAkR,GAAA5N,QAAa4N,EAAA5N,QAASsD,KAAK4C,mBAFjCoH,GAAO5Q,EAKX,GAAIiR,EAAS,CACT,GAAI4L,GAAY9U,EAAAzE,QAAMlG,SAAS4C,EAAQsP,WAChCvH,EAAAzE,QAAMlG,SAAS4C,EAAQuP,UAC9B,KAAKxH,EAAAzE,QAAMtG,SAASgD,EAAQwa,WAAaqC,EACrC,KAAM,IAAA3L,GAAA5N,QAAa4N,EAAA5N,QAASsD,KAAK4C,oBAIzCoH,EAAO7I,EAAAzE,QAAMrD,QACTgB,IAAKsR,EAAKnE,OAAOnN,KAAO,GACxBiS,SAAUX,EAAKW,UAAY,KAC3B4B,KAAK,GACNlE,EAEH,IAAItF,GAAQsO,EAAUW,mBAAmB3J,EAAMK,GAC3CnS,EAAMiJ,EAAAzE,QAAMzE,YAAY6R,EAAApN,QAAMI,IAAIM,eAAgBuO,EAAKxT,OACvDiW,GACIlW,IAAQA,EAAR,IAAewM,EAGvBmH,GAAAnP,QAAM8G,IAAI4K,EAAS,SAAC3M,EAAK+B,GACrB,GAAI/B,EAAK,MAAOxG,GAASqP,EAAA5N,QAAS+F,OAAOhB,GAAM,KAE/C,IAAIM,GAAWZ,EAAAzE,QAAMT,cAAcuH,EAAIsD,cACnCoP,EAAO5L,EAAA5N,QAASqK,aAAahF,EAEjC,IAAImU,EAAM,MAAOjb,GAASib,EAAM,KAEhCnU,GAAW3I,EAAQ8U,IACbnM,EACAiR,EAAUoB,qBAAqBrS,EAASsS,SAC9CpZ,EAAS,KAAM8G,MA4CvB8O,sBAnOc,SAmOQwD,GAClB,IAAKlT,EAAAzE,QAAM1F,cAAcqd,GACrB,MAAO,KAGX,IAAIlB,MACAlD,EAAUoE,EAAQ8B,gBAClBC,EAAQ/B,EAAQgC,qBAChBC,EAAOjC,EAAQiC,KAafla,QAeJ,OAdA6T,GAAQlV,QAAQ,SAACmV,EAAQqG,GACrBH,EAAMrb,QAAQ,SAACyb,EAAMC,GACjBra,EAAIka,EAAKC,GAAQG,SAASD,GAC1BtD,EAAI1Y,MACA4U,KAAMa,EACNZ,GAAIkH,EACJrH,SAAU/S,EAAE+S,SACZwH,SAAUva,EAAEua,SACZC,KAAMxa,EAAEwa,KACRhM,UAAWzJ,EAAAzE,QAAML,aAKtB8W,GAKXpG,kBA5Qc,SA4QIlE,GACd,IAAKA,EAAQ,MAAO,EACf1H,GAAAzE,QAAM7F,QAAQgS,KAASA,GAAUA,GACtC,IAAIiC,KAgBJ,OAfAjC,GAAO9N,QAAQ,SAACR,EAAGnG,EAAG6c,GAClB,GAAI4F,GAAQ,EACRtc,GAAEuc,SACEvc,EAAEuc,QAAQvgB,OAAS,IACnBsgB,IAAUtc,EAAE/E,eAAe,eAAiB,WAAa+E,EAAEwc,YAAc,eAAiB,IAC1FF,IAAUtc,EAAE/E,eAAe,eAAiB,WAAa+E,EAAEyc,YAAc,eAAiB,IAC1Fzc,EAAEuc,QAAQ/b,QAAQ,SAACkc,EAAK7iB,EAAG6c,GACvB,GAAIiG,GAAWpiB,OAAO8E,KAAKqd,GAAK,EAEhCJ,IAASK,EAAW,IADND,EAAIC,GAAUjhB,WAAW8B,QAAQ,IAAK,MAChB,OAIhD+S,EAAOrQ,KAAK,SAAWhC,mBAAmBoe,MAEvC/L,EAAOrR,KAAK,MP8gJ3B9F,GAAQ+I,QOzgJOsW,GP6gJT,SAAUpf,EAAQD,EAASM,GAEjC,YAaA,SAASuL,GAAuB1J,GAAO,MAAOA,IAAOA,EAAIV,WAAaU,GAAQ4G,QAAS5G,GAEvF,QAAS2J,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAZhH9K,OAAOC,eAAepB,EAAS,cAC3Bc,OAAO,GAGX,IAAIiM,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIzM,GAAI,EAAGA,EAAIyM,EAAMtK,OAAQnC,IAAK,CAAE,GAAI0M,GAAaD,EAAMzM,EAAI0M,GAAW7L,WAAa6L,EAAW7L,aAAc,EAAO6L,EAAW9L,cAAe,EAAU,SAAW8L,KAAYA,EAAWC,UAAW,GAAMjM,OAAOC,eAAe6L,EAAQE,EAAWzG,IAAKyG,IAAiB,MAAO,UAAUnB,EAAaqB,EAAYC,GAAiJ,MAA9HD,IAAYL,EAAiBhB,EAAYpK,UAAWyL,GAAiBC,GAAaN,EAAiBhB,EAAasB,GAAqBtB,MQv0JhiBuB,EAAAjN,EAAA,GR20JIkN,EAAU3B,EAAuB0B,GQz0J/BiW,ER+0JW,WQ70Jb,QAAAA,GAAYC,EAAUC,GAAuB,GAAAC,GAAAvjB,KAAdqF,EAAcgC,UAAA7E,OAAA,GAAA6B,SAAAgD,UAAA,GAAAA,UAAA,KAAAqE,GAAA1L,KAAAojB,GACzCpjB,KAAKwjB,WAAY,EACjBxjB,KAAKwX,MAAQ,EACbxX,KAAKyjB,OAAS,KACdzjB,KAAK6b,GAAKnC,UAAUC,YAAY+J,cAC5B,SAAAvI,GACIoI,EAAK/L,QACDpK,EAAAzE,QAAM9F,WAAWwgB,IAAWA,EAASlI,IAE7C,SAAAzN,GACI6V,EAAK/L,QACDpK,EAAAzE,QAAM9F,WAAWygB,IAAUA,EAAQ5V,GACnCrI,EAAQuW,cACR2H,EAAKhM,SAGblS,GRs3JR,MAlCAsH,GAAayW,IACT9c,IAAK,SACL5F,MAAO,WQj1JPgZ,UAAUC,YAAYgK,WAAW3jB,KAAK6b,IACtC7b,KAAKwjB,WAAY,EACjBxjB,KAAKyjB,OAAS,QRq1Jdnd,IAAK,QACL5F,MAAO,SQn1JLkjB,EAAO1c,GAAU,GAAA2c,GAAA7jB,KACfW,EAAIyM,EAAAzE,QAAMlG,SAASmhB,GAASA,EAAQ,EACpClN,EAAKtJ,EAAAzE,QAAM9F,WAAWqE,GAAYA,EAC5BkG,EAAAzE,QAAM9F,WAAW+gB,GAASA,EAAQ,IAO5C,IALI5jB,KAAKyjB,SACL5T,aAAa7P,KAAKyjB,QAClBzjB,KAAKyjB,OAAS,OAGbzjB,KAAKwjB,UAAW,CACjB,GAAU,IAAN7iB,EAGA,MAFAX,MAAK8jB,cACDpN,GAAIA,IAGZ1W,MAAKyjB,OAASlS,WAAW,WACrBsS,EAAKC,SACDpN,GAAIA,KACT/V,QRy1JJyiB,IAOXxjB,GAAQ+I,QQt1JOya,GR01JT,SAAUvjB,EAAQD,EAASM,GAEjC,YAOA,SAASuL,GAAuB1J,GAAO,MAAOA,IAAOA,EAAIV,WAAaU,GAAQ4G,QAAS5G,GS95JvF,GAAAgiB,GAAA7jB,EAAA,GT45JI8jB,EAAevY,EAAuBsY,ESz5JpB,oBAAXtgB,SAC6B,SAAtBA,OAAO6P,aACrB7P,OAAO6P,WAAP0Q,EAAArb,SAKJ9I,EAAOD,QAAPokB,EAAArb","file":"geolocator.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"geolocator\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"geolocator\"] = factory();\n\telse\n\t\troot[\"geolocator\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"geolocator\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"geolocator\"] = factory();\n\telse\n\t\troot[\"geolocator\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Simple utility methods; internally used within Geolocator core;\n * made publically accessible.\n * @type {Object}\n * @readonly\n *\n * @license MIT\n * @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nvar utils = {\n    noop: function noop() {},\n\n\n    // ---------------------------\n    // Validation\n    // ---------------------------\n\n    /**\n     * Checks if the type of the given value is `String`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isString: function isString(value) {\n        return typeof value === 'string';\n    },\n    isStringSet: function isStringSet(value) {\n        return typeof value === 'string' && value.trim().length > 0;\n    },\n\n\n    /**\n     * Checks if the type of the given value is `Number`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isNumber: function isNumber(value) {\n        return typeof value === 'number';\n    },\n\n\n    /**\n     * Checks if the type of the given value is an `Object` or `Function`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isObject: function isObject(value) {\n        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n        return Boolean(value) && (type === 'object' || type === 'function');\n    },\n\n\n    /**\n     * Checks if the type of the given value is `Function`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isFunction: function isFunction(value) {\n        return typeof value === 'function';\n    },\n\n\n    /**\n     * Checks if the type of the given value is `Array`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isArray: function isArray(value) {\n        return Boolean(value) && _toString.call(value) === '[object Array]';\n    },\n\n\n    /**\n     * Checks if the given object is a non-empty `Array`.\n     * @memberof utils\n     *\n     * @param {*} array - Object to be checked.\n     * @returns {Boolean}\n     */\n    isFilledArray: function isFilledArray(array) {\n        return utils.isArray(array) && array.length > 0;\n    },\n\n\n    /**\n     * Checks if the given value is a plain `Object`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isPlainObject: function isPlainObject(value) {\n        return Boolean(value) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && _toString.call(value) === '[object Object]';\n    },\n\n\n    /**\n     * Checks if the given value is a `Date`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isDate: function isDate(value) {\n        return Boolean(value) && _toString.call(value) === '[object Date]';\n    },\n\n\n    /**\n     * Checks if the given object is a DOM element.\n     * @memberof utils\n     *\n     * @param {Object} object - Object to be checked.\n     * @returns {Boolean}\n     */\n    isElement: function isElement(object) {\n        if (!object) return false;\n        return object instanceof HTMLElement || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.nodeType === 1;\n    },\n\n\n    /**\n     * Checks if the given object is a DOM node.\n     * @memberof utils\n     *\n     * @param {Object} object - Object to be checked.\n     * @returns {Boolean}\n     */\n    isNode: function isNode(object) {\n        if (!object) return false;\n        return object instanceof Node || (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number';\n    },\n\n\n    /**\n     * Checks if the given object is a jQuery instance.\n     * This will still return `false` if the jQuery instance has no items.\n     * @memberof utils\n     *\n     * @param {Object} object - Object to be checked.\n     * @returns {Boolean}\n     */\n    isJQueryObject: function isJQueryObject(object) {\n        if (!object) return false;\n        return 'jQuery' in window && object instanceof window.jQuery && Boolean(object[0]);\n        // http://api.jquery.com/jquery-2/\n        // || (typeof object === 'object' && Boolean(object.jquery));\n    },\n\n\n    /**\n     * Checks if the type of the given value is an HTML5 `PositionError`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isPositionError: function isPositionError(value) {\n        return Boolean(value) && _toString.call(value) === '[object PositionError]';\n    },\n\n\n    /**\n     * Checks if the given value is an instance of `Error` or HTML5 `PositionError`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isError: function isError(value) {\n        return value instanceof Error || utils.isPositionError(value);\n    },\n\n\n    // ---------------------------\n    // String\n    // ---------------------------\n\n    /**\n     * Removes the query string portion from the given URL string.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the rest of the string.\n     */\n    removeQuery: function removeQuery(str) {\n        return str.replace(/\\?.*$/, '');\n    },\n\n\n    /**\n     * Removes the protocol portion from the given URL string.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the rest of the string.\n     */\n    removeProtocol: function removeProtocol(str) {\n        return str.replace(/^(.*:)?\\/\\//, '');\n    },\n\n\n    /**\n     * Sets the protocol of the given URL.\n     * @memberof utils\n     *\n     * @param {String} url\n     *        The URL to be modified.\n     * @param {Boolean} [https]\n     *        Specifies whether to set the protocol to HTTPS.\n     *        If omitted, current page protocol will be used.\n     *\n     * @returns {String} - The modified URL string.\n     */\n    setProtocol: function setProtocol(url, https) {\n        var p = void 0;\n        if (https === undefined || https === null) {\n            p = window.location.protocol;\n        } else {\n            p = https ? 'https:' : 'http:';\n        }\n        url = utils.removeProtocol(url);\n        return p + '//' + url;\n    },\n\n\n    /**\n     * Removes both the leading and trailing dots from the given string.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the rest of the string.\n     */\n    trimDots: function trimDots(str) {\n        return str.replace(/^\\.+?(.*?)\\.+?$/g, '$1');\n    },\n\n\n    /**\n     * URL-Encodes the given string. Note that the encoding is done Google's\n     * way; that is, spaces are replaced with `+` instead of `%20`.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the encoded string.\n     */\n    encodeURI: function encodeURI(str) {\n        return encodeURIComponent(str).replace(/%20/g, '+');\n    },\n\n\n    /**\n     * URL-Decodes the given string. This is the reverse of `utils.encodeURI()`;\n     * so pluses (`+`) are replaced with spaces.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the decoded string.\n     */\n    decodeURI: function decodeURI(str) {\n        return decodeURIComponent(str.replace(/\\+/g, '%20'));\n    },\n\n\n    /**\n     * Converts the given value to string.\n     * `null` and `undefined` converts to empty string.\n     * If value is a function, it's native `toString()` method is used.\n     * Otherwise, value is coerced.\n     * @memberof utils\n     *\n     * @param {*} value - String to be converted.\n     * @returns {String} - Returns the result string.\n     */\n    toString: function toString(value) {\n        if (value === null || value === undefined) return '';\n        if (value.toString && utils.isFunction(value.toString)) {\n            return value.toString();\n        }\n        return String(value);\n    },\n\n\n    /**\n     * Generates a random string with the number of characters.\n     * @memberof utils\n     *\n     * @param {Number} [len=1] - Length of the string.\n     * @returns {String} - Returns a random string.\n     */\n    randomString: function randomString(len) {\n        if (!len || !utils.isNumber(len)) len = 1;\n        len = -Math.abs(len);\n        return Math.random().toString(36).slice(len);\n    },\n\n\n    /**\n     * Gets the abbreviation of the given phrase.\n     * @memberof utils\n     *\n     * @param {String} str\n     *        String to abbreviate.\n     * @param {Object} [options]\n     *        Abbreviation options.\n     *     @param {Boolean} [options.upper=true]\n     *            Whether to convert to upper-case.\n     *     @param {Boolean} [options.dots=true]\n     *            Whether to add dots after each abbreviation.\n     *\n     * @returns {String} - Returns the abbreviation of the given phrase.\n     */\n    abbr: function abbr(str, options) {\n        options = utils.extend({\n            upper: true,\n            dots: true\n        }, options);\n        var d = options.dots ? '.' : '',\n            s = str.match(/(\\b\\w)/gi).join(d) + d;\n        return options.upper ? s.toUpperCase() : s;\n    },\n\n\n    /**\n     * Builds URI parameters from the given object.\n     * Note: This does not iterate deep objects.\n     * @memberof utils\n     *\n     * @param {Object} obj - Object to be processed.\n     * @param {Object} options - Parameterize options.\n     *     @param {Boolean} [options.encode=true]\n     *            Whether to encode URI components.\n     *     @param {String} [options.operator=\"=\"]\n     *     @param {String} [options.separator=\"&\"]\n     *     @param {Array} [options.include]\n     *            Keys to be included in the output params. If defined,\n     *            `options.exclude` is ignored.\n     *     @param {Array} [options.exclude]\n     *            Keys to be excluded from the output params.\n     *\n     * @returns {String} - URI parameters string.\n     */\n    params: function params(obj, options) {\n        if (!utils.isPlainObject(obj) || Object.keys(obj).length === 0) {\n            return '';\n        }\n\n        options = utils.extend({\n            encode: true,\n            operator: '=',\n            separator: '&',\n            include: undefined,\n            exclude: undefined\n        }, options);\n\n        var params = [],\n            inc = utils.isArray(options.include) ? options.include : null,\n            exc = !inc && utils.isArray(options.exclude) ? options.exclude : null;\n        utils.forIn(obj, function (value, key) {\n            if ((!inc || inc.indexOf(key) >= 0) && (!exc || exc.indexOf(key) < 0)) {\n                var v = utils.toString(value);\n                v = options.encode ? utils.encodeURI(v) : v;\n                var k = options.encode ? utils.encodeURI(key) : key;\n                params.push(k + options.operator + v);\n            }\n        });\n\n        return params.join(options.separator);\n    },\n\n\n    /**\n     * Gets the object from the given object notation string.\n     * @private\n     *\n     * @param {String} notation - Object notation.\n     * @returns {*} - Any existing object.\n     */\n    notateGlobalObj: function notateGlobalObj(notation) {\n        notation = utils.trimDots(notation);\n        var levels = notation.split('.'),\n            o = window;\n        if (levels[0] === 'window' || levels[0] === 'document') {\n            levels.shift();\n        }\n        levels.forEach(function (note) {\n            o = o[note];\n        });\n        return o;\n    },\n\n\n    // ---------------------------\n    // Object\n    // ---------------------------\n\n    /**\n     * Iterates over own properties of an object invoking a callback for each\n     * property.\n     * @memberof utils\n     *\n     * @param {Object} obj\n     *        Object to be processed.\n     * @param {Function} callback\n     *        Callback function with the following signature:\n     *        `function (value, key, object) { ... }`.\n     *        Explicitly returning `false` will exit the iteration early.\n     * @returns {void}\n     */\n    forIn: function forIn(obj, callback) {\n        var k = void 0;\n        for (k in obj) {\n            // if (obj.hasOwnProperty(k)) {} // Do this inside callback if needed.\n            if (callback(obj[k], k, obj) === false) break;\n        }\n    },\n\n\n    /**\n     * Extends the given object with the specified sources.\n     * Right most source overwrites the previous.\n     * NOTE: This is not a full implementation. Use with caution.\n     * @memberof utils\n     *\n     * @param {Object} destination\n     *        Destionation Object that will be extended and holds the default\n     *        values.\n     * @param {...Object} sources\n     *        Source objects to be merged.\n     *\n     * @returns {Object} - Returns the extended object.\n     */\n    extend: function extend(destination) {\n        if (!utils.isObject(destination)) return {};\n        var key = void 0,\n            value = void 0;\n\n        for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            sources[_key - 1] = arguments[_key];\n        }\n\n        sources.forEach(function (source) {\n            for (key in source) {\n                // eslint-disable-line\n                value = source[key];\n                if (utils.isArray(value)) {\n                    destination[key] = value.concat();\n                } else if (utils.isDate(value)) {\n                    destination[key] = new Date(value);\n                } else if (utils.isFunction(value)) {\n                    // should be before object\n                    destination[key] = value;\n                } else if (utils.isObject(value)) {\n                    destination[key] = utils.extend({}, value);\n                } else {\n                    destination[key] = value;\n                }\n            }\n        });\n        return destination;\n    },\n\n\n    /**\n     * Clones the given object.\n     * NOTE: This is not a full implementation. Use with caution.\n     * @memberof utils\n     *\n     * @param {Object} obj\n     *        Target Object to be cloned.\n     * @param {Object|Array} [options]\n     *        Clone options or array of keys to be cloned.\n     *     @param {Array} [options.keys]\n     *            Keys of the properties to be cloned.\n     *     @param {Boolean} [options.own=true]\n     *            Whether to clone own properties only. This is only effective\n     *            if `keys` is not defined.\n     *\n     * @returns {Object} - Returns the cloned object.\n     */\n    clone: function clone(obj, options) {\n        if (!obj) return {};\n\n        if (utils.isArray(options)) {\n            options = { keys: options };\n        }\n        options = utils.extend({\n            keys: null,\n            own: true\n        }, options);\n\n        var include = void 0,\n            cloned = {};\n\n        utils.forIn(obj, function (value, key) {\n            include = options.keys ? options.keys.indexOf(key) >= 0 : options.own && obj.hasOwnProperty(key) || !options.own;\n            if (include) {\n                if (utils.isObject(value)) {\n                    cloned[key] = utils.clone(value, options);\n                } else {\n                    cloned[key] = value;\n                }\n            }\n        });\n        return cloned;\n    },\n\n\n    /**\n     *  Maps the values of the given object to a schema to re-structure a new\n     *  object.\n     *  @memberof utils\n     *\n     *  @param {Object} obj\n     *         Original object to be mapped.\n     *  @param {Object} schema\n     *         Schema to be used to map the object.\n     *\n     *  @returns {Object} - Mapped object.\n     */\n    mapToSchema: function mapToSchema(obj, schema) {\n        var mapped = {};\n        utils.forIn(schema, function (value, key) {\n            if (utils.isPlainObject(value)) {\n                mapped[key] = utils.mapToSchema(obj, value);\n            } else {\n                mapped[key] = obj[value];\n            }\n        });\n        return mapped;\n    },\n\n\n    // ---------------------------\n    // Misc\n    // ---------------------------\n\n    /**\n     * Safely parses the given JSON `String` into an `Object`.\n     * The only difference from `JSON.parse()` is that this method does not\n     * throw for invalid input. Instead, returns `null`.\n     * @memberof utils\n     *\n     * @param {String} str - JSON string to be parsed\n     * @returns {Object|null} - Returns the parsed `Object` or `null` if the\n     * input is invalid.\n     */\n    safeJsonParse: function safeJsonParse(str) {\n        var o = null;\n        try {\n            o = JSON.parse(str);\n        } catch (e) {}\n        return o;\n    },\n\n\n    /**\n     * Gets a timestamp that is seconds or milliseconds since midnight,\n     * January 1, 1970 UTC.\n     * @memberof utils\n     *\n     * @param {Boolean} [seconds=false]\n     *        Specifies whether seconds should be returned instead of\n     *        milliseconds.\n     *\n     * @returns {Number} - Returns seconds or milliseconds since midnight,\n     * January 1, 1970 UTC.\n     */\n    time: function time(seconds) {\n        var ts = Date.now();\n        return seconds ? parseInt(ts / 1000, 10) : ts;\n    }\n};\n\nexports.default = utils;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar GOOGLE_MAPS_API_BASE = '//maps.googleapis.com/maps/api';\n\n/**\n * This file only includes partial documentation about `geolocator` enumerations.\n * Note that these enumerations are mostly an aggregation of\n * {@link https://developers.google.com/maps/documentation/javascript|Google Maps API} constants.\n *\n * @private\n * @readonly\n */\nvar enums = Object.freeze({\n  /**\n   * Enumerates API endpoints used within Geolocator core.\n   *\n   * @enum {String}\n   * @readonly\n   * @private\n   */\n  URL: {\n    /**\n     *  Public IP retrieval (free) service.\n     *  @type {String}\n     *  @private\n     */\n    IP: '//api.ipify.org',\n    /**\n     *  Country SVG flags.\n     *  e.g. <url>/tr.svg for Turkey flag.\n     *  @type {String}\n     *  @private\n     */\n    FLAG: '//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/',\n    /**\n     * Google Maps API bootstrap endpoint that loads all of the main\n     * Javascript objects and symbols for use in the Maps API.\n     * Some Maps API features are also available in self-contained\n     * libraries which are not loaded unless you specifically request them.\n     * See {@link https://developers.google.com/maps/documentation/javascript/libraries|details}.\n     * @type {String}\n     * @private\n     */\n    GOOGLE_MAPS_API: GOOGLE_MAPS_API_BASE + '/js',\n    /**\n     * Google Maps API Static Map endpoint.\n     * @type {String}\n     * @private\n     */\n    GOOGLE_SATATIC_MAP: GOOGLE_MAPS_API_BASE + '/staticmap',\n    /**\n     * Google Geolocation API endpoint.\n     * @type {String}\n     * @private\n     */\n    GOOGLE_GEOLOCATION: '//www.googleapis.com/geolocation/v1/geolocate',\n    /**\n     * Google Geocode API endpoint.\n     * @type {String}\n     * @private\n     */\n    GOOGLE_GEOCODE: '//maps.googleapis.com/maps/api/geocode/json',\n    /**\n     * Google TimeZone API endpoint.\n     * @type {String}\n     * @private\n     */\n    GOOGLE_TIMEZONE: '//maps.googleapis.com/maps/api/timezone/json',\n    /**\n     * Google Distance Matrix API endpoint.\n     * @type {String}\n     * @private\n     */\n    GOOGLE_DISTANCE_MATRIX: '//maps.googleapis.com/maps/api/distancematrix/json'\n  },\n  /**\n   * Enumerates Google map types.\n   * @memberof! geolocator\n   *\n   * @enum {String}\n   * @readonly\n   */\n  MapTypeId: {\n    /**\n     * Map type that displays a transparent layer of major streets on\n     * satellite images.\n     * @type {String}\n     */\n    HYBRID: 'hybrid',\n    /**\n     * Map type that displays a normal street map.\n     * @type {String}\n     */\n    ROADMAP: 'roadmap',\n    /**\n     * Map type that displays satellite images.\n     * @type {String}\n     */\n    SATELLITE: 'satellite',\n    /**\n     * Map type displays maps with physical features such as terrain and\n     * vegetation.\n     * @type {String}\n     */\n    TERRAIN: 'terrain'\n  },\n  /**\n   * Enumerates Google location types.\n   * @memberof! geolocator\n   *\n   * @enum {String}\n   * @readonly\n   */\n  LocationType: {\n    /**\n     * Indicates that the returned result is a precise geocode for which\n     * we have location information accurate down to street address\n     * precision.\n     * @type {String}\n     */\n    ROOFTOP: 'ROOFTOP',\n    /**\n     * Indicates that the returned result reflects an approximation\n     * (usually on a road) interpolated between two precise points (such as\n     * intersections). Interpolated results are generally returned when\n     * rooftop geocodes are unavailable for a street address.\n     * @type {String}\n     */\n    RANGE_INTERPOLATED: 'RANGE_INTERPOLATED',\n    /**\n     * Indicates that the returned result is the geometric center of a\n     * result such as a polyline (for example, a street) or polygon\n     * (region).\n     * @type {String}\n     */\n    GEOMETRIC_CENTER: 'GEOMETRIC_CENTER',\n    /**\n     * Indicates that the returned result is approximate.\n     * @type {String}\n     */\n    APPROXIMATE: 'APPROXIMATE'\n  },\n  /**\n   * Enumerates Google travel modes.\n   * @memberof! geolocator\n   *\n   * @enum {String}\n   * @readonly\n   */\n  TravelMode: {\n    /**\n     * Indicates distance calculation using the road network.\n     * @type {String}\n     */\n    DRIVING: 'DRIVING',\n    /**\n     * Requests distance calculation for walking via pedestrian paths &\n     * sidewalks (where available).\n     * @type {String}\n     */\n    WALKING: 'WALKING',\n    /**\n     * Requests distance calculation for bicycling via bicycle paths &\n     * preferred streets (where available).\n     * @type {String}\n     */\n    BICYCLING: 'BICYCLING',\n    /**\n     * Requests distance calculation via public transit routes (where\n     * available). This value may only be specified if the request includes\n     * an API key or a Google Maps APIs Premium Plan client ID. If you set\n     * the mode to transit you can optionally specify either a\n     * `departureTime` or an `arrivalTime`. If neither time is specified,\n     * the `departureTime` defaults to now (that is, the departure time defaults\n     * to the current time). You can also optionally include a `transitMode`\n     * and/or a `transitRoutingPreference`.\n     * @type {String}\n     */\n    TRANSIT: 'TRANSIT'\n  },\n  // /**\n  //  * Enumerates Google route restrictions.\n  //  * @memberof! geolocator\n  //  *\n  //  * @enum {String}\n  //  * @readonly\n  //  */\n  // RouteRestriction: {\n  //     TOLLS: 'tolls',\n  //     HIGHWAYS: 'highways',\n  //     FERRIES: 'ferries',\n  //     INDOOR: 'indoor'\n  // },\n  /**\n   * Enumerates Google unit systems.\n   * @memberof! geolocator\n   *\n   * @enum {Number}\n   * @readonly\n   */\n  UnitSystem: {\n    /**\n     * Distances in kilometers and meters.\n     * @type {Number}\n     */\n    METRIC: 0,\n    /**\n     * Distances defined in miles and feet.\n     * @type {Number}\n     */\n    IMPERIAL: 1\n  },\n  /**\n   * Enumerates mobile radio types.\n   * @memberof! geolocator\n   *\n   * @enum {String}\n   * @readonly\n   */\n  RadioType: {\n    /**\n     * LTE (Long-Term Evolution) mobile radio type.\n     * @type {String}\n     */\n    LTE: 'lte',\n    /**\n     * GSM (Global System for Mobile Communications) mobile radio type.\n     * @type {String}\n     */\n    GSM: 'gsm',\n    /**\n     * CDMA (Code division multiple access) mobile radio access technology.\n     * @type {String}\n     */\n    CDMA: 'cdma',\n    /**\n     * Wideband CDMA mobile radio access technology.\n     * @type {String}\n     */\n    WCDMA: 'wcdma'\n  },\n  /**\n   * Enumerates formulas/algorithms for calculating the distance between two\n   * lat/lng points.\n   * @memberof! geolocator\n   *\n   * @readonly\n   * @enum {String}\n   *\n   * @todo {@link https://en.wikipedia.org/wiki/Vincenty%27s_formulae|Vincenty's Formula}\n   */\n  DistanceFormula: {\n    /**\n     * Haversine formula for calculating the distance between two lat/lng points\n     * by relating the sides and angles of spherical triangles.\n     * @see {@link http://en.wikipedia.org/wiki/Haversine_formula|Haversine_formula}.\n     * @type {String}\n     */\n    HAVERSINE: 'haversine',\n    /**\n     * Formula based on the Pythagoras Theorem for calculating the\n     * distance between two lat/lng points on a Equirectangular projection\n     * to account for curvature of the longitude lines.\n     * @see {@link https://en.wikipedia.org/wiki/Pythagorean_theorem|Pythagorean_theorem}\n     * @type {String}\n     */\n    PYTHAGOREAN: 'pythagorean'\n  },\n  /**\n   *  Enumerates the image formats used for getting static Google Map images.\n   *  @memberof! geolocator\n   *\n   *  @readonly\n   *  @enum {String}\n   */\n  ImageFormat: {\n    /**\n     *  Specifies the PNG image format.\n     *  Same as `PNG_8`.\n     *  @type {String}\n     */\n    PNG: 'png',\n    /**\n     *  Specifies the 8-bit PNG image format.\n     *  Same as `PNG`.\n     *  @type {String}\n     */\n    PNG_8: 'png8',\n    /**\n     *  Specifies the 32-bit PNG image format.\n     *  @type {String}\n     */\n    PNG_32: 'png32',\n    /**\n     *  Specifies the GIF image format.\n     *  @type {String}\n     */\n    GIF: 'gif',\n    /**\n     *  Specifies the JPEG compressed image format.\n     *  @type {String}\n     */\n    JPG: 'jpg',\n    /**\n     *  Specifies a non-progressive JPEG compression image format.\n     *  @type {String}\n     */\n    JPG_BASELINE: 'jpg-baseline'\n  }\n});\n\nexports.default = enums;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Geolocator Error class that provides a common type of error object for the\n * various APIs implemented in Geolocator. All callbacks of Geolocator will\n * include an instance of this object as the first argument; if the\n * corresponding operation fails. Also all thrown errors will be an instance of\n * this object.\n *\n * This object can be publicly accessed via `geolocator.Error`.\n *\n * @extends Error\n */\nvar GeoError = function () {\n    // extends Error (doesn't work with transpilers)\n\n    /**\n     * Costructs a new instance of `GeoError`.\n     *\n     * @param {String} [code=\"UNKNOWN_ERROR\"]\n     *        Any valid Geolocator Error code.\n     *        See {@link #GeoError.Code|`GeoError.Code` enumeration} for\n     *        possible values.\n     * @param {String} [message]\n     *        Error message. If omitted, this will be set to `code`.\n     *\n     * @returns {GeoError}\n     *\n     * @example\n     * var GeoError = geolocator.Error,\n     *     error = new GeoError(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n     * console.log(error.code); // \"GEOLOCATION_NOT_SUPPORTED\"\n     * console.log(error instanceof GeoError); // true\n     */\n    function GeoError() {\n        var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : GeoError.Code.UNKNOWN_ERROR;\n        var message = arguments[1];\n\n        _classCallCheck(this, GeoError);\n\n        message = message || String(code);\n\n        /**\n         *  Gets the name of the Error object.\n         *  This always returns `\"GeoError\"`.\n         *  @name GeoError#name\n         *  @type {String}\n         */\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            writable: false,\n            value: 'GeoError' // this.constructor.name\n        });\n\n        /**\n         *  Gets the error code set for this instance.\n         *  This will return one of\n         *  {@link #GeoError.Code|`GeoError.Code` enumeration}.\n         *  @name GeoError#code\n         *  @type {String}\n         */\n        Object.defineProperty(this, 'code', {\n            enumerable: false,\n            writable: true,\n            value: code\n        });\n\n        /**\n         *  Gets the error message set for this instance.\n         *  If no message is set, this will return the error code value.\n         *  @name GeoError#message\n         *  @type {String}\n         */\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        if (Error.hasOwnProperty('captureStackTrace')) {\n            // V8\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            /**\n             *  Gets the error stack for this instance.\n             *  @name GeoError#stack\n             *  @type {String}\n             */\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: new Error(message).stack\n            });\n        }\n    }\n\n    /**\n     * Creates a new instance of `GeoError` from the given value.\n     *\n     * @param {*} [err]\n     *        Value to be transformed. This is used to determine the proper\n     *        error code for the created instance. If an `Error` or `Object` is\n     *        passed, its `message` property is checked if it matches any of the\n     *        valid error codes. If omitted or no match is found, error code\n     *        `GeoError.Code.UNKNOWN_ERROR` will be used as default.\n     *\n     * @returns {GeoError}\n     *\n     * @example\n     * var GeoError = geolocator.Error,\n     * \t   error = GeoError.create();\n     * console.log(error.code); // \"UNKNOWN_ERROR\"\n     * error = GeoError.create(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n     * console.log(error.code); // \"GEOLOCATION_NOT_SUPPORTED\"\n     */\n\n\n    _createClass(GeoError, null, [{\n        key: 'create',\n        value: function create(err) {\n            if (err instanceof GeoError) {\n                return err;\n            }\n\n            var code = void 0,\n                msg = void 0;\n\n            if (_utils2.default.isPositionError(err) && err.code) {\n                switch (err.code) {\n                    case 1:\n                        code = GeoError.Code.PERMISSION_DENIED;\n                        break;\n                    case 2:\n                        code = GeoError.Code.POSITION_UNAVAILABLE;\n                        break;\n                    case 3:\n                        code = GeoError.Code.TIMEOUT;\n                        break;\n                    default:\n                        code = GeoError.Code.UNKNOWN_ERROR;\n                        break;\n                }\n                return new GeoError(code, err.message || '');\n            }\n\n            if (typeof err === 'string') {\n                code = msg = err;\n            } else if ((typeof err === 'undefined' ? 'undefined' : _typeof(err)) === 'object') {\n                code = err.code || err.message;\n                msg = err.message || err.code;\n            }\n            if (code && GeoError.isValidErrorCode(code)) {\n                return new GeoError(code, msg);\n            }\n\n            return new GeoError(GeoError.Code.UNKNOWN_ERROR, msg);\n        }\n\n        /**\n         * Creates a new instance of `GeoError` from the given response object.\n         * Since Geolocator implements various Google APIs, we might receive\n         * responses if different structures. For example, some APIs return a\n         * response object with a `status:String` property (such as the TimeZone\n         * API) and some return responses with an `error:Object` property. This\n         * method will determine the correct reason or message and return a\n         * consistent error object.\n         *\n         * @param {Object|String} response\n         *        Response (Object) or status (String) to be transformed.\n         * @param {String} [message=null]\n         *        Error message.\n         *\n         * @returns {GeoError}\n         *          `GeoError` instance if response contains an error. Otherwise,\n         *          returns `null`.\n         *\n         * @example\n         * var error = geolocator.Error.fromResponse(googleResponse);\n         * console.log(error.code); // \"GOOGLE_KEY_INVALID\"\n         */\n\n    }, {\n        key: 'fromResponse',\n        value: function fromResponse(response) {\n            var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n            // example Google Geolocation API response:\n            // https://developers.google.com/maps/documentation/geolocation/intro#errors\n            // {\n            //      \"error\": {\n            //          \"errors\": [\n            //              {\n            //                  \"domain\": \"global\",\n            //                  \"reason\": \"parseError\",\n            //                  \"message\": \"Parse Error\",\n            //              }\n            //          ],\n            //      \"code\": 400,\n            //      \"message\": \"Parse Error\"\n            //      }\n            // }\n            // example Google TimeZone API response:\n            // {\n            //     \"status\": \"REQUEST_DENIED\"\n            // }\n\n            if (!response) return new GeoError(GeoError.Code.INVALID_RESPONSE);\n\n            var errCode = void 0;\n\n            if (_utils2.default.isString(response)) {\n                errCode = errorCodeFromStatus(response);\n                if (errCode) return new GeoError(errCode, message || response);\n            }\n\n            if (!_utils2.default.isObject(response)) return null;\n\n            var errMsg = response.error_message || response.errorMessage || response.error && response.error.message || '' || '';\n\n            if (response.status) {\n                errCode = errorCodeFromStatus(response.status);\n                if (errCode) return new GeoError(errCode, errMsg || message || response.status);\n            }\n\n            if (response.error) {\n                var reason = response.reason || response.error.reason;\n                if (!reason) {\n                    var errors = response.error.errors;\n                    if (_utils2.default.isArray(errors) && errors.length > 0) {\n                        reason = errors[0].reason; // get the first reason only\n                        errMsg = errMsg || errors[0].message; // update errMsg\n                    }\n                }\n                errCode = errorCodeFromReason(reason) || GeoError.Code.UNKNOWN_ERROR;\n                return new GeoError(errCode, errMsg || reason || message);\n            }\n\n            if (errMsg) {\n                errCode = errorCodeFromStatus(errMsg) || GeoError.Code.UNKNOWN_ERROR;\n                return new GeoError(errCode, errMsg || message);\n            }\n\n            return null;\n        }\n\n        /**\n         *  Checks whether the given value is an instance of `GeoError`.\n         *\n         *  @param {*} err - Object to be checked.\n         *\n         *  @returns {Boolean}\n         */\n\n    }, {\n        key: 'isGeoError',\n        value: function isGeoError(err) {\n            return err instanceof GeoError;\n        }\n\n        /**\n         *  Checks whether the given value is a valid Geolocator Error code.\n         *\n         *  @param {String} errorCode - Error code to be checked.\n         *\n         *  @returns {Boolean}\n         */\n\n    }, {\n        key: 'isValidErrorCode',\n        value: function isValidErrorCode(errorCode) {\n            var prop = void 0;\n            for (prop in GeoError.Code) {\n                if (GeoError.Code.hasOwnProperty(prop) && errorCode === GeoError.Code[prop]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }]);\n\n    return GeoError;\n}();\n\n/**\n *  Gets the string representation of the error instance.\n *\n *  @returns {String}\n */\n\n\nGeoError.prototype.toString = function () {\n    var msg = this.code !== this.message ? ' (' + this.message + ')' : '';\n    return this.name + ': ' + this.code + msg;\n};\n\n// `class x extends Error` doesn't work when using an ES6 transpiler, such as\n// Babel, since subclasses must extend a class. With Babel 6, we need\n// transform-builtin-extend plugin for this to work. So we're extending from\n// Error the old way. Now, `err instanceof Error` also returns `true`.\nif (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(GeoError.prototype, Error.prototype);\n} else {\n    GeoError.prototype = Object.create(Error.prototype);\n}\n\n// ---------------------------\n// ERROR CODES\n// ---------------------------\n\n/**\n *  Enumerates Geolocator error codes.\n *  This enumeration combines Google API status (error) codes, HTML5 Geolocation\n *  position error codes and other Geolocator-specific error codes.\n *  @enum {String}\n */\nGeoError.Code = {\n    /**\n     *  Indicates that HTML5 Geolocation API is not supported by the browser.\n     *  @type {String}\n     */\n    GEOLOCATION_NOT_SUPPORTED: 'GEOLOCATION_NOT_SUPPORTED',\n    /**\n     *  Indicates that Geolocation-IP source is not set or invalid.\n     *  @type {String}\n     */\n    INVALID_GEO_IP_SOURCE: 'INVALID_GEO_IP_SOURCE',\n    /**\n     *  The acquisition of the geolocation information failed because the\n     *  page didn't have the permission to do it.\n     *  @type {String}\n     */\n    PERMISSION_DENIED: 'PERMISSION_DENIED',\n    /**\n     *  The acquisition of the geolocation failed because at least one\n     *  internal source of position returned an internal error.\n     *  @type {String}\n     */\n    POSITION_UNAVAILABLE: 'POSITION_UNAVAILABLE',\n    /**\n     *  The time allowed to acquire the geolocation, defined by\n     *  PositionOptions.timeout information was reached before\n     *  the information was obtained.\n     *  @type {String}\n     */\n    TIMEOUT: 'TIMEOUT',\n    /**\n     * Indicates that the request had one or more invalid parameters.\n     * @type {String}\n     */\n    INVALID_PARAMETERS: 'INVALID_PARAMETERS',\n    /**\n     * Indicates that the service returned invalid response.\n     * @type {String}\n     */\n    INVALID_RESPONSE: 'INVALID_RESPONSE',\n    /**\n     * Generally indicates that the query (address, components or latlng)\n     * is missing.\n     * @type {String}\n     */\n    INVALID_REQUEST: 'INVALID_REQUEST',\n    /**\n     * Indicates that the request was denied by the service.\n     * This will generally occur because of a missing API key or because the request\n     * is sent over HTTP instead of HTTPS.\n     * @type {String}\n     */\n    REQUEST_DENIED: 'REQUEST_DENIED',\n    /**\n     * Indicates that the request has failed.\n     * This will generally occur because of an XHR error.\n     * @type {String}\n     */\n    REQUEST_FAILED: 'REQUEST_FAILED',\n    /**\n     * Indicates that Google API could not be loaded.\n     * @type {String}\n     */\n    GOOGLE_API_FAILED: 'GOOGLE_API_FAILED',\n    /**\n     * Indicates that you are over your Google API quota.\n     * @type {String}\n     */\n    OVER_QUERY_LIMIT: 'OVER_QUERY_LIMIT',\n    /**\n     * Indicates that you've exceeded the requests per second per user limit that\n     * you configured in the Google Developers Console. This limit should be\n     * configured to prevent a single or small group of users from exhausting your\n     * daily quota, while still allowing reasonable access to all users.\n     * @type {String}\n     */\n    USER_RATE_LIMIT_EXCEEDED: 'USER_RATE_LIMIT_EXCEEDED',\n    /**\n     * Indicates that you've exceeded your daily limit for Google API(s).\n     * @type {String}\n     */\n    DAILY_LIMIT_EXCEEDED: 'DAILY_LIMIT_EXCEEDED',\n    /**\n     * Indicates that your Google API key is not valid. Please ensure that you've\n     * included the entire key, and that you've either purchased the API or have\n     * enabled billing and activated the API to obtain the free quota.\n     * @type {String}\n     */\n    GOOGLE_KEY_INVALID: 'GOOGLE_KEY_INVALID',\n    /**\n     * Indicates that maximum number of elements limit is exceeded. For\n     * example, for the Distance Matrix API; occurs when the product of\n     * origins and destinations exceeds the per-query limit.\n     * @type {String}\n     */\n    MAX_ELEMENTS_EXCEEDED: 'MAX_ELEMENTS_EXCEEDED',\n    /**\n     * Indicates that the request contained more than 25 origins,\n     * or more than 25 destinations.\n     * @type {String}\n     */\n    MAX_DIMENSIONS_EXCEEDED: 'MAX_DIMENSIONS_EXCEEDED',\n    /**\n     * Indicates that the request contained more than allowed waypoints.\n     * @type {String}\n     */\n    MAX_WAYPOINTS_EXCEEDED: 'MAX_WAYPOINTS_EXCEEDED',\n    /**\n     * Indicates that the request body is not valid JSON.\n     * @type {String}\n     */\n    PARSE_ERROR: 'PARSE_ERROR',\n    /**\n     * Indicates that the requested resource could not be found.\n     * Note that this also covers `ZERO_RESULTS`.\n     * @type {String}\n     */\n    NOT_FOUND: 'NOT_FOUND',\n    /**\n     * Indicates that an internal error (such as XHR cross-domain, etc) has occured.\n     * @type {String}\n     */\n    INTERNAL_ERROR: 'INTERNAL_ERROR',\n    /**\n     * Indicates that an unknown error has occured.\n     * @type {String}\n     */\n    UNKNOWN_ERROR: 'UNKNOWN_ERROR'\n};\n\n// ---------------------------\n// HELPER METHODS\n// ---------------------------\n\n/**\n *  @private\n */\nfunction errorCodeFromStatus(status) {\n    if (!status) return GeoError.Code.INVALID_RESPONSE;\n    if (status === 'OK') return null;\n    if (status === 'ZERO_RESULTS') return GeoError.Code.NOT_FOUND;\n    if (GeoError.Code.hasOwnProperty(status)) return status;\n    return null;\n}\n\n/**\n *  Gets `GeoError.Code` from the given response error reason.\n *  @private\n *\n *  @param {String} reason\n *         Google response error reason.\n *\n *  @returns {String}\n */\nfunction errorCodeFromReason(reason) {\n    switch (reason) {\n        case 'invalid':\n            return GeoError.Code.INVALID_REQUEST;\n        case 'dailyLimitExceeded':\n            return GeoError.Code.DAILY_LIMIT_EXCEEDED;\n        case 'keyInvalid':\n            return GeoError.Code.GOOGLE_KEY_INVALID;\n        case 'userRateLimitExceeded':\n            return GeoError.Code.USER_RATE_LIMIT_EXCEEDED;\n        case 'notFound':\n            return GeoError.Code.NOT_FOUND;\n        case 'parseError':\n            return GeoError.Code.PARSE_ERROR;\n        default:\n            return null;\n    }\n}\n\n// ---------------------------\n// EXPORT\n// ---------------------------\n\nexports.default = GeoError;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Utility for making `XMLHttpRequest` and `JSONP` requests.\n *\n * @license MIT\n * @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nvar fetch = function () {\n    function fetch() {\n        _classCallCheck(this, fetch);\n    }\n\n    _createClass(fetch, null, [{\n        key: 'jsonp',\n\n\n        // https://html.spec.whatwg.org/multipage/scripting.html#script\n\n        /**\n         * Makes a JSONP (GET) request by injecting a script tag in the browser.\n         * Note that using JSONP has some security implications. As JSONP is really\n         * javascript, it can do everything else javascript can do, so you need to\n         * trust the provider of the JSONP data.\n         * @see https://en.wikipedia.org/wiki/JSONP\n         * @memberof fetch\n         *\n         * @param {Object|String} options - Required. Either the URL string which\n         *     will set other options to defaults or an options object with the\n         *     following properties.\n         *     @param {String} options.url\n         *            Source URL to be called.\n         *     @param {String} [options.type]\n         *            The MIME type that identifies the scripting language of the\n         *            code referenced within the script element.\n         *            e.g. `\"text/javascript\"`\n         *     @param {String} [options.charset]\n         *            Indicates the character encoding of the external resource.\n         *            e.g. `\"utf-8\"`.\n         *     @param {Boolean} [options.async=true]\n         *            Indicates whether or not to perform the operation\n         *            asynchronously. See {@link http://caniuse.com/#feat=script-async|browser support}.\n         *     @param {Boolean} [options.defer=false]\n         *            Indicates whether the script should be executed when the page\n         *            has finished parsing. See {@link http://caniuse.com/#feat=script-defer|browser support}.\n         *     @param {String} [options.crossorigin]\n         *            Indicates the CORS setting for the script element being\n         *            injected. Note that this attribute is not widely supported.\n         *            Valid values: `\"anonymous\"`, `\"use-credentials\"`.\n         *            See {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes|CORS settings}.\n         *     @param {Number} [options.timeout=0]\n         *            The number of milliseconds a request can take before\n         *            automatically being terminated. `0` disables timeout.\n         *     @param {Boolean} [options.clean=false]\n         *            Whether to remove the loaded script from DOM when the\n         *            operation ends. Note that the initial source might load\n         *            additional sources which are not deteceted or removed. Only\n         *            the initial source is removed.\n         *     @param {Object} [options.params]\n         *            Optional query parameters to be appended at the end of the URL.\n         *            e.g. `{ key: \"MY-KEY\" }`\n         *            You can also include the JSONP callback name parameter here\n         *            but if you want the object to be passed to the callback\n         *            argument of this method, use `options.callbackParam` to set\n         *            the callback parameter.\n         *     @param {String} [options.callbackParam]\n         *            If the endpoint supports JSONP callbacks, you can set the\n         *            callback parameter with this setting. This will enable a\n         *            second `obj` argument in the callback of this method which is\n         *            useful if the JSONP source invokes the callback with an\n         *            argument.\n         *     @param {String} [options.rootName]\n         *            The name (or notation) of the object that the generated JSONP\n         *            callback function should be assigned to. By default, this is\n         *            the `window` object but you can set this to a custom object\n         *            notation; for example, to prevent global namespace polution.\n         *            Note that this root object has to be globally accessible for\n         *            this to work. e.g. `\"window.myObject\"` (as string)\n         * @param {Function} [callback]\n         *        The callback function that will be executed when the script is\n         *        loaded. This callback has the following signature:\n         *        `function (err, obj) { ... }`. Note that the second argument\n         *        `obj` will always be `undefined` if the source endpoint does not\n         *        support JSONP callbacks or a callback param is not set explicitly\n         *        via `options.callbackParam` (or if the source does not invoke the\n         *        jsonp with an argument). However, the function will always execute\n         *        when the script loads or an error occurs.\n         *\n         * @returns {void}\n         *\n         * @example\n         * var opts1 = {\n         * \t   url: 'some/api',\n         * \t   callbackParam: 'jsonCallback',\n         * \t   params: { key: 'MY-KEY' }\n         * };\n         * // This will load the following source:\n         * // some/api?jsonCallback={auto-generated-fn-name}&key=MY-KEY\n         * fetch.jsonp(opts1, function (err, obj) {\n         * \t   console.log(obj); // some object\n         * });\n         *\n         * var opts2 = {\n         * \t   url: 'some/api',\n         * \t   params: {\n         * \t\t   key: 'MY-KEY',\n         * \t\t   jsonCallback: 'my-fn-name'\n         * \t   }\n         * };\n         * // This will load the following source:\n         * // some/api?jsonCallback=my-fn-name&key=MY-KEY\n         * fetch.jsonp(options, function (err, obj) {\n         * \t   console.log(obj); // undefined\n         * \t   // still executes, catch errors here\n         * });\n         * // JSON callback should be explicitly set.\n         * window['my-fn-name'] = function (obj) {\n         * \t   console.log(obj); // some object\n         * };\n         */\n        value: function jsonp(options, callback) {\n            var timeout = void 0;\n\n            callback = _utils2.default.isFunction(callback) ? callback : _utils2.default.noop;\n\n            if (_utils2.default.isString(options)) {\n                options = { url: options };\n            }\n\n            if (_utils2.default.isPlainObject(options)) {\n                options = _utils2.default.extend({\n                    // type: undefined,\n                    async: true,\n                    defer: false,\n                    // crossorigin: undefined,\n                    timeout: 0,\n                    params: {},\n                    // callbackParam: undefined,\n                    // rootName: undefined,\n                    clean: true\n                }, options);\n            } else {\n                return callback(new Error('No options or target URL is provided.'));\n            }\n\n            if (_utils2.default.isString(options.url) === false || options.url.trim() === '') {\n                return callback(new Error('No target URL is provided.'));\n            }\n\n            var script = document.createElement('script'),\n                cbParamSet = _utils2.default.isString(options.callbackParam) && options.callbackParam.trim() !== '',\n                cbFnName = void 0,\n                root = void 0,\n                rootNameSet = _utils2.default.isString(options.rootName) && options.rootName !== 'window' && options.rootName !== 'document' && options.rootName.trim() !== '';\n\n            if (cbParamSet) {\n                cbFnName = '_jsonp_' + _utils2.default.randomString(10);\n                options.params[options.callbackParam] = rootNameSet ? options.rootName + '.' + cbFnName : cbFnName;\n            }\n            var query = _utils2.default.params(options.params) || '',\n                qMark = options.url.indexOf('?') >= 0 ? '&' : '?',\n                url = query ? '' + options.url + qMark + query : options.url;\n            // console.log(url);\n\n            function execCb(err, timeUp, obj) {\n                if (timeout) {\n                    clearTimeout(timeout);\n                    timeout = null;\n                }\n                if ((timeUp || options.clean) && script.parentNode) {\n                    script.parentNode.removeChild(script);\n                }\n                // delete the jsonp callback function\n                if (rootNameSet) {\n                    delete root[cbFnName];\n                }\n                callback(err, obj);\n            }\n\n            if (cbFnName) {\n                var fn = function fn(obj) {\n                    execCb(null, false, obj);\n                };\n                root = rootNameSet\n                // ? window[options.rootName][cbFnName] = fn;\n                ? _utils2.default.notateGlobalObj(options.rootName) // if rootName is dot-notation.\n                : window;\n                root[cbFnName] = fn;\n            } else if (script.readyState) {\n                // IE < 11\n                script.onreadystatechange = function () {\n                    if (script.readyState === 'loaded' || script.readyState === 'complete') {\n                        script.onreadystatechange = null;\n                        execCb(null);\n                    }\n                };\n            } else {\n                // IE 11+\n                script.onload = function () {\n                    execCb(null);\n                };\n            }\n\n            script.onerror = function (error) {\n                var errMsg = 'Could not load source at ' + _utils2.default.removeQuery(options.url);\n                if (error) {\n                    errMsg += '\\n' + (error.message || error);\n                }\n                execCb(new Error(errMsg));\n            };\n\n            if (options.type) {\n                script.type = options.type;\n            }\n            if (options.charset) {\n                script.charset = options.charset;\n            }\n            if (options.async) {\n                script.async = true;\n            }\n            if (options.defer) {\n                script.defer = true;\n            }\n            if (options.crossorigin) {\n                script.crossorigin = options.crossorigin;\n            }\n\n            script.src = url;\n            document.getElementsByTagName('head')[0].appendChild(script);\n\n            // Timeout\n            if (_utils2.default.isNumber(options.timeout) && options.timeout > 0) {\n                timeout = setTimeout(function () {\n                    script.src = '';\n                    execCb(new Error('Operation timed out.'), true);\n                }, options.timeout);\n            }\n        }\n\n        /**\n         * Makes an XMLHttpRequest with the given parameters.\n         * Note that `\"Access-Control-Allow-Origin\"` header should be present on\n         * the requested resource. Otherwise, the request will not be allowed.\n         * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}.\n         * @memberof fetch\n         *\n         * @param {Object|String} options\n         *        Either the URL string which will set other options to defaults or\n         *        the full options object.\n         *     @param {String} options.url\n         *            Target URL to be called.\n         *     @param {String} [options.method=\"GET\"]\n         *            HTTP method.\n         *     @param {*} [options.data]\n         *            Data to be sent with the request.\n         *     @param {Number} [options.timeout]\n         *            The number of milliseconds a request can take before\n         *            automatically being terminated. `0` disables timeout.\n         *     @param {Boolean} [options.withCredentials=false]\n         *            Indicates whether or not cross-site Access-Control requests\n         *            should be made using credentials such as cookies or\n         *            authorization headers.\n         *     @param {Boolean} [options.async=true]\n         *            Indicating whether or not to perform the operation\n         *            asynchronously. If this value is false, the `send()` method\n         *            does not return until the response is received. If `true`,\n         *            notification of a completed transaction is provided using\n         *            event listeners. This must be `true` if the multipart\n         *            attribute is `true`, or an exception will be thrown.\n         *     @param {String} [options.mimeType]\n         *            If set, overrides the MIME type returned by the server. This\n         *            may be used, for example, to force a stream to be treated and\n         *            parsed as `text/xml`, even if the server does not report it as\n         *            such.\n         *     @param {Object} [options.headers]\n         *            Sets the HTTP request headers. Each key should be a header\n         *            name with a value. e.g. `{ 'Content-Length': 50 }`. For\n         *            security reasons, some headers cannot be set and can only be\n         *            controlled by the user agent.\n         *     @param {String} [options.username=\"\"]\n         *            User name to use for authentication purposes.\n         *     @param {String} [options.password=\"\"]\n         *            Password to use for authentication purposes.\n         * @param {Function} [callback]\n         *        The callback function in the following signature:\n         *        `function (err, xhr) { ... }`\n         *        Note that `xhr` object is always passed regardless of an error.\n         *\n         * @returns {void}\n         */\n\n    }, {\n        key: 'xhr',\n        value: function xhr(options, callback) {\n            var xhr = void 0,\n                err = void 0;\n\n            if ('XMLHttpRequest' in window) {\n                xhr = new XMLHttpRequest();\n            } else {\n                throw new Error('XMLHttpRequest is not supported!');\n            }\n\n            var hasCallback = _utils2.default.isFunction(callback);\n            callback = hasCallback ? callback : _utils2.default.noop;\n\n            if (_utils2.default.isString(options)) {\n                options = { url: options };\n            }\n\n            if (_utils2.default.isPlainObject(options)) {\n                options = _utils2.default.extend({\n                    method: 'GET',\n                    data: undefined,\n                    async: true,\n                    timeout: 0, // no timeout\n                    withCredentials: false,\n                    mimeType: undefined,\n                    username: '',\n                    password: ''\n                }, options);\n            } else {\n                callback(new Error('No options or target URL is provided.'));\n            }\n\n            if (_utils2.default.isString(options.url) === false) {\n                callback(new Error('No target URL is provided.'));\n            }\n\n            options.username = String(options.username);\n            options.password = String(options.password);\n            options.method = options.method.toUpperCase();\n            if (options.method !== 'POST' && options.method !== 'PUT') {\n                options.data = undefined;\n            }\n            // console.log(JSON.stringify(options));\n\n            if (hasCallback) {\n                xhr.onreadystatechange = function () {\n                    if (xhr.readyState === fetch.XHR_READY_STATE.DONE) {\n                        if (xhr.status === 200) {\n                            callback(null, xhr);\n                        } else {\n                            // let response = utils.safeJsonParse(xhr.responseText);\n                            // if (response && response.error)\n                            var crossDomain = xhr.status === 0 ? '. Make sure you have permission if this is a cross-domain request.' : '';\n                            err = new Error('The request returned status: ' + xhr.status + crossDomain);\n                            // console.log(xhr);\n                            callback(err, xhr);\n                        }\n                    }\n                };\n\n                if (_utils2.default.isNumber(options.timeout) && options.timeout > 0) {\n                    xhr.timeout = options.timeout;\n                    xhr.ontimeout = function () {\n                        // xhr.abort();\n                        err = new Error('The request had timed out.');\n                        callback(err, xhr);\n                    };\n                }\n            }\n            // console.log(options);\n            xhr.open(options.method, options.url, options.async, options.username, options.password);\n\n            // xhr.setRequestHeader() method should b called œafter open(), but\n            // before send().\n            if (_utils2.default.isPlainObject(options.headers)) {\n                Object.keys(options.headers).forEach(function (key) {\n                    var value = options.headers[key];\n                    xhr.setRequestHeader(key, value);\n                });\n            }\n\n            // xhr.overrideMimeType() method must be called before send().\n            if (options.mimeType) {\n                xhr.overrideMimeType(options.mimeType);\n            }\n\n            xhr.send(options.data);\n        }\n\n        /**\n         * Alias of `fetch.xhr()` with request method set to `\"GET\"` by default.\n         * @memberof fetch\n         *\n         * @param {Object} options\n         *        Either the URL string which will set other options to defaults or\n         *        the full options object. See `fetch.xhr()` method options for\n         *        details.\n         * @param {Function} [callback]\n         *        The callback function in the following signature:\n         *        `function (err, xhr) { ... }`\n         *        Note that `xhr` object is always passed regardless of an error.\n         * @returns {void}\n         */\n\n    }, {\n        key: 'get',\n        value: function get(options, callback) {\n            return fetch.xhr(options, callback);\n        }\n\n        /**\n         * Alias of `fetch.xhr()` with request method set to `\"POST\"` by default.\n         * @memberof fetch\n         *\n         * @param {Object} options\n         *        Either the URL string which will set other options to defaults or\n         *        the full options object. See `fetch.xhr()` method options for\n         *        details.\n         * @param {Function} [callback]\n         *        The callback function in the following signature:\n         *        `function (err, xhr) { ... }`\n         *        Note that `xhr` object is always passed regardless of an error.\n         * @returns {void}\n         */\n\n    }, {\n        key: 'post',\n        value: function post(options, callback) {\n            return _xhr('POST', options, callback);\n        }\n\n        /**\n         * Alias of `fetch.xhr()` with request method set to `\"PUT\"` by default.\n         * @memberof fetch\n         *\n         * @param {Object} options\n         *        Either the URL string which will set other options to defaults or\n         *        the full options object. See `fetch.xhr()` method options for\n         *        details.\n         * @param {Function} [callback]\n         *        The callback function in the following signature:\n         *        `function (err, xhr) { ... }`\n         *        Note that `xhr` object is always passed regardless of an error.\n         * @returns {void}\n         */\n\n    }, {\n        key: 'put',\n        value: function put(options, callback) {\n            return _xhr('PUT', options, callback);\n        }\n\n        /**\n         * Alias of `fetch.xhr()` with request method set to `\"DELETE\"` by default.\n         * @memberof fetch\n         *\n         * @param {Object} options\n         *        Either the URL string which will set other options to defaults or\n         *        the full options object. See `fetch.xhr()` method options for\n         *        details.\n         * @param {Function} [callback]\n         *        The callback function in the following signature:\n         *        `function (err, xhr) { ... }`\n         *        Note that `xhr` object is always passed regardless of an error.\n         * @returns {void}\n         */\n\n    }, {\n        key: 'delete',\n        value: function _delete(options, callback) {\n            return _xhr('DELETE', options, callback);\n        }\n    }]);\n\n    return fetch;\n}();\n\n/**\n *  @private\n */\n\n\nfunction _xhr(method, options, callback) {\n    options = _utils2.default.isString(options) ? { url: options } : options || {};\n    options.method = method;\n    return fetch.xhr(options, callback);\n}\n\n/**\n * Enumerates `XMLHttpRequest` ready states.\n * Not to be confused with `script.readyState`.\n * @memberof fetch\n *\n * @enum {Number}\n */\nfetch.XHR_READY_STATE = {\n    /**\n     * `xhr.open()` has not been called yet.\n     * @type {Number}\n     */\n    UNSENT: 0,\n    /**\n     * `xhr.send()` has been called.\n     * @type {Number}\n     */\n    OPENED: 1,\n    /**\n     * `xhr.send()` has been called, and headers and status are available.\n     * @type {Number}\n     */\n    HEADERS_RECEIVED: 2,\n    /**\n     * Downloading; responseText holds partial data.\n     * @type {Number}\n     */\n    LOADING: 3,\n    /**\n     * The operation is complete.\n     * @type {Number}\n     */\n    DONE: 4\n};\n\nexports.default = fetch;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _fetch = __webpack_require__(3);\n\nvar _fetch2 = _interopRequireDefault(_fetch);\n\nvar _geo = __webpack_require__(5);\n\nvar _geo2 = _interopRequireDefault(_geo);\n\nvar _geo3 = __webpack_require__(2);\n\nvar _geo4 = _interopRequireDefault(_geo3);\n\nvar _geo5 = __webpack_require__(6);\n\nvar _geo6 = _interopRequireDefault(_geo5);\n\nvar _enums = __webpack_require__(1);\n\nvar _enums2 = _interopRequireDefault(_enums);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *  Radius of earth in kilometers.\n *  @private\n *  @type {Number}\n */\nvar EARTH_RADIUS_KM = 6371;\n\n/**\n *  Radius of earth in miles.\n *  @private\n *  @type {Number}\n */\nvar EARTH_RADIUS_MI = 3959;\n\n/**\n *  Storage for Geolocator default configuration.\n *\n *  @readonly\n *  @private\n */\nvar defaultConfig = {\n    language: 'en',\n    https: true,\n    google: {\n        version: '3', // latest 3.x\n        key: '',\n        styles: null\n    }\n};\n\n/**\n *  Geolocator library that provides methods for getting geo-location information,\n *  geocoding, address look-ups, distance & durations, timezone information and more...\n *  This library makes use of HTML5 position feautures, implements Google APIs\n *  and other services.\n *\n *  <b>Important Notes:</b>\n *\n *  Although some calls might work without a key, it is generally required by\n *  most {@link https://developers.google.com/maps/faq#using-google-maps-apis|Goolge APIs}\n *  (such as Time Zone API). To get a free (or premium) key,\n *  {@link https://developers.google.com/maps/documentation/javascript/|click here}.\n *  After getting a key, you can enable multiple APIs for it. Make sure you\n *  {@link https://console.developers.google.com|enable}\n *  all the APIs supported by Geolocator.\n *\n *  Note that browser API keys cannot have referer restrictions when used\n *  with some Google APIs.\n *\n *  Make sure your doctype is HTML5 and you're calling Geolocation APIs from an\n *  HTTPS page. Geolocation API is removed from unsecured origins in Chrome 50.\n *  Other browsers are expected to follow.\n *\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\n\nvar geolocator = function () {\n    function geolocator() {\n        _classCallCheck(this, geolocator);\n    }\n\n    _createClass(geolocator, null, [{\n        key: 'config',\n\n\n        // ---------------------------\n        // STATIC METHODS\n        // ---------------------------\n\n        /**\n         *  Sets or gets the geolocator configuration object.\n         *  Make sure you configure Geolocator before calling other methods that\n         *  require a Google API key.\n         *\n         *  @param {Object} [options]\n         *         Configuration object. If omitted, this method returns the current\n         *         configuration.\n         *      @param {String} [options.language=\"en\"]\n         *             Language to be used for API requests that supports language\n         *             configurations. This is generally used for Google APIs.\n         *             See {@link https://developers.google.com/maps/faq#languagesupport|supported languages}.\n         *      @param {Boolean} [options.https=true]\n         *             As Google recommends; using HTTPS encryption makes your site\n         *             more secure, and more resistant to snooping or tampering.\n         *             If set to `true`, the API calls are made over HTTPS, at all\n         *             times. Setting to `false` will switch to HTTP (even if the\n         *             page is on HTTPS). And if set to `null`, current protocol will\n         *             be used. Note that some APIs might not work with HTTP such as\n         *             Google Maps TimeZone API.\n         *      @param {Object} [options.google]\n         *             Google specific options.\n         *          @param {String} [options.google.version=\"3\"]\n         *                 Google Maps API version to be used (with\n         *                 `geolocator.createMap()`) method. The default version\n         *                 value is tested and works with Geolocator. You can set a\n         *                 greater value or the latest version number and it should\n         *                 work; but it's not guaranteed. Find out the\n         *                 {@link https://developers.google.com/maps/documentation/javascript/versions|latest version here}.\n         *          @param {String} [options.google.key=\"\"]\n         *                 API key to be used with Google API calls. Although some\n         *                 calls might work without a key, it is generally required\n         *                 by most Goolge APIs. To get a free (or premium) key,\n         *                 {@link https://developers.google.com/maps/documentation/javascript/|click here}.\n         *          @param {Array} [options.google.styles]\n         *                 An array of objects to customize the presentation of the\n         *                 Google base maps, changing the visual display of such\n         *                 elements as roads, parks, and built-up areas.\n         *                 See {@link https://developers.google.com/maps/documentation/javascript/styling|Styling Maps}.\n         *\n         *  @returns {Object} - Returns the current or updated configuration object.\n         *\n         *  @example\n         *  geolocator.config({\n         *      language: \"en\",\n         *      google: {\n         *          version: \"3\",\n         *          key: \"YOUR-GOOGLE-API-KEY\"\n         *      }\n         *  });\n         */\n        value: function config(options) {\n            if (options) {\n                geolocator._.config = _utils2.default.extend(defaultConfig, options);\n            }\n            return geolocator._.config;\n        }\n\n        /**\n         *  Gets a static map image URL which can be embeded via an `<img />` tag\n         *  on the page.\n         *\n         *  Note that, if `options.center` is set to an address (instead of\n         *  coordinates) and `options.marker` is also set; we will need to geocode\n         *  that address to get center coordinates for the marker.\n         *  In this case, you must use the `callback` parameter to get the async\n         *  result. Otherwise, this method will directly return a `String`.\n         *\n         *  Make sure you have enabled Static Maps API (and Geocoding API if\n         *  `marker` is enabled) in your Google Developers console.\n         *\n         *  For interactive map, see {@link #geolocator.createMap|`geolocator.createMap()` method}.\n         *\n         *  @see {@link https://developers.google.com/maps/documentation/static-maps/intro|Static Maps}\n         *  @see {@link https://developers.google.com/maps/documentation/static-maps/usage-limits|Usage Limits}\n         *\n         *  @param {Object} options\n         *         Static map options.\n         *         @param {String|Object} options.center\n         *                Defines the center of the map and the location.\n         *                Either an address `String` or an coordinates `Object` with\n         *                `latitude:Number` and `longitude:Number` properties.\n         *         @param {String} [options.mapTypeId=\"roadmap\"]\n         *                Type of the map to be created.\n         *                See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n         *                for possible values.\n         *         @param {String|Object} [options.size=\"600x300\"]\n         *                Defines the size (in pixels) of the returned image.\n         *                Either a string in `widthxheight` format or an Object\n         *                with `width:Number` and `height:Number` properties.\n         *         @param {Number} [options.scale=1]\n         *                Affects the number of pixels that are returned. scale=2\n         *                returns twice as many pixels as scale=1 while retaining\n         *                the same coverage area and level of detail (i.e. the\n         *                contents of the map don't change). Accepted values are 1,\n         *                2 and 4 (4 is only available to Google Maps APIs Premium\n         *                Plan customers.)\n         *         @param {Number} [options.zoom=9]\n         *                Zoom level to be set for the map.\n         *         @param {String} [options.format=png]\n         *                Defines the format of the resulting image.\n         *                See {@link #geolocator.ImageFormat|`geolocator.ImageFormat` enumeration}\n         *                for possible values.\n         *         @param {Boolean|String} [options.marker=true]\n         *                Specifies whether to add a marker to the center of the map.\n         *                You can define the color of the marker by passing a color\n         *                `String` instead of a `Boolean`. Color can be a predefined\n         *                color from the set `red` (default), `black`, `brown`,\n         *                `green`, `purple`, `yellow`, `blue`, `gray`, `orange` and\n         *                `white`; or a HEX 24-bit color (e.g. `\"0xFF0000\"`).\n         *                Note that marker will not be visible if `center` is set to\n         *                a `String` address and you don't use the callback.\n         *         @param {String} [options.region]\n         *                Defines the appropriate borders to display, based on\n         *                geo-political sensitivities. Accepts a region code\n         *                specified as a two-character ccTLD (top-level domain)\n         *                value. e.g. `\"us\"`.\n         *         @param {Array} [options.styles]\n         *                An array of objects to customize the presentation of the\n         *                Google base maps, changing the visual display of such\n         *                elements as roads, parks, and built-up areas.\n         *                This will default to the global styles set via\n         *                {@link #geolocator.config|`geolocator.config()` method}, if any.\n         *                See {@link https://developers.google.com/maps/documentation/javascript/styling|Styling Maps}.\n         *\n         *  @param {Function} [callback]\n         *         Callback function to be executed when the static map URL is built.\n         *         This takes 2 arguments: `function (err, url) { ... }`.\n         *         If omitted, this method will directly return the static map\n         *         image URL; but (if enabled) the marker will not be visible if\n         *         `options.center` is set to an address `String` instead of a\n         *         coordinates `Object`.\n         *\n         *  @returns {String|void}\n         *           If a callback is passed, this will return `void`.\n         *           Otherwise, a `String` that represents the URL of the static map.\n         *\n         *  @example\n         *  // Async example (with address and marker)\n         *  var options = {\n         *      center: \"Los Angles, CA, US\",\n         *      mapTypeId: geolocator.MapTypeId.ROADMAP,\n         *      size: \"600x300\",\n         *      scale: 1,\n         *      zoom: 5,\n         *      marker: \"0xFFCC00\",\n         *      format: geolocator.ImageFormat.PNG\n         *  };\n         *  geolocator.getStaticMap(options, function (err, url) {\n         *      if (!err) {\n         *          document.getElementById('my-img').src = url;\n         *      }\n         *  });\n         *\n         *  @example\n         *  // Sync example (with coordinates)\n         *  var options = {\n         *      center: {\n         *          longitude: 34.0522342,\n         *          latitude: -118.2436849\n         *      },\n         *      mapTypeId: geolocator.MapTypeId.ROADMAP,\n         *      size: \"600x300\",\n         *      scale: 1,\n         *      zoom: 5,\n         *      marker: \"0xFFCC00\",\n         *      format: geolocator.ImageFormat.PNG\n         *  };\n         *  document.getElementById('my-img').src = geolocator.getStaticMap(options);\n         */\n\n    }, {\n        key: 'getStaticMap',\n        value: function getStaticMap(options, callback) {\n            if (!_utils2.default.isPlainObject(options) || !options.center) {\n                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS, 'A center address or coordinates are required.');\n            }\n\n            if (_utils2.default.isString(options.center)) {\n                return geolocator.geocode(options.center, function (err, location) {\n                    if (err) callback(err);\n                    options.center = location.coords;\n                    callback(null, geolocator.getStaticMap(options));\n                });\n            }\n\n            var conf = geolocator._.config;\n            var opts = _utils2.default.extend({\n                mapTypeId: _enums2.default.MapTypeId.ROADMAP,\n                size: {\n                    width: 600,\n                    height: 300\n                },\n                scale: 1, // 1 | 2 | (4 for business customers of google maps)\n                zoom: 9,\n                marker: 'red',\n                format: _enums2.default.ImageFormat.PNG,\n                language: conf.language || 'en',\n                region: null\n            }, options);\n\n            var center = _utils2.default.isPlainObject(opts.center) ? opts.center.latitude + ',' + opts.center.longitude : String(opts.center);\n\n            var size = _utils2.default.isPlainObject(opts.size) ? opts.size.width + 'x' + opts.size.height : String(opts.size);\n\n            var url = _enums2.default.URL.GOOGLE_SATATIC_MAP // not using utils.setProtocol() here\n            + ('?center=' + center + '&maptype=' + opts.mapTypeId) + ('&size=' + size + '&scale=' + opts.scale + '&zoom=' + opts.zoom) + ('&format=' + opts.format + '&language=' + opts.language);\n\n            if (opts.marker) {\n                var color = _utils2.default.isString(opts.marker) ? opts.marker : 'red';\n                url += '&markers=' + encodeURIComponent('color:' + color + '|' + center);\n            }\n            if (opts.region) url += '&region=' + opts.region;\n            if (conf.google.key) url += '&key=' + conf.google.key;\n\n            var styles = getStyles(opts);\n            if (styles) url += '&' + _geo2.default.mapStylesToParams(styles);\n\n            if (_utils2.default.isFunction(callback)) return callback(null, url);\n            return url;\n        }\n\n        /**\n         *  Creates an interactive Google Map within the given element.\n         *  Make sure you have enabled Google Static Maps API in your Google Developers console.\n         *  For static map, see {@link #geolocator.getStaticMap|`geolocator.getStaticMap()` method}.\n         *  @see {@link https://developers.google.com/maps/documentation/javascript/reference|Google Maps JavaScript API}\n         *  @see {@link https://developers.google.com/maps/documentation/javascript/usage|Usage Limits}\n         *\n         *  @param {Object|String|HTMLElement|Map} options\n         *         Either map options object with the following properties or; the ID\n         *         of a DOM element, or element itself which the map will be\n         *         created within; or a previously created `google.maps.Map` instance.\n         *         If a map instance is set, this only will apply the options without\n         *         re-creating it.\n         *      @param {String|HTMLElement|Map} options.element\n         *             Either the ID of a DOM element or the element itself;\n         *             which the map will be created within; or a previously created\n         *             `google.maps.Map` instance. If a map instance is set, this\n         *             only will apply the options without re-creating it.\n         *      @param {Object} options.center\n         *             Center coordinates for the map to be created.\n         *          @param {Number} options.center.latitude\n         *                 Latitude of the center point coordinates.\n         *          @param {Number} options.center.longitude\n         *                 Longitude of the center point coordinates.\n         *      @param {String} [options.mapTypeId=\"roadmap\"]\n         *             Type of the map to be created.\n         *             See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n         *             for possible values.\n         *      @param {String} [options.title]\n         *             Title text to be displayed within an `InfoWindow`, when the\n         *             marker is clicked. This only take effect if `marker` is\n         *             enabled.\n         *      @param {Boolean} [options.marker=true]\n         *             Whether to place a marker at the given coordinates.\n         *             If `title` is set, an `InfoWindow` will be opened when the\n         *             marker is clicked.\n         *      @param {Number} [options.zoom=9]\n         *             Zoom level to be set for the map.\n         *      @param {Array} [options.styles]\n         *             An array of objects to customize the presentation of the\n         *             Google base maps, changing the visual display of such\n         *             elements as roads, parks, and built-up areas.\n         *             This will default to the global styles set via\n         *             {@link #geolocator.config|`geolocator.config` method}`, if any.\n         *             See {@link https://developers.google.com/maps/documentation/javascript/styling|Styling Maps}.\n         *\n         *  @param {Function} callback\n         *         Callback function to be executed when the map is created.\n         *         This takes 2 arguments: `function (err, map) { ... }`.\n         *         See {@link #geolocator~MapData|`geolocator~MapData` type} for details.\n         *\n         *  @returns {void}\n         *\n         *  @example\n         *  var options = {\n         *      element: \"my-map\",\n         *      center: {\n         *          latitude: 48.8534100,\n         *          longitude: 2.3488000\n         *  \t},\n         *  \tmarker: true,\n         *  \ttitle: \"Paris, France\",\n         *  \tzoom: 12\n         *  };\n         *  geolocator.createMap(options, function (err, map) {\n         *      if (map && map.infoWindow) {\n         *          map.infoWindow.open(map.instance, map.marker);\n         *      }\n         *  });\n         */\n\n    }, {\n        key: 'createMap',\n        value: function createMap(options, callback) {\n            // if options is not a plain object, consider element ID, `HTMLElement`,\n            // `jQuery` instance or `google.maps.Map` instance.\n            if (!_utils2.default.isPlainObject(options)) {\n                options = { element: options };\n            }\n\n            options = _utils2.default.extend({\n                element: null,\n                mapTypeId: _enums2.default.MapTypeId.ROADMAP,\n                title: undefined,\n                marker: true,\n                zoom: 9\n            }, options);\n\n            var e = options.element,\n                elem = void 0;\n            if (_utils2.default.isString(e)) {\n                elem = document.getElementById(e);\n            } else if (_utils2.default.isJQueryObject(e)) {\n                elem = e[0];\n            } else if (geolocator.isGoogleLoaded() && e instanceof google.maps.Map) {\n                elem = e.getDiv();\n            }\n\n            if (!_utils2.default.isElement(elem) && !_utils2.default.isNode(elem)) {\n                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS, 'A valid DOM element or element ID is required to create a map.');\n            }\n\n            if (!_utils2.default.isPlainObject(options.center) || !_utils2.default.isNumber(options.center.latitude) || !_utils2.default.isNumber(options.center.longitude)) {\n                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS, 'Center coordinates are required to create a map.');\n            }\n\n            options.element = elem;\n\n            var conf = geolocator._.config,\n                key = conf.google.key;\n            options.styles = getStyles(options);\n\n            geolocator.ensureGoogleLoaded(key, function (err) {\n                if (err) {\n                    throw new _geo4.default(_geo4.default.Code.GOOGLE_API_FAILED, String(err.message || err));\n                }\n\n                var mapData = configCreateMap(options);\n                callback(null, mapData);\n            });\n        }\n\n        /**\n         *  Locates the user's location via HTML5 geolocation. This may\n         *  require/prompt for user's permission. If the permission is granted we'll\n         *  get the most accurate location information. Otherwise, we'll fallback to\n         *  locating via user's IP (if enabled).\n         *\n         *  For better accuracy, Geolocator implements a different approach than the\n         *  `getCurrentPosition` API; which generally triggers before the device's\n         *  GPS hardware can provide anything accurate. Thanks to\n         *  {@link https://github.com/gwilson/getAccurateCurrentPosition#background|Greg Wilson}\n         *  for the idea.\n         *\n         *  Also note that HTML5 Geolocation feature no more allows insecure origins.\n         *  See {@link https://goo.gl/rStTGz|this} for more details.\n         *  This means if you don't call this method from an HTTPS page, it will\n         *  fail. And if `options.fallbackToIP` is enabled, this will locate by IP.\n         *\n         *  @param {Object} [options]\n         *         HTML5 geo-location settings with some additional options.\n         *      @param {Boolean} [options.enableHighAccuracy=true]\n         *             Specifies whether the device should provide the most accurate\n         *             position it can. Note that setting this to `true` might\n         *             consume more CPU and/or battery power; and result in slower\n         *             response times.\n         *      @param {Number} [options.desiredAccuracy=30]\n         *             Minimum accuracy desired, in meters. Position will not be\n         *             returned until this is met, before the timeout. This only\n         *             takes effect if `enableHighAccuracy` is set to `true`.\n         *      @param {Number} [options.timeout=5000]\n         *             HTML5 position timeout setting in milliseconds. Setting this\n         *             to `Infinity` means that Geolocator won't return until the\n         *             position is available.\n         *      @param {Number} [options.maximumWait=10000]\n         *             Maximum time to wait (in milliseconds) for the desired\n         *             accuracy (which should be greater than `timeout`).\n         *             This only takes effect if `enableHighAccuracy` is set to\n         *             `true`.\n         *      @param {Number} [options.maximumAge=0]\n         *             HTML5 position maximum age. Indicates the maximum age in\n         *             milliseconds of a possible cached position that is acceptable\n         *             to return. `0` means, the device cannot use a cached position\n         *             and must attempt to retrieve the real current position. If set\n         *             to `Infinity` the device must return a cached position\n         *             regardless of its age. Note that if `enableHighAccuracy` is\n         *             set to `true`, `maximumAge` will be forced to `0`.\n         *      @param {Function} [options.onProgress]\n         *             If `enableHighAccuracy` is set to `true`, you can use this\n         *             callback to check the progress of the location accuracy;\n         *             while waiting for the final, best accurate location.\n         *      @param {Boolean} [options.fallbackToIP=false]\n         *             Specifies whether to fallback to IP geolocation if the HTML5\n         *             geolocation fails (e.g. user rejection).\n         *      @param {Boolean} [options.addressLookup=false]\n         *             Specifies whether to run a reverse-geocode operation for the\n         *             fetched coordinates to retrieve detailed address information.\n         *             Note that this means an additional request which requires a\n         *             Google API key to be set in the Geolocator configuration.\n         *             See {@link #geolocator.config|`geolocator.config()`}.\n         *      @param {Boolean} [options.timezone=false]\n         *             Specifies whether to also fetch the time zone information for\n         *             the receieved coordinates. Note that this means an additional\n         *             request which requires a Google API key to be set in the\n         *             Geolocator configuration.\n         *             See {@link #geolocator.config|`geolocator.config()`}.\n         *      @param {String|MapOptions} [options.map]\n         *             In order to create an interactive map from the fetched\n         *             location coordinates; either set this to a\n         *             {@link #geolocator~MapOptions|`MapOptions` object}\n         *             or; the ID of a DOM element or DOM element itself which the\n         *             map will be created within.\n         *      @param {Boolean|Object} [options.staticMap=false]\n         *             Set to `true` to get a static Google Map image URL (with\n         *             default options); or pass a static map options object.\n         *\n         *  @param {Function} callback\n         *         Callback function to be executed when the request completes.\n         *         This takes 2 arguments: `function (err, location) { ... }`.\n         *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n         *\n         *  @returns {void}\n         *\n         *  @example\n         *  var options = {\n         *      enableHighAccuracy: true,\n         *      desiredAccuracy: 30,\n         *      timeout: 5000,\n         *      maximumWait: 10000,\n         *      maximumAge: 0,\n         *      fallbackToIP: true,\n         *      addressLookup: true,\n         *      timezone: true,\n         *      map: \"my-map\",\n         *      staticMap: true\n         *  };\n         *  geolocator.locate(options, function (err, location) {\n         *      console.log(err || location);\n         *  });\n         *\n         * @example\n         *  // location result:\n         *  {\n         *      coords: {\n         *          latitude: 37.4224764,\n         *          longitude: -122.0842499,\n         *          accuracy: 30,\n         *          altitude: null,\n         *          altitudeAccuracy: null,\n         *          heading: null,\n         *          speed: null\n         *      },\n         *      address: {\n         *          commonName: \"\",\n         *          street: \"Amphitheatre Pkwy\",\n         *          route: \"Amphitheatre Pkwy\",\n         *          streetNumber: \"1600\",\n         *          neighborhood: \"\",\n         *          town: \"\",\n         *          city: \"Mountain View\",\n         *          region: \"Santa Clara County\",\n         *          state: \"California\",\n         *          stateCode: \"CA\",\n         *          postalCode: \"94043\",\n         *          country: \"United States\",\n         *          countryCode: \"US\"\n         *      },\n         *      formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n         *      type: \"ROOFTOP\",\n         *      placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n         *      timezone: {\n         *          id: \"America/Los_Angeles\",\n         *          name: \"Pacific Standard Time\",\n         *          abbr: \"PST\",\n         *          dstOffset: 0,\n         *          rawOffset: -28800\n         *      },\n         *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n         *      map: {\n         *          element: HTMLElement,\n         *          instance: Object, // google.maps.Map\n         *          marker: Object, // google.maps.Marker\n         *          infoWindow: Object, // google.maps.InfoWindow\n         *          options: Object // map options\n         *      },\n         *      staticMap: \"//maps.googleapis.com/maps/api/staticmap?center=37.4224764,-122.0842499&maptype=roadmap&size=600x300&scale=1&zoom=9&format=png&language=en&markers=color%3Ared%7C37.4224764%2C2-122.0842499&key=YOUR-GOOGLE-API-KEY\",\n         *      timestamp: 1456795956380\n         *  }\n         */\n\n    }, {\n        key: 'locate',\n        value: function locate(options, callback) {\n            options = _utils2.default.extend({\n                enableHighAccuracy: true,\n                timeout: 5000,\n                maximumWait: 10000,\n                maximumAge: 0,\n                desiredAccuracy: 30,\n                onProgress: _utils2.default.noop,\n                fallbackToIP: false,\n                addressLookup: false,\n                timezone: false,\n                map: undefined,\n                staticMap: false\n            }, options);\n\n            // force disable cache if high-accuracy is enabled\n            if (options.enableHighAccuracy) options.maximumAge = 0;\n            // set a min value for timeout\n            if (options.timeout < 1000) options.timeout = 1000;\n            // max wait should not be less than timeout\n            if (options.maximumWait < options.timeout) options.maximumWait = options.timeout;\n\n            // check options and Google key\n            checkGoogleKey(options);\n\n            var cb = callbackMap(options, callback);\n\n            function fallbackToIP(error) {\n                if (options.fallbackToIP) {\n                    return geolocator.locateByIP(options, function (err, location) {\n                        if (err) return cb(err, null);\n                        return cb(null, location);\n                    });\n                }\n                cb(error, null);\n            }\n            function onPositionReceived(location) {\n                fetchAddressAndTimezone(location, options, cb);\n            }\n            function onPositionError(err) {\n                err = _geo4.default.create(err);\n                fallbackToIP(err);\n            }\n\n            if (geolocator.isGeolocationSupported()) {\n                if (options.enableHighAccuracy) {\n                    locateAccurate(options, onPositionReceived, onPositionError);\n                } else {\n                    navigator.geolocation.getCurrentPosition(onPositionReceived, onPositionError, options);\n                }\n            } else {\n                var err = new _geo4.default(_geo4.default.Code.GEOLOCATION_NOT_SUPPORTED);\n                fallbackToIP(err);\n            }\n        }\n\n        /**\n         *  Returns a location and accuracy radius based on information about cell\n         *  towers and WiFi nodes that the mobile client can detect; via the Google\n         *  Maps Geolocation API.\n         *  @see {@link https://developers.google.com/maps/documentation/geolocation/intro|Google Maps Geolocation API}\n         *  @see {@link https://developers.google.com/maps/documentation/geolocation/usage-limits|Usage Limits}\n         *\n         *  @param {Object} [options]\n         *         Geolocation options.\n         *      @param {Number} [options.homeMobileCountryCode]\n         *             The mobile country code (MCC) for the device's home network.\n         *      @param {Number} [options.homeMobileNetworkCode]\n         *             The mobile network code (MNC) for the device's home network.\n         *      @param {String} [options.radioType]\n         *             The mobile radio type.\n         *             See {@link #geolocator.RadioType|`geolocator.RadioType` enumeration}\n         *             for possible values. While this field is optional, it should\n         *             be included if a value is available, for more accurate results.\n         *      @param {string} [options.carrier]\n         *             The carrier name. e.g. \"Vodafone\"\n         *      @param {Boolean} [options.fallbackToIP=false]\n         *             Specifies whether to fallback to IP geolocation if wifi and\n         *             cell tower signals are not available. Note that the IP address\n         *             in the request header may not be the IP of the device. Set\n         *             `fallbackToIP` to `false` to disable fall back.\n         *      @param {Array} [options.cellTowers]\n         *             An array of cell tower objects.\n         *             See {@link https://developers.google.com/maps/documentation/geolocation/intro#cell_tower_object|Cell tower objects} for details.\n         *      @param {Array} [options.wifiAccessPoints]\n         *             An array of WiFi access point objects.\n         *             See {@link https://developers.google.com/maps/documentation/geolocation/intro#wifi_access_point_object|WiFi access point objects} for details.\n         *      @param {Boolean} [options.addressLookup=false]\n         *             Specifies whether to run a reverse-geocode operation for the\n         *             fetched coordinates to retrieve detailed address information.\n         *             Note that this means an additional request which requires a\n         *             Google API key to be set in the Geolocator configuration.\n         *             See {@link #geolocator.config|`geolocator.config()`}.\n         *      @param {Boolean} [options.timezone=false]\n         *             Specifies whether to also fetch the time zone information for\n         *             the receieved coordinates. Note that this means an additional\n         *             request which requires a Google API key to be set in the\n         *             Geolocator configuration.\n         *             See {@link #geolocator.config|`geolocator.config()`}.\n         *      @param {String|MapOptions} [options.map]\n         *             In order to create an interactive map from the fetched\n         *             location coordinates; either set this to a\n         *             {@link #geolocator~MapOptions|`MapOptions` object}\n         *             or; the ID of a DOM element or DOM element itself which the\n         *             map will be created within.\n         *      @param {Boolean|Object} [options.staticMap=false]\n         *             Set to `true` to get a static Google Map image URL (with\n         *             default options); or pass a static map options object.\n         *      @param {Boolean} [options.raw=false]\n         *      \t      Whether to return the raw Google API result.\n         *  @param {Function} callback\n         *         Callback function to be executed when the request completes.\n         *         This takes 2 arguments: `function (err, location) { ... }`.\n         *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n         *\n         *  @returns {void}\n         *\n         *  @example\n         *  var options = {\n         *      homeMobileCountryCode: 310,\n         *      homeMobileNetworkCode: 410,\n         *      carrier: 'Vodafone',\n         *      radioType: geolocator.RadioType.GSM,\n         *      fallbackToIP: true,\n         *      addressLookup: false,\n         *      timezone: false,\n         *      map: \"my-map\",\n         *      staticMap: false\n         *  };\n         *  geolocator.locateByMobile(options, function (err, location) {\n         *      console.log(err || location);\n         *  });\n         */\n\n    }, {\n        key: 'locateByMobile',\n        value: function locateByMobile(options, callback) {\n            if (!_utils2.default.isPlainObject(options)) {\n                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS);\n            }\n\n            var cb = callbackMap(options, callback);\n\n            options = _utils2.default.extend({\n                homeMobileCountryCode: undefined,\n                homeMobileNetworkCode: undefined,\n                radioType: undefined,\n                carrier: undefined,\n                fallbackToIP: false,\n                cellTowers: undefined,\n                wifiAccessPoints: undefined,\n                addressLookup: false,\n                timezone: false,\n                map: undefined,\n                raw: false\n            }, options);\n\n            options.considerIp = options.fallbackToIP;\n            // check Google key\n            checkGoogleKey();\n\n            var conf = geolocator._.config,\n                key = conf.google.key || '',\n                url = _utils2.default.setProtocol(_enums2.default.URL.GOOGLE_GEOLOCATION, conf.https),\n                xhrOpts = {\n                url: url + '?key=' + key,\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                data: JSON.stringify(options)\n            };\n            // console.log(xhrOpts.data);\n\n            _fetch2.default.post(xhrOpts, function (err, xhr) {\n                var response = getXHRResponse(err, xhr);\n                if (_geo4.default.isGeoError(response)) return cb(response, null);\n\n                response = options.raw ? response : {\n                    coords: {\n                        latitude: response.location.lat,\n                        longitude: response.location.lng,\n                        accuracy: response.accuracy\n                    },\n                    timestamp: _utils2.default.time()\n                };\n\n                fetchAddressAndTimezone(response, options, cb);\n\n                // e.g. raw response\n                // {\n                //     \"location\": {\n                //         \"lat\": 51.0,\n                //         \"lng\": -0.1\n                //     },\n                //     \"accuracy\": 1200.4\n                // }\n            });\n        }\n\n        /**\n         *  Locates the user's location by the client's IP.\n         *\n         *  This method uses FreeGeoIP's lookup service, by default.\n         *  In order to change the source provider, you can use\n         *  {@link #geolocator.setGeoIPSource|`geolocator.setGeoIPSource()` method}.\n         *\n         *  @param {Object} [options]\n         *         Locate options.\n         *      @param {Boolean} [options.addressLookup=false]\n         *             Specifies whether to run a reverse-geocode operation for the\n         *             fetched coordinates to retrieve detailed address information.\n         *             Since no precise address can be fetched from an IP addres; you\n         *             should only enable this if the Geo-IP Source returns no useful\n         *             address information other than coordinates. Also, note that\n         *             this means an additional request which requires a Google API\n         *             key to be set in the Geolocator configuration.\n         *             See {@link #geolocator.config|`geolocator.config()`}.\n         *      @param {Boolean} [options.timezone=false]\n         *             Specifies whether to also fetch the time zone information for\n         *             the receieved coordinates. Note that this means an additional\n         *             request which requires a Google API key to be set in the\n         *             Geolocator configuration.\n         *             See {@link #geolocator.config|`geolocator.config()`}.\n         *      @param {String|MapOptions} [options.map]\n         *             In order to create an interactive map from the fetched\n         *             location coordinates; either set this to a\n         *             {@link #geolocator~MapOptions|`MapOptions` object}\n         *             or; the ID of a DOM element or DOM element itself which the\n         *             map will be created within.\n         *      @param {Boolean|Object} [options.staticMap=false]\n         *             Set to `true` to get a static Google Map image URL (with\n         *             default options); or pass a static map options object.\n         *  @param {Function} callback\n         *         Callback function to be executed when the request completes.\n         *         This takes 2 arguments: `function (err, location) { ... }`.\n         *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n         *\n         *  @returns {void}\n         *\n         *  @example\n         *  var options = {\n         *  \taddressLookup: true,\n         *  \ttimezone: true,\n         *  \tmap: \"my-map\",\n         *  \tstaticMap: true\n         *  };\n         *  geolocator.locateByIP(options, function (err, location) {\n         *  \tconsole.log(err || location);\n         *  });\n         *\n         *  @example\n         *  // location result:\n         *  {\n         *      coords: {\n         *          latitude: 41.0214,\n         *          longitude: 28.9948,\n         *      },\n         *      address: {\n         *          city: \"Istanbul\",\n         *          region: \"34\",\n         *          state: \"34\",\n         *          country: \"Turkey\",\n         *          countryCode: \"TR\"\n         *      },\n         *      formattedAddress: \"Demirtaş, Tesviyeci Sk. No:7, 34134 Fatih/İstanbul, Turkey\",\n         *      type: \"ROOFTOP\",\n         *      placeId: \"ChIJ-ZRLfO25yhQRBi5YJxX80Q0\",\n         *      timezone: {\n         *          id: \"Europe/Istanbul\",\n         *          name: \"Eastern European Summer Time\",\n         *          abbr: \"EEST\",\n         *          dstOffset: 3600,\n         *          rawOffset: 7200\n         *      },\n         *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/tr.svg\",\n         *      map: {\n         *          element: HTMLElement,\n         *          instance: Object, // google.maps.Map\n         *          marker: Object, // google.maps.Marker\n         *          infoWindow: Object, // google.maps.InfoWindow\n         *          options: Object // map options\n         *      },\n         *      staticMap: \"//maps.googleapis.com/maps/api/staticmap?center=41.0214,28.9948&maptype=roadmap&size=600x300&scale=1&zoom=9&format=png&language=en&markers=color%3Ared%7C41.0214%2C228.9948&key=YOUR-GOOGLE-API-KEY\",\n         *      provider: \"freegeoip\",\n         *      timestamp: 1466216325223\n         *  }\n         */\n\n    }, {\n        key: 'locateByIP',\n        value: function locateByIP(options, callback) {\n            // passed source can be a string or object\n            var source = geolocator._.geoIpSource;\n\n            if (!_utils2.default.isPlainObject(source)) {\n                throw new _geo4.default(_geo4.default.Code.INVALID_GEO_IP_SOURCE, 'Please set a valid Geo-IP Source via geolocator.setGeoIPSource(options).');\n            }\n\n            // check options and Google key\n            checkGoogleKey(options || {});\n\n            var jsonpOpts = {\n                url: source.url,\n                async: true,\n                clean: true\n                // params: {}\n            };\n            if (source.callbackParam) {\n                jsonpOpts.callbackParam = source.callbackParam;\n                jsonpOpts.rootName = 'geolocator._.cb';\n            } else if (!source.globalVar) {\n                throw new _geo4.default(_geo4.default.Code.INVALID_GEO_IP_SOURCE, 'Either callbackParam or globalVar should be set for Geo-IP source.');\n            }\n            return _fetch2.default.jsonp(jsonpOpts, function (err, response) {\n                if (err) {\n                    return callback(_geo4.default.create(err), null);\n                }\n                if (source.globalVar) {\n                    if (window[source.globalVar]) {\n                        response = _utils2.default.clone(window[source.globalVar]);\n                        delete window[source.globalVar];\n                    } else {\n                        response = null;\n                    }\n                }\n                if (!response) {\n                    err = new _geo4.default(_geo4.default.Code.INVALID_RESPONSE);\n                    return callback(err, null);\n                }\n                if (_utils2.default.isPlainObject(source.schema)) {\n                    response = _utils2.default.mapToSchema(response, source.schema);\n                }\n                response.provider = source.provider || 'unknown';\n                setLocationURLs(response, options);\n                if (response.coords) {\n                    response.coords.latitude = Number(response.coords.latitude);\n                    response.coords.longitude = Number(response.coords.longitude);\n                }\n                var cb = callbackMap(options, callback);\n                fetchAddressAndTimezone(response, options, cb);\n            });\n        }\n\n        /**\n         *  Sets the Geo-IP source to be used for fetching location information\n         *  by user's IP; which is internally used by\n         *  {@link #geolocator.locateByIP|`geolocator.locateByIP()` method}.\n         *\n         *  By default, Geolocator uses FreeGeoIP as the Geo-IP source provider.\n         *  You can use this method to change this; or you can choose from\n         *  ready-to-use\n         *  {@link https://github.com/onury/geolocator/tree/master/src/geo-ip-sources|Geo-IP sources}.\n         *\n         *  @param {Object} options\n         *         Geo-IP Source options.\n         *      @param {String} [options.provider]\n         *             Source or service provider's name.\n         *      @param {String} options.url\n         *             Source URL without the callback query parameter. The callback\n         *             name (if supported) should be set via `options.callbackParam`.\n         *             Also, make sure the service supports the protocol you use in\n         *             the enums.URL. If it supports both HTTP and HTTPS, you can omit the\n         *             protocol. In this case, it will be determined via Geolocator\n         *             configuration.\n         *             See {@link #geolocator.config|`geolocator.config()`}.\n         *             NOTE: Do not forget to include your API key in the query\n         *             parameters of the URL, if you have one.\n         *      @param {String} [options.callbackParam]\n         *             If JSON callback is supported, pass the name of the callback\n         *             parameter, defined by the provider.\n         *      @param {Object} [options.globalVar]\n         *             Set this instead of `options.callbackParam` if the service\n         *             does not support JSON callbacks, but weirdly set a global\n         *             variable in the document. For example, if the response is\n         *             `Geo = { lat, lng }`, you should set this to `\"Geo\"`.\n         *      @param {Object} [options.schema]\n         *             Schema object to be used to re-structure the response returned\n         *             from the service. Set the response object's keys as values of\n         *             a custom object to map the format to the `location` object.\n         *             For example; if the service returns a response like\n         *             `{ lat: 40.112233, lng: 10.112233, otherProp: 'hello' }`.\n         *             Then you should set the following schema:\n         *             `{ coords: { latitude: 'lat', longitude: 'lng' } }`.\n         *\n         *  @return {geolocator}\n         */\n\n    }, {\n        key: 'setGeoIPSource',\n        value: function setGeoIPSource(options) {\n            if (!_utils2.default.isPlainObject(options)) {\n                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS, 'Geo-IP source options is invalid.');\n            }\n            if (!_utils2.default.isStringSet(options.url)) {\n                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS, 'Geo-IP source should have a valid URI.');\n            }\n            // if (!utils.isStringSet(options.callbackParam) && !utils.isStringSet(options.globalVar)) {\n            //     throw new GeoError(GeoError.Code.INVALID_PARAMETERS, 'No \\'callbackParam\\' or \\'globalVar\\' is provided for the Geo-IP Source options.');\n            // }\n            geolocator._.geoIpSource = Object.freeze(options);\n        }\n\n        /**\n         *  Registers a handler for watching the user's location via HTML5\n         *  geolocation; that is triggered each time the position of the device\n         *  changes. This may require/prompt for user's permission.\n         *\n         *  @param {Object} [options]\n         *         HTML5 geo-location settings.\n         *      @param {Boolean} [options.enableHighAccuracy=true]\n         *             Specifies whether the device should provide the most accurate\n         *             position it can. Note that setting this to `true` might consume\n         *             more CPU and/or battery power; and result in slower response\n         *             times.\n         *      @param {Number} [options.timeout=6000]\n         *             HTML5 position timeout setting in milliseconds. Setting this\n         *             to `Infinity` means that Geolocator won't return until the\n         *             position is available.\n         *      @param {Number} [options.maximumAge=0]\n         *             HTML5 position maximum age. Indicates the maximum age in\n         *             milliseconds of a possible cached position that is acceptable\n         *             to return. `0` means, the device cannot use a cached position\n         *             and must attempt to retrieve the real current position. If set\n         *             to `Infinity` the device must return a cached position\n         *             regardless of its age.\n         *      @param {Boolean} [options.clearOnError=false]\n         *             Specifies whether to clear the watcher on first error so that\n         *             it does not execute any more callbacks.\n         *      @param {Object} [options.target]\n         *             Object that defines the target location and settings; that\n         *             when the location is reached, the watcher will auto-clear\n         *             itself and invoke the callback.\n         *      @param {Number} options.target.latitude\n         *             The `latitude` of the target location.\n         *      @param {Number} options.target.longitude\n         *             The `longitude` of the target location.\n         *      @param {Number} [options.target.radius=0.5]\n         *             The radius, in other words; the minimum distance (in\n         *             kilometers or miles) to the target point that should be\n         *             reached.\n         *      @param {Number} [options.target.unitSystem=0]\n         *             Unit system to be used for target radius.\n         *             See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}\n         *             for possible values.\n         *  @param {Function} callback\n         *         Callback function to be executed when the request completes.\n         *         This takes 2 arguments: `function (err, location) { ... }`.\n         *         If `options.target` is set, `location` will also\n         *         include a `targetReached:Boolean` property.\n         *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n         *\n         *  @returns {GeoWatcher} - A watcher object that provides a\n         *  `.clear(delay:Number, callback:Function)` method to clear the watcher\n         *  when needed. Optional `delay` argument can be set (in milliseconds) to\n         *  clear in a later time. Omitting this argument will clear the watcher\n         *  immediately. You should always call this method, except if you've set up\n         *  a target; which will auto-clear the watcher when reached.\n         *\n         *  @example\n         *  // Watch my position for 5 minutes.\n         *  var options = { enableHighAccuracy: true, timeout: 6000, maximumAge: 0 };\n         *  var watcher = geolocator.watch(options, function (err, location) {\n         *      console.log(err || location);\n         *  });\n         *  console.log(watcher.id); // ID of the watcher\n         *  watcher.clear(300000); // clear after 5 minutes.\n         *\n         *  @example\n         *  // Watch my position until I'm 350 meters near Disneyland Park.\n         *  options.target = {\n         *      latitude: 33.8120918,\n         *      longitude: -117.9233569,\n         *      radius: 0.35,\n         *      unitSystem: geolocator.UnitSystem.METRIC\n         *  };\n         *  watcher = geolocator.watch(options, function (err, location) {\n         *      if (err) {\n         *          console.log(err);\n         *          return;\n         *      }\n         *      if (location.targetReached) {\n         *          console.log(watcher.isCleared); // true\n         *          console.log(watcher.cycle); // 15 — target reached after 15 cycles\n         *      } else {\n         *          console.log(watcher.isCleared); // false — watcher is active.\n         *      }\n         *  });\n         */\n\n    }, {\n        key: 'watch',\n        value: function watch(options, callback) {\n            if (!geolocator.isGeolocationSupported()) {\n                callback(new _geo4.default(_geo4.default.Code.GEOLOCATION_NOT_SUPPORTED), null);\n                return {};\n            }\n\n            var watcher = void 0,\n                target = void 0;\n\n            options = _utils2.default.extend({\n                enableHighAccuracy: true,\n                timeout: 6000,\n                maximumAge: 0,\n                clearOnError: false\n            }, options);\n\n            if (_utils2.default.isPlainObject(options.target)) {\n                target = _utils2.default.extend({\n                    radius: 0.5,\n                    unitSystem: geolocator.UnitSystem.METRIC\n                }, options.target);\n            }\n\n            function onPositionChanged(location) {\n                var pos = _utils2.default.clone(location, { own: false });\n                if (target) {\n                    var distance = geolocator.calcDistance({\n                        from: location.coords,\n                        to: target,\n                        formula: geolocator.DistanceFormula.HAVERSINE,\n                        unitSystem: target.unitSystem\n                    });\n                    pos.targetReached = distance <= target.radius;\n                    if (watcher && pos.targetReached) {\n                        watcher.clear(function () {\n                            return callback(null, pos);\n                        });\n                    }\n                }\n                return callback(null, pos);\n            }\n            function onPositionError(err) {\n                callback(_geo4.default.create(err), null);\n            }\n            return new _geo6.default(onPositionChanged, onPositionError, options);\n        }\n\n        /**\n         *  Converts a given address (or address components) into geographic\n         *  coordinates (i.e. latitude, longitude); and gets detailed address\n         *  information.\n         *  @see {@link https://developers.google.com/maps/documentation/geocoding/intro|Google Maps Geocoding API}\n         *  @see {@link https://developers.google.com/maps/documentation/geocoding/usage-limits|Usage Limits}\n         *\n         *  @param {String|Object} options\n         *         Either the address to geocode or geocoding options with the\n         *         following properties.\n         *      @param {String} options.address\n         *             The street address to geocode, in the format used by the\n         *             national postal service of the country concerned. Additional\n         *             address elements such as business names and unit, suite or\n         *             floor numbers should be avoided. Note that any address\n         *             component (route, locality, administrativeArea, postalCode and\n         *             country) should be specified either in address or the\n         *             corresponding property - not both. Doing so may result in\n         *             `ZERO_RESULTS`.\n         *      @param {String} [options.route]\n         *      \t      Long or short name of a route.\n         *      @param {String} [options.locality]\n         *      \t      Locality and sublocality of the location.\n         *      @param {String} [options.administrativeArea]\n         *      \t      Administrative area of the location.\n         *      @param {String} [options.postalCode]\n         *      \t      Postal code of the location.\n         *      @param {String} [options.country]\n         *      \t      A country name or a two letter ISO 3166-1 country code.\n         *      @param {String} [options.region]\n         *      \t      The region code, specified as a ccTLD (\"top-level domain\")\n         *      \t      two-character value. e.g.: `\"fr\"` for France.\n         *      @param {Array|Object} [options.bounds]\n         *      \t      The bounding box of the viewport within which to bias geocode\n         *      \t      results more prominently. e.g.:\n         *      \t      `[ southwestLat:Number, southwestLng:Number, northeastLat:Number, northeastLng:Number ]`\n         *      @param {String|MapOptions} [options.map]\n         *             In order to create an interactive map from the fetched\n         *             location coordinates; either set this to a\n         *             {@link #geolocator~MapOptions|`MapOptions` object}\n         *             or; the ID of a DOM element or DOM element itself which the\n         *             map will be created within.\n         *      @param {Boolean|Object} [options.staticMap=false]\n         *             Set to `true` to get a static Google Map image URL (with\n         *             default options); or pass a static map options object.\n         *      @param {Boolean} [options.raw=false]\n         *      \t      Whether to return the raw Google API result.\n         *  @param {Function} callback\n         *         Callback function to be executed when the request completes.\n         *         This takes 2 arguments: `function (err, location) { ... }`.\n         *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n         *\n         *  @returns {void}\n         *\n         *  @example\n         *  var address = '1600 Amphitheatre Parkway, CA';\n         *  geolocator.geocode(address, function (err, location) {\n         *      console.log(err || location);\n         *  });\n         *\n         *  @example\n         *  // location result:\n         *  {\n         *      coords: {\n         *          latitude: 37.4224764,\n         *          longitude: -122.0842499\n         *      },\n         *      address: {\n         *          commonName: \"\",\n         *          street: \"Amphitheatre Pkwy\",\n         *          route: \"Amphitheatre Pkwy\",\n         *          streetNumber: \"1600\",\n         *          neighborhood: \"\",\n         *          town: \"\",\n         *          city: \"Mountain View\",\n         *          region: \"Santa Clara County\",\n         *          state: \"California\",\n         *          stateCode: \"CA\",\n         *          postalCode: \"94043\",\n         *          country: \"United States\",\n         *          countryCode: \"US\"\n         *      },\n         *      formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n         *      type: \"ROOFTOP\",\n         *      placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n         *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n         *      map: {\n         *          element: HTMLElement,\n         *          instance: Object, // google.maps.Map\n         *          marker: Object, // google.maps.Marker\n         *          infoWindow: Object, // google.maps.InfoWindow\n         *          options: Object // map options\n         *      },\n         *      timestamp: 1456795956380\n         *  }\n         */\n\n    }, {\n        key: 'geocode',\n        value: function geocode(options, callback) {\n            _geocode(false, options, callback);\n        }\n\n        /**\n         *  Converts the given geographic coordinates into a human-readable address\n         *  information.\n         *  @see {@link https://developers.google.com/maps/documentation/geocoding/intro#ReverseGeocoding|Google Maps (Reverse) Geocoding API}\n         *  @see {@link https://developers.google.com/maps/documentation/geocoding/usage-limits|Usage Limits}\n         *  @alias geolocator.addressLookup\n         *\n         *  @param {Object|String} options\n         *         Either the `placeId` of the location or Reverse Geocoding options\n         *         with the following properties.\n         *      @param {Number} options.latitude\n         *      Latitude of the target location.\n         *      @param {Number} options.longitude\n         *      Longitude of the target location.\n         *      @param {String} [options.placeId]\n         *             Required if `latitude` and `longitude` are omitted. The place\n         *             ID of the place for which you wish to obtain the\n         *             human-readable address. The place ID is a unique identifier\n         *             that can be used with other Google APIs. Note that if\n         *             `placeId` is set, `latitude` and `longitude` are ignored.\n         *      @param {String|MapOptions} [options.map]\n         *             In order to create an interactive map from the fetched\n         *             location coordinates; either set this to a\n         *             {@link #geolocator~MapOptions|`MapOptions` object}\n         *             or; the ID of a DOM element or DOM element itself which the\n         *             map will be created within.\n         *      @param {Boolean|Object} [options.staticMap=false]\n         *             Set to `true` to get a static Google Map image URL (with\n         *             default options); or pass a static map options object.\n         *      @param {Boolean} [options.raw=false]\n         *             Whether to return the raw Google API result.\n         *  @param {Function} callback\n         *         Callback function to be executed when the request completes.\n         *         This takes 2 arguments: `function (err, location) { ... }`\n         *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n         *\n         *  @returns {void}\n         *\n         *  @example\n         *  var coords = {\n         *      latitude: 37.4224764,\n         *      longitude: -122.0842499\n         *  };\n         *\n         *  geolocator.reverseGeocode(coords, function (err, location) {\n         *      console.log(err || location);\n         *  });\n         *\n         *  @example\n         *  // location result:\n         *  {\n         *      coords: {\n         *          latitude: 37.4224764,\n         *          longitude: -122.0842499\n         *      },\n         *      address: {\n         *          commonName: \"\",\n         *          street: \"Amphitheatre Pkwy\",\n         *          route: \"Amphitheatre Pkwy\",\n         *          streetNumber: \"1600\",\n         *          neighborhood: \"\",\n         *          town: \"\",\n         *          city: \"Mountain View\",\n         *          region: \"Santa Clara County\",\n         *          state: \"California\",\n         *          stateCode: \"CA\",\n         *          postalCode: \"94043\",\n         *          country: \"United States\",\n         *          countryCode: \"US\"\n         *      },\n         *      formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n         *      type: \"ROOFTOP\",\n         *      placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n         *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n         *      map: {\n         *          element: HTMLElement,\n         *          instance: Object, // google.maps.Map\n         *          marker: Object, // google.maps.Marker\n         *          infoWindow: Object, // google.maps.InfoWindow\n         *          options: Object // map options\n         *      },\n         *      timestamp: 1456795956380\n         *  }\n         */\n\n    }, {\n        key: 'reverseGeocode',\n        value: function reverseGeocode(options, callback) {\n            _geocode(true, options, callback);\n        }\n\n        /**\n         *  Alias for `geolocator.reverseGeocode`\n         *  @private\n         */\n\n    }, {\n        key: 'addressLookup',\n        value: function addressLookup(options, callback) {\n            geolocator.reverseGeocode(options, callback);\n        }\n\n        /**\n         *  Gets timezone information for the given coordinates.\n         *  Note: Google Browser API keys cannot have referer restrictions when used with this API.\n         *  @see {@link https://developers.google.com/maps/documentation/timezone/intro|Google Maps TimeZone API}\n         *  @see {@link https://developers.google.com/maps/documentation/timezone/usage-limits|Usage Limits}\n         *\n         *  @param {Object} options\n         *         Time zone options.\n         *      @param {Number} options.latitude\n         *             Latitude of location.\n         *      @param {Number} options.longitude\n         *             Longitude of location.\n         *      @param {Number} [options.timestamp=Date.now()]\n         *             Specifies the desired time as seconds since midnight, January\n         *             1, 1970 UTC. This is used to determine whether or not Daylight\n         *             Savings should be applied.\n         *      @param {Boolean} [options.raw=false]\n         *             Whether to return the raw Google API result.\n         *  @param {Function} callback\n         *         Callback function to be executed when the request completes, in\n         *         the following signature: `function (err, timezone) { ... }`.\n         *         See {@link #geolocator~TimeZone|`geolocator~TimeZone` type} for\n         *         details.\n         *\n         *  @returns {void}\n         *\n         *  @example\n         *  var options = {\n         *      latitude: 48.8534100,\n         *      longitude: 2.3488000\n         *  };\n         *  geolocator.getTimeZone(options, function (err, timezone) {\n         *      console.log(err || timezone);\n         *  });\n         *\n         *  @example\n         *  // timezone result:\n         *  {\n         *      id: \"Europe/Paris\",\n         *      name: \"Central European Standard Time\",\n         *      abbr: \"CEST\",\n         *      dstOffset: 0,\n         *      rawOffset: 3600,\n         *      timestamp: 1455733120\n         *  }\n         */\n\n    }, {\n        key: 'getTimeZone',\n        value: function getTimeZone(options, callback) {\n            if (!_utils2.default.isPlainObject(options) || !_utils2.default.isNumber(options.latitude) || !_utils2.default.isNumber(options.longitude)) {\n                throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS);\n            }\n\n            checkGoogleKey();\n\n            var conf = geolocator._.config;\n            options = _utils2.default.extend({\n                key: conf.google.key || '',\n                language: conf.language || 'en',\n                timestamp: _utils2.default.time(true),\n                raw: false\n            }, options);\n\n            var url = _utils2.default.setProtocol(_enums2.default.URL.GOOGLE_TIMEZONE, conf.https),\n                xhrOpts = {\n                url: url + '?location=' + options.latitude + ',' + options.longitude + '&timestamp=' + options.timestamp + '&language=' + options.language + '&key=' + options.key\n            };\n\n            _fetch2.default.xhr(xhrOpts, function (err, xhr) {\n                var response = getXHRResponse(err, xhr);\n                if (_geo4.default.isGeoError(response)) return callback(response, null);\n\n                response = options.raw ? response : {\n                    id: response.timeZoneId,\n                    name: response.timeZoneName,\n                    abbr: _utils2.default.abbr(response.timeZoneName, { dots: false }),\n                    dstOffset: response.dstOffset,\n                    rawOffset: response.rawOffset,\n                    timestamp: options.timestamp\n                };\n                callback(err, response);\n            });\n        }\n\n        /**\n         *  Gets the distance and duration values based on the recommended route\n         *  between start and end points.\n         *  @see {@link https://developers.google.com/maps/documentation/distance-matrix/intro|Google Maps Distance Matrix API}\n         *  @see {@link https://developers.google.com/maps/documentation/distance-matrix/usage-limits|Usage Limits}\n         *\n         *  @param {Object} options\n         *         Distance matrix options.\n         *      @param {String|Object|Array} options.origins\n         *             One or more addresses and/or an object of latitude/longitude\n         *             values, from which to calculate distance and time. If you pass\n         *             an address as a string, the service will geocode the string\n         *             and convert it to a latitude/longitude coordinate to calculate\n         *             distances. Following are valid examples:\n         *  <pre><code>options.origins = 'London';\n         *  options.origins = ['London', 'Paris'];\n         *  options.origins = { latitude: 51.5085300, longitude: -0.1257400 };\n         *  options.origins = [\n         *      { latitude: 51.5085300, longitude: -0.1257400 },\n         *      { latitude: 48.8534100, longitude: 2.3488000 }\n         *  ];\n         *  </code></pre>\n         *      @param {String|Object|Array} options.destinations\n         *             One or more addresses and/or an object of latitude/longitude\n         *             values, from which to calculate distance and time. If you pass\n         *             an address as a string, the service will geocode the string\n         *             and convert it to a latitude/longitude coordinate to calculate\n         *             distances.\n         *      @param {String} [options.travelMode=\"DRIVING\"]\n         *             Type of routing requested.\n         *             See {@link #geolocator.TravelMode|`geolocator.TravelMode` enumeration}\n         *             for possible values.\n         *      @param {Boolean} [options.avoidFerries]\n         *             If true, instructs the Distance Matrix service to avoid\n         *             ferries where possible.\n         *      @param {Boolean} [options.avoidHighways]\n         *             If true, instructs the Distance Matrix service to avoid\n         *             highways where possible.\n         *      @param {Boolean} [options.avoidTolls]\n         *             If true, instructs the Distance Matrix service to avoid toll\n         *             roads where possible.\n         *      @param {Number} [options.unitSystem=0]\n         *             Preferred unit system to use when displaying distance.\n         *             See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}\n         *             for possible values.\n         *      @param {String} [options.region]\n         *             Region code used as a bias for geocoding requests.\n         *  @param {Boolean} [options.raw=false]\n         *         Whether to return the raw Google API result.\n         *  @param {Function} callback\n         *         Callback function to be executed when the request completes,\n         *         in the following signature: `function (err, result) { ... }`\n         *\n         *  @returns {void}\n         *\n         *  @example\n         *  var options = {\n         *      origins: [{ latitude: 51.5085300, longitude: -0.1257400 }],\n         *      destinations: [{ latitude: 48.8534100, longitude: 2.3488000 }],\n         *      travelMode: geolocator.TravelMode.DRIVING,\n         *      unitSystem: geolocator.UnitSystem.METRIC\n         *  };\n         *  geolocator.getDistanceMatrix(options, function (err, result) {\n         *      console.log(err || result);\n         *  });\n         *\n         *  @example\n         *  // result:\n         *  [\n         *  \t{\n         *  \t\tfrom: \"449 Duncannon St, London WC2R 0DZ, UK\",\n         *  \t\tto: \"1 Parvis Notre-Dame - Pl. Jean-Paul II, 75004 Paris-4E-Arrondissement, France\",\n         *  \t\tdistance: {\n         *  \t\t\tvalue: 475104,\n         *  \t\t\ttext: \"475 km\"\n         *  \t\t},\n         *  \t\tduration: {\n         *  \t\t\tvalue: 20193,\n         *  \t\t\ttext: \"5 hours 37 mins\"\n         *  \t\t},\n         *  \t\tfare: undefined,\n         *  \t\ttimestamp: 1456795956380\n         *  \t}\n         *  ]\n         */\n\n    }, {\n        key: 'getDistanceMatrix',\n        value: function getDistanceMatrix(options, callback) {\n            checkGoogleKey();\n\n            var key = geolocator._.config.google.key;\n            geolocator.ensureGoogleLoaded(key, function (err) {\n                if (err) {\n                    throw new _geo4.default(_geo4.default.Code.GOOGLE_API_FAILED, String(err.message || err));\n                }\n\n                var o = options.origins || options.origin || options.from,\n                    d = options.destinations || options.destination || options.to;\n                if (!_utils2.default.isPlainObject(options) || invalidOriginOrDest(o) || invalidOriginOrDest(d)) {\n                    throw new _geo4.default(_geo4.default.Code.INVALID_PARAMETERS);\n                }\n                options.origins = _geo2.default.toPointList(o);\n                options.destinations = _geo2.default.toPointList(d);\n\n                options = _utils2.default.extend({\n                    travelMode: google.maps.TravelMode.DRIVING,\n                    avoidFerries: undefined,\n                    avoidHighways: undefined,\n                    avoidTolls: undefined,\n                    unitSystem: google.maps.UnitSystem.METRIC\n                }, options);\n\n                var service = new google.maps.DistanceMatrixService();\n                service.getDistanceMatrix(options, function (response, status) {\n                    var err = null;\n                    if (status !== google.maps.DistanceMatrixStatus.OK) {\n                        err = _geo4.default.fromResponse(status) || _geo4.default.fromResponse(response);\n                        response = null;\n                    } else {\n                        response = options.raw ? response : _geo2.default.formatDistanceResults(response);\n                    }\n                    callback(err, response);\n                });\n            });\n        }\n\n        /**\n         *  Calculates the distance between two geographic points.\n         *\n         *  @param {Object} options\n         *         Calculation and display options.\n         *      @param {Object} options.from\n         *             Object containing the `latitude` and `longitude` of original\n         *             location.\n         *      @param {Object} options.to\n         *             Object containing the `latitude` and `longitude` of destination.\n         *      @param {String} [options.formula=\"haversine\"]\n         *             The algorithm or formula to calculate the distance.\n         *             See {@link #geolocator.DistanceFormula|`geolocator.DistanceFormula` enumeration}.\n         *      @param {Number} [options.unitSystem=0]\n         *             Preferred unit system to use when displaying distance.\n         *             See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}.\n         *\n         *  @returns {Number} - The calculated distance.\n         *\n         *  @example\n         *  // Calculate distance from London to Paris.\n         *  var result = geolocator.calcDistance({\n         *      from: {\n         *          latitude: 51.5085300,\n         *          longitude: -0.1257400\n         *      },\n         *      to: {\n         *          latitude: 48.8534100,\n         *          longitude: 2.3488000\n         *      },\n         *      formula: geolocator.DistanceFormula.HAVERSINE,\n         *      unitSystem: geolocator.UnitSystem.METRIC\n         *  });\n         *  // result: 366.41656039126093 (kilometers)\n         */\n\n    }, {\n        key: 'calcDistance',\n        value: function calcDistance(options) {\n            options = _utils2.default.extend({\n                formula: geolocator.DistanceFormula.HAVERSINE,\n                unitSystem: geolocator.UnitSystem.METRIC\n            }, options);\n\n            var from = options.from,\n                to = options.to,\n                radius = options.unitSystem === geolocator.UnitSystem.METRIC ? EARTH_RADIUS_KM : EARTH_RADIUS_MI;\n\n            if (options.formula === geolocator.DistanceFormula.HAVERSINE) {\n                var dLat = geolocator.degToRad(to.latitude - from.latitude),\n                    dLng = geolocator.degToRad(to.longitude - from.longitude),\n                    a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(geolocator.degToRad(from.latitude)) * Math.cos(geolocator.degToRad(to.longitude)) * Math.sin(dLng / 2) * Math.sin(dLng / 2),\n                    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n                return radius * c;\n            }\n            // geolocator.DistanceFormula.PYTHAGOREAN\n            var latA = geolocator.degToRad(from.latitude),\n                latB = geolocator.degToRad(to.latitude),\n                lngA = geolocator.degToRad(from.longitude),\n                lngB = geolocator.degToRad(to.longitude),\n                x = (lngB - lngA) * Math.cos((latA + latB) / 2),\n                y = latB - latA;\n            return Math.sqrt(x * x + y * y) * radius;\n        }\n\n        /**\n         *  Gets the current public IP of the client.\n         *\n         *  @param {Function} callback\n         *         Callback function to be executed when the request completes, in\n         *         the following signature: `function (err, result) { ... }`\n         *\n         *  @returns {void}\n         *\n         *  @example\n         *  geolocator.getIP(function (err, result) {\n         *      console.log(err || result);\n         *  });\n         *\n         *  @example\n         *  // result:\n         *  {\n         *      ip: \"176.232.71.155\",\n         *      timestamp: 1457573683427\n         *  }\n         */\n\n    }, {\n        key: 'getIP',\n        value: function getIP(callback) {\n            var conf = geolocator._.config;\n\n            var jsonpOpts = {\n                url: _utils2.default.setProtocol(_enums2.default.URL.IP, conf.https),\n                async: true,\n                clean: true,\n                params: {\n                    format: 'jsonp'\n                },\n                callbackParam: 'callback',\n                rootName: 'geolocator._.cb'\n            };\n            return _fetch2.default.jsonp(jsonpOpts, function (err, response) {\n                if (err) {\n                    return callback(_geo4.default.create(err), null);\n                }\n                if (!response) {\n                    err = new _geo4.default(_geo4.default.Code.INVALID_RESPONSE);\n                    return callback(err, null);\n                }\n                if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) === 'object') response.timestamp = _utils2.default.time();\n                callback(null, response);\n            });\n        }\n\n        /**\n         *  Ensures Google Maps API is loaded. If not, this will load all of the\n         *  main Javascript objects and symbols for use in the Maps API.\n         *\n         *  Note that, Google Maps API is loaded only when needed. For example,\n         *  the DistanceMatrix API does not support Web Service requests and\n         *  requires this API to be loaded. However, the TimeZone API requests are\n         *  made throught the Web Service without requiring a `google` object\n         *  within DOM.\n         *\n         *  Also note that this will not re-load the API if `google.maps` object\n         *  already exists. In this case, the `callback` is still executed and\n         *  no errors are passed.\n         *\n         *  You can use the following overload to omit the `key` argument altogether:\n         *\n         *  `geolocator.ensureGoogleLoaded(callback)`\n         *\n         *  @param {String} [key]\n         *         Google API key.\n         *  @param {Function} callback\n         *         Callback function to be executed when the operation ends.\n         *\n         *  @returns {void}\n         *\n         *  @example\n         *  geolocator.ensureGoogleLoaded(function (err) {\n         *      if (err) return;\n         *      console.log('google' in window); // true\n         *  });\n         */\n\n    }, {\n        key: 'ensureGoogleLoaded',\n        value: function ensureGoogleLoaded(key, callback) {\n            var k = void 0;\n            if (_utils2.default.isFunction(key)) {\n                callback = key;\n            } else {\n                k = key;\n            }\n            if (!geolocator.isGoogleLoaded()) {\n                var jsonpOpts = {\n                    url: _enums2.default.URL.GOOGLE_MAPS_API,\n                    async: true,\n                    callbackParam: 'callback',\n                    params: {\n                        key: k || ''\n                        // callback: ''\n                    },\n                    rootName: 'geolocator._.cb'\n                };\n                return _fetch2.default.jsonp(jsonpOpts, callback);\n            }\n            callback();\n        }\n\n        /**\n         *  Checks whether the Google Maps API is loaded.\n         *\n         *  @returns {Boolean} - Returns `true` if already loaded.\n         */\n\n    }, {\n        key: 'isGoogleLoaded',\n        value: function isGoogleLoaded() {\n            return 'google' in window && google.maps;\n        }\n\n        /**\n         *  Checks whether the type of the given object is an HTML5 `PositionError`.\n         *\n         *  @param {*} obj - Object to be checked.\n         *  @return {Boolean}\n         */\n\n    }, {\n        key: 'isPositionError',\n        value: function isPositionError(obj) {\n            return _utils2.default.isPositionError(obj);\n        }\n\n        /**\n         *  Checks whether the given value is an instance of `GeoError`.\n         *\n         *  @param {*} obj - Object to be checked.\n         *  @return {Boolean}\n         */\n\n    }, {\n        key: 'isGeoError',\n        value: function isGeoError(obj) {\n            return _geo4.default.isGeoError(obj);\n        }\n\n        /**\n         *  Checks whether HTML5 Geolocation API is supported.\n         *\n         *  @return {Boolean}\n         */\n\n    }, {\n        key: 'isGeolocationSupported',\n        value: function isGeolocationSupported() {\n            return navigator && 'geolocation' in navigator;\n        }\n\n        /**\n         *  Converts kilometers to miles.\n         *\n         *  @param {Number} km - Kilometers to be converted.\n         *  @returns {Number} - Miles.\n         */\n\n    }, {\n        key: 'kmToMi',\n        value: function kmToMi(km) {\n            return km * 0.621371;\n        }\n\n        /**\n         *  Converts miles to kilometers.\n         *\n         *  @param {Number} mi - Miles to be converted.\n         *  @returns {Number} - Kilometers.\n         */\n\n    }, {\n        key: 'miToKm',\n        value: function miToKm(mi) {\n            return mi / 0.621371;\n        }\n\n        /**\n         *  Converts degrees to radians.\n         *\n         *  @param {Number} deg - Degrees to be converted.\n         *  @returns {Number} - Radians.\n         */\n\n    }, {\n        key: 'degToRad',\n        value: function degToRad(degrees) {\n            return degrees * (Math.PI / 180);\n        }\n\n        /**\n         *  Converts radians to degrees.\n         *\n         *  @param {Number} rad - Radians to be converted.\n         *  @returns {Number} - Degrees.\n         */\n\n    }, {\n        key: 'radToDeg',\n        value: function radToDeg(radians) {\n            return radians * (180 / Math.PI);\n        }\n\n        /**\n         *  Converts decimal coordinates (either lat or lng) to degrees, minutes, seconds.\n         *\n         *  @param {Number} dec\n         *         Decimals to be converted.\n         *  @param {Boolean} [isLng=false]\n         *         Indicates whether the given decimals is longitude.\n         *\n         *  @returns {String} - Degrees, minutes, seconds.\n         */\n\n    }, {\n        key: 'decToDegMinSec',\n        value: function decToDegMinSec(dec) {\n            var isLng = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            // Degrees Latitude must be in the range of -90. to 90.\n            // Degrees Longitude must be in the range of -180 to 180.\n            // +Latitude is North, -Latitude is South\n            // +Longitude is East, -Longitude is West\n            var sign = dec < 0 ? -1 : 1,\n                sn = dec < 0 ? 'S' : 'N',\n                we = dec < 0 ? 'W' : 'E',\n                nsew = !isLng ? sn : we,\n                absValue = Math.abs(Math.round(dec * 1000000.0));\n            return Math.floor(absValue / 1000000) * sign + '° ' + Math.floor((absValue / 1000000 - Math.floor(absValue / 1000000)) * 60) + '\\' ' + Math.floor(((absValue / 1000000 - Math.floor(absValue / 1000000)) * 60 - Math.floor((absValue / 1000000 - Math.floor(absValue / 1000000)) * 60)) * 100000) * 60 / 100000 + '\" ' + nsew;\n        }\n    }, {\n        key: 'Error',\n\n\n        // ---------------------------\n        // PROPERTIES\n        // ---------------------------\n\n        /**\n         *  Geolocator Error class that provides a common type of error object for\n         *  the various APIs implemented in Geolocator. All callbacks of Geolocator\n         *  will include an instance of this object as the first argument; if the\n         *  corresponding operation fails. Also all thrown errors will be an instance\n         *  of this object.\n         *\n         *  This object also enumerates\n         *  {@link ?api=geolocator-error#GeoError.Code|Geolocator Error codes}.\n         *\n         *  @see {@link ?api=geolocator-error|`GeoError` documentation}\n         *  @type {GeoError}\n         *  @readonly\n         */\n        get: function get() {\n            return _geo4.default;\n        }\n\n        /**\n         *  Documented separately in enums.js\n         *  @private\n         */\n\n    }, {\n        key: 'MapTypeId',\n        get: function get() {\n            return _enums2.default.MapTypeId;\n        }\n\n        /**\n         *  Documented separately in enums.js\n         *  @private\n         */\n\n    }, {\n        key: 'LocationType',\n        get: function get() {\n            return _enums2.default.LocationType;\n        }\n\n        /**\n         *  Documented separately in enums.js\n         *  @private\n         */\n\n    }, {\n        key: 'TravelMode',\n        get: function get() {\n            return _enums2.default.TravelMode;\n        }\n\n        /**\n         *  Documented separately in enums.js\n         *  @private\n         */\n\n    }, {\n        key: 'UnitSystem',\n        get: function get() {\n            return _enums2.default.UnitSystem;\n        }\n\n        /**\n         *  Documented separately in enums.js\n         *  @private\n         */\n\n    }, {\n        key: 'RadioType',\n        get: function get() {\n            return _enums2.default.RadioType;\n        }\n\n        /**\n         *  Documented separately in enums.js\n         *  @private\n         */\n\n    }, {\n        key: 'DistanceFormula',\n        get: function get() {\n            return _enums2.default.DistanceFormula;\n        }\n\n        /**\n         *  Documented separately in enums.js\n         *  @private\n         */\n\n    }, {\n        key: 'ImageFormat',\n        get: function get() {\n            return _enums2.default.ImageFormat;\n        }\n    }]);\n\n    return geolocator;\n}();\n\n// ---------------------------\n// HELPER METHODS\n// ---------------------------\n\n/**\n *  Used with distance matrix calls.\n *  @private\n */\n\n\nfunction invalidOriginOrDest(value) {\n    return !_utils2.default.isString(value) && !_utils2.default.isArray(value) && !_utils2.default.isPlainObject(value);\n}\n\n/**\n *  Check if XHR response is an error response and returns a `GeoError`.\n *  If not, returns the parsed response.\n *  @private\n *\n *  @param {Error} err\n *         XHR error.\n *  @param {Object} xhr\n *         XHR object to be checked.\n *\n *  @returns {GeoError|Object}\n */\nfunction getXHRResponse(err, xhr) {\n    if (err) return _geo4.default.create(err);\n    if (!xhr) return new _geo4.default(_geo4.default.Code.REQUEST_FAILED);\n    var response = _utils2.default.safeJsonParse(xhr.responseText);\n    // Check if XHR response is an error response.\n    // return response if not.\n    return _geo4.default.fromResponse(response) || response;\n}\n\n/**\n *  Checks the given options and determines if Google key is required.\n *  Throws if key is required but not set or valid.\n *  @private\n *\n *  @param {Object} [options]\n *         Options to be checked. If `undefined`, directly checks Googke key.\n */\nfunction checkGoogleKey(options) {\n    if (!options || options.addressLookup || options.timezone || options.map || options.staticMap) {\n        if (!geolocator._.config.google.key) {\n            throw new _geo4.default(_geo4.default.Code.GOOGLE_KEY_INVALID, 'A Google API key is required but it\\'s not set or valid.');\n        }\n    }\n}\n\n/**\n *  Checks and adds necessary properties to map options from the given location\n *  result object. This is used with methods that support `map` option; to\n *  create a map from the result coordinates; such as locate() method.\n *  @private\n *\n *  @param {Object|String} options\n *         Original options object.\n *  @param {Object} location\n *         Location result object.\n *\n *  @returns {Object} - Final map options object.\n */\nfunction getMapOpts(mapOptions, location) {\n    if (_utils2.default.isObject(mapOptions)) {\n        mapOptions.center = location.coords;\n    } else {\n        mapOptions = {\n            element: mapOptions,\n            center: location.coords\n        };\n    }\n    // this will enable infoWindow\n    if (location.formattedAddress) {\n        mapOptions.title = location.formattedAddress;\n    }\n    // if location has accuracy, (and zoom is not set) we can zoom in a bit more\n    if (!mapOptions.zoom && location.coords && _utils2.default.isNumber(location.coords.accuracy) && location.coords.accuracy < 1500) {\n        mapOptions.zoom = 15;\n    }\n    return mapOptions;\n}\n\n/**\n *  Checks the HTMLElement to see whether a previous map and related objects\n *  (marker, infoWindow) are created for it; by checking our private property\n *  `_geolocatorMapData`. If there is a map, this does not re-create it (which\n *  will break the map) but only re-adjust center, zoom and re-create the marker\n *  if needed. We use this approach bec. Google maps has no feature to destroy\n *  a map. This is considered a bug by Google developers.\n *  @private\n *\n *  @param {Object} options\n *         Options for creating a map.\n */\nfunction configCreateMap(options) {\n    var elem = options.element,\n\n    // when geolocator creates a map, it will set a `_geolocatorMapData`\n    // property on the element. So we can use this map instance later,\n    // when the same HTMLElement is passed to create a map. So check if\n    // we have it here.\n    mapData = elem._geolocatorMapData,\n        map = mapData && mapData.instance || null,\n        marker = mapData && mapData.marker || null,\n        infoWindow = mapData && mapData.infoWindow || null,\n        center = new google.maps.LatLng(options.center.latitude, options.center.longitude),\n        mapOptions = {\n        mapTypeId: options.mapTypeId,\n        center: center,\n        zoom: options.zoom,\n        styles: options.styles || null\n    };\n\n    // if we have a map, we'll just configure it. otherwise, we'll create\n    // one.\n    if (map) {\n        map.setOptions(mapOptions);\n    } else {\n        map = new google.maps.Map(options.element, mapOptions);\n    }\n\n    // destroy marker and infoWindow if previously created for this element.\n    if (infoWindow) infoWindow = null;\n    if (marker && marker instanceof google.maps.Marker) {\n        google.maps.event.clearInstanceListeners(marker);\n        marker.setMap(null);\n        marker = null;\n    }\n\n    // check the new options to see if we need to re-create a marker for\n    // this.\n    if (options.marker) {\n        marker = new google.maps.Marker({\n            position: mapOptions.center,\n            map: map\n        });\n        if (options.title) {\n            infoWindow = new google.maps.InfoWindow();\n            infoWindow.setContent(options.title);\n            // infoWindow.open(map, marker);\n            google.maps.event.addListener(marker, 'click', function () {\n                infoWindow.open(map, marker);\n            });\n        }\n    }\n\n    mapData = {\n        element: elem,\n        instance: map,\n        marker: marker,\n        infoWindow: infoWindow,\n        options: mapOptions\n    };\n    // set the reference on the element for later use, if needed.\n    elem._geolocatorMapData = mapData;\n    return mapData;\n}\n\n/**\n *  Sets the `flag` and `staticMap` (if enabled) property of the given location.\n *  @private\n *\n *  @param {Object} location - Fetched location result.\n *  @param {Object} options - initial options.\n */\nfunction setLocationURLs(location, options) {\n    if (!location || !location.address) return;\n    var cc = void 0,\n        address = location.address;\n    if (_utils2.default.isString(address.countryCode) && address.countryCode.length === 2) {\n        cc = address.countryCode;\n    } else if (_utils2.default.isString(address.country) && address.country.length === 2) {\n        cc = address.country;\n    }\n    if (!cc) return;\n    location.flag = _enums2.default.URL.FLAG + cc.toLowerCase() + '.svg';\n    if (options.staticMap) {\n        var opts = _utils2.default.isPlainObject(options.staticMap) ? _utils2.default.clone(options.staticMap) : {};\n        opts.center = location.coords;\n        location.staticMap = geolocator.getStaticMap(opts);\n    }\n}\n\n/**\n *  Nests `createMap` callback within the given callback.\n *  @private\n *\n *  @param {Object} options\n *         Method options.\n *  @param {Function} callback\n *         Parent callback.\n *\n *  @returns {Function} - Nested callback.\n */\nfunction callbackMap(options, callback) {\n    return function cb(err, location) {\n        if (err) return callback(_geo4.default.create(err), null);\n        setLocationURLs(location, options);\n        if (!options.map) return callback(null, location);\n        options.map = getMapOpts(options.map, location);\n        geolocator.createMap(options.map, function (error, map) {\n            if (error) return callback(error, null);\n            location.map = map;\n            return callback(null, location);\n        });\n    };\n}\n\n/**\n *  Sends a geocode or reverse-geocode request with the given options.\n *  @private\n *\n *  @param {Boolean} reverse\n *         Whether to send reverse-geocode request.\n *  @param {Object} options\n *         Geocode options.\n *  @param {Function} callback\n *         Callback to be nested and executed with map callback.\n */\nfunction _geocode(reverse, options, callback) {\n    checkGoogleKey();\n    _geo2.default.geocode(reverse, geolocator._.config, options, callbackMap(options, callback));\n}\n\n/**\n *  Runs both an address and a timezone look-up for the given location.\n *  @private\n *\n *  @param {Object} location\n *         Location object.\n *  @param {Object} options\n *         Method options.\n *  @param {Function} callback\n *         Parent callback.\n */\nfunction fetchAddressAndTimezone(location, options, callback) {\n    var loc = _utils2.default.clone(location, { own: false });\n    if (!options.addressLookup && !options.timezone) {\n        return callback(null, loc);\n    }\n    function getTZ(cb) {\n        geolocator.getTimeZone(loc.coords, function (err, timezone) {\n            if (err) {\n                return cb(err, null);\n            }\n            delete timezone.timestamp;\n            loc.timezone = timezone;\n            loc.timestamp = _utils2.default.time(); // update timestamp\n            cb(null, loc);\n        });\n    }\n    if (options.addressLookup) {\n        geolocator.reverseGeocode(loc.coords, function (err, result) {\n            if (err) return callback(err, null);\n            loc = _utils2.default.extend({}, result, loc);\n            loc.address = result.address;\n            loc.timestamp = _utils2.default.time(); // update timestamp\n            if (!options.timezone) {\n                callback(err, loc);\n            } else {\n                getTZ(callback);\n            }\n        });\n    } else if (options.timezone) {\n        getTZ(callback);\n    } else {\n        callback(null, loc);\n    }\n}\n\n/**\n *  Gets the position with better accuracy.\n *  See https://github.com/gwilson/getAccurateCurrentPosition#background\n *  @private\n *\n *  @param {Object} options\n *         Locate options.\n *  @param {Function} onPositionReceived\n *         Success callback.\n *  @param {Function} onPositionError\n *         Error callback.\n */\nfunction locateAccurate(options, onPositionReceived, onPositionError) {\n    var loc = void 0,\n        watcher = void 0,\n        onProgress = !_utils2.default.isFunction(options.onProgress) ? _utils2.default.noop : options.onProgress;\n\n    function complete() {\n        if (!loc) {\n            onPositionError(new _geo4.default(_geo4.default.Code.POSITION_UNAVAILABLE));\n        } else {\n            onPositionReceived(loc);\n        }\n    }\n\n    watcher = geolocator.watch(options, function (err, location) {\n        if (err) {\n            return watcher.clear(function () {\n                onPositionError(err);\n            });\n        }\n        loc = location;\n        // ignore the first event if not the only result; for more accuracy.\n        if (watcher.cycle > 1 && loc.coords.accuracy <= options.desiredAccuracy) {\n            watcher.clear(complete);\n        } else {\n            onProgress(loc);\n        }\n    });\n    watcher.clear(options.maximumWait + 100, complete);\n}\n\nfunction getStyles(options) {\n    var conf = geolocator._.config;\n    return !_utils2.default.isFilledArray(options.styles) ? _utils2.default.isFilledArray(conf.google.styles) ? conf.google.styles : null : options.styles;\n}\n\n// ---------------------------\n// INITIALIZE\n// ---------------------------\n\n/**\n *  @private\n *  @type {Object}\n */\ngeolocator._ = {\n    config: _utils2.default.extend({}, defaultConfig),\n    // Storage for global callbacks.\n    cb: {}\n};\n\n// setting default Geo-IP source, FreeGeoIP\ngeolocator.setGeoIPSource({\n    provider: 'freegeoip',\n    url: 'https://freegeoip.net/json',\n    callbackParam: 'callback',\n    schema: {\n        ip: 'ip',\n        coords: {\n            latitude: 'latitude',\n            longitude: 'longitude'\n        },\n        address: {\n            city: 'city',\n            state: 'region_name',\n            stateCode: 'region_code',\n            postalCode: 'zip_code',\n            countryCode: 'country_code',\n            country: 'country_name',\n            region: 'region_name'\n        },\n        timezone: {\n            id: 'time_zone'\n        }\n    }\n});\n\n// ---------------------------\n// EXPORT\n// ---------------------------\n\nexports.default = geolocator;\n\n// ---------------------------\n// ADDITIONAL DOCUMENTATION\n// ---------------------------\n\n/**\n *  `Coordinates` inner type that specifies the geographic position of the\n *  device. The position is expressed as a set of geographic coordinates\n *  together with information about heading and speed.\n *\n *  This is generally returned as part of the\n *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n *\n *  @typedef geolocator~Coordinates\n *  @type Object\n *\n *  @property {Number} latitude\n *         Specifies the latitude estimate in decimal degrees. The value\n *         range is [-90.00, +90.00].\n *  @property {Number} longitude\n *         Specifies the longitude estimate in decimal degrees. The value\n *         range is [-180.00, +180.00].\n *  @property {Number} altitude\n *         Specifies the altitude estimate in meters above the WGS 84\n *         ellipsoid.\n *  @property {Number} accuracy\n *         Specifies the accuracy of the latitude and longitude estimates in\n *         meters.\n *  @property {Number} altitudeAccuracy\n *         Specifies the accuracy of the altitude estimate in meters.\n *  @property {Number} heading\n *         Specifies the device's current direction of movement in degrees\n *         counting clockwise relative to true north.\n *  @property {Number} speed\n *         Specifies the device's current ground speed in meters per second.\n */\n\n/**\n *\t`Address` inner type that specifies the address of the fetched location.\n *\tThe address is expressed as a set of political and locality components.\n *\n *  This is generally returned as part of the\n *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n *\n *  @typedef geolocator~Address\n *  @type Object\n *\n *  @property {String} commonName\n *         Indicates a point of interest, a premise or colloquial area name for\n *         the fetched location, if any.\n *  @property {String} streetNumber\n *         Indicates the precise street number of the fetched location, if any.\n *  @property {String} street\n *         Indicates the street name of the fetched location, if any.\n *  @property {String} route\n *         Indicates the route name of the fetched location, if any.\n *  @property {String} neighborhood\n *         Indicates the neighborhood name of the fetched location, if any.\n *  @property {String} town\n *         Indictes the town of the fetched location, if any.\n *  @property {String} city\n *         Indicates the city of the fetched location.\n *  @property {String} region\n *         Indicates the political region name of the fetched location, if any.\n *  @property {String} postalCode\n *         Indicates the postal code of the fetched location, if any.\n *  @property {String} state\n *         Indicates the state of the fetched location, if any.\n *  @property {String} stateCode\n *         Indicates the state code of the fetched location, if any.\n *  @property {String} country\n *         Indicates the national political entity of the fetched location.\n *  @property {String} countryCode\n *         Indicates the ISO alpha-2 country code of the fetched location.\n */\n\n/**\n *\t`TimeZone` inner type that specifies time offset data for the fetched\n *\tlocation on the surface of the earth.\n *\n *  This is generally returned as part of the\n *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n *\n *  @typedef geolocator~TimeZone\n *  @type Object\n *\n *  @property {String} id\n *         The ID of the time zone, such as `\"America/Los_Angeles\"` or\n *         `\"Australia/Sydney\"`. These IDs are defined in the\n *         {@link http://www.iana.org/time-zones|IANA Time Zone Database},\n *         which is also available in searchable format in Wikipedia's\n *         {@link http://en.wikipedia.org/wiki/List_of_tz_database_time_zones|List of tz database time zones}.\n *  @property {String} name\n *         The long form name of the time zone. This field will be localized if\n *         the Geolocator `language` is configured. e.g. `\"Pacific Daylight Time\"`\n *         or `\"Australian Eastern Daylight Time\"`.\n *  @property {String} abbr\n *         The abbreviation of the time zone.\n *  @property {Number} dstOffset\n *         The offset for daylight-savings time in seconds. This will be zero\n *         if the time zone is not in Daylight Savings Time during the specified\n *         timestamp.\n *  @property {Number} rawOffset\n *         The offset from UTC (in seconds) for the given location. This does\n *         not take into effect daylight savings.\n */\n\n/**\n *\t`MapData` inner type that provides references to the components of a\n *\tcreated Google Maps `Map` and the containing DOM element.\n *\n *  This is generally returned as part of the\n *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n *\n *  @typedef geolocator~MapData\n *  @type Object\n *\n *  @property {HTMLElement} element\n *         DOM element which a (Google) map is created within.\n *  @property {google.maps.Map} instance\n *         Instance of a Google Maps `Map` object.\n *  @property {google.maps.Marker} marker\n *         Instance of a Google Maps `Marker` object, if any.\n *  @property {google.maps.InfoWindow} infoWindow\n *         Instance of a Google Maps `InfoWindow` object, if any.\n *  @property {Object} options\n *         Arbitrary object of applied map options.\n */\n\n/**\n *\t`Location` inner type that specifies geographic coordinates, address and\n *\ttime zone information for the fetched location.\n *\n *  This result object is passed to the callbacks of the corresponding\n *  asynchronous Geolocator methods (such as `.locate()` method), as the second\n *  argument. The contents of this object will differ for various  Geolocator\n *  methods, depending on the configured method options.\n *\n *  @typedef geolocator~Location\n *  @type Object\n *\n *  @property {Coordinates} coords\n *         Specifies the geographic location of the device. The location is\n *         expressed as a set of geographic coordinates together with\n *         information about heading and speed.\n *         See {@link #geolocator~Coordinates|`geolocator~Coordinates` type}\n *         for details.\n *  @property {Address} address\n *         Specifies the address of the fetched location. The address is\n *         expressed as a set of political and locality components.\n *         This property might be `undefined` if `addressLookup` option is not\n *         enabled for the corresponding method.\n *         See {@link #geolocator~Address|`geolocator~Address` type}\n *         for details.\n *  @property {String} formattedAddress\n *         The human-readable address of this location. Often this address is\n *         equivalent to the \"postal address,\" which sometimes differs from\n *         country to country.\n *  @property {Boolean} targetReached\n *         Specifies whether the defined target coordinates is reached.\n *         This property is only available for\n *         {@link #geolocator.watch|`geolocator.watch()`} method when `target`\n *         option is defined.\n *  @property {String} type\n *         Type of the location. See\n *         {@link #geolcoator.LocationType|`geolcoator.LocationType` enumeration}\n *         for details.\n *  @property {String} placeId\n *         A unique identifier that can be used with other Google APIs.\n *  @property {String} flag\n *         URL of the country flag image, in SVG format. This property exists\n *         only if address information is available.\n *  @property {TimeZone} timezone\n *         Specifies time offset data for the fetched location on the surface of\n *         the earth. See {@link #geolocator~TimeZone|`geolocator~TimeZone` type}\n *         for details.\n *  @property {MapData} map\n *         Provides references to the components of a created Google Maps `Map`\n *         and the containing DOM element. See\n *         {@link #geolocator~MapData|`geolocator~MapData` type} for details.\n *  @property {String} staticMap\n *         URL of a static Google map image, for the location.\n *  @property {Number} timestamp\n *         Specifies the time when the location information was retrieved and\n *         the `Location` object created.\n */\n\n/**\n *  `MapOptions` inner type that specifies options for the map to be created.\n *\n *  @typedef geolocator~MapOptions\n *  @type Object\n *\n *  @property {String|HTMLElement|Map} element\n *         Either the ID of a DOM element or the element itself;\n *         which the map will be created within; or a previously created\n *         `google.maps.Map` instance. If a map instance is set, this\n *         only will apply the options without re-creating it.\n *  @property {Object} center\n *         Center coordinates for the map to be created.\n *      @property {Number} center.latitude\n *             Latitude of the center point coordinates.\n *      @property {Number} center.longitude\n *             Longitude of the center point coordinates.\n *  @property {String} mapTypeId\n *         Type of the map to be created.\n *         See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n *         for possible values.\n *  @property {String} title\n *         Title text to be displayed within an `InfoWindow`, when the\n *         marker is clicked. This only take effect if `marker` is\n *         enabled.\n *  @property {Boolean} marker\n *         Whether to place a marker at the given coordinates.\n *         If `title` is set, an `InfoWindow` will be opened when the\n *         marker is clicked.\n *  @property {Number} zoom\n *             Zoom level to be set for the map.\n */\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _fetch = __webpack_require__(3);\n\nvar _fetch2 = _interopRequireDefault(_fetch);\n\nvar _enums = __webpack_require__(1);\n\nvar _enums2 = _interopRequireDefault(_enums);\n\nvar _geo = __webpack_require__(2);\n\nvar _geo2 = _interopRequireDefault(_geo);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n *  Helper methods.\n *\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n *  @type {Object}\n *  @private\n */\nvar geoHelper = {\n    toGoogleCoords: function toGoogleCoords(coords) {\n        return {\n            lat: coords.lat || coords.latitude,\n            lng: coords.lng || coords.longitude\n        };\n    },\n    fromGoogleCoords: function fromGoogleCoords(coords) {\n        return {\n            latitude: coords.latitude || coords.lat,\n            longitude: coords.longitude || coords.lng\n        };\n    },\n\n\n    // used for distance matrix origins and destinations\n    toPointList: function toPointList(arr) {\n        arr = _utils2.default.isArray(arr) ? arr : [arr];\n        return arr.map(function (o) {\n            return _utils2.default.isString(o) ? o : geoHelper.toGoogleCoords(o);\n        });\n    },\n    getGeocodeComps: function getGeocodeComps(comp) {\n        return {\n            route: comp.route,\n            locality: comp.locality,\n            administrative_area: comp.administrativeArea, // eslint-disable-line camelcase\n            postal_code: comp.postalCode, // eslint-disable-line camelcase\n            country: comp.country,\n            region: comp.region\n        };\n    },\n\n\n    // Geocode examples:\n    // address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&key=API_KEY\n    // address=Winnetka&bounds=34.172684,-118.604794|34.236144,-118.500938&key=API_KEY\n    // address=santa+cruz&components=country:ES&key=API_KEY\n    // components=administrative_area:TX|country:US&key=API_KEY\n    // Reverse Geocode examples:\n    // latlng=40.714224,-73.961452&key=API_KEY\n    // place_id=ChIJd8BlQ2BZwokRAFUEcm_qrcA&key=API_KEY\n    buildGeocodeParams: function buildGeocodeParams(options, reverse) {\n        var params = [],\n            e = _utils2.default.encodeURI;\n\n        if (reverse) {\n            if (options.placeId) {\n                params.push('place_id=' + options.placeId);\n            } else if (options.latitude && options.longitude) {\n                params.push('latlng=' + options.latitude + ',' + options.longitude);\n            }\n        } else {\n            if (options.address) {\n                params.push('address=' + e(options.address));\n            }\n\n            var geoComps = geoHelper.getGeocodeComps(options);\n            geoComps = _utils2.default.params(geoComps, { operator: ':', separator: '|' });\n            params.push('components=' + geoComps);\n\n            var b = options.bounds;\n            if (_utils2.default.isArray(b) && b.length === 4) {\n                params.push('bounds=' + b[0] + ',' + b[1] + '|' + b[2] + ',' + b[3]);\n            } else if (_utils2.default.isPlainObject(b) && Object.keys(b).length === 4) {\n                params.push('bounds=' + b.southwestLat + ',' + b.southwestLng + '|' + b.northeastLat + ',' + b.northeastLng);\n            }\n        }\n\n        params.push('language=' + options.language);\n        params.push('key=' + options.key);\n        return params.join('&');\n    },\n\n\n    // See https://developers.google.com/maps/documentation/geocoding/intro\n    formatGeocodeResults: function formatGeocodeResults(results) {\n        if (!_utils2.default.isArray(results) || results.length <= 0) {\n            return {\n                location: null,\n                address: null,\n                formattedAddress: '',\n                type: null, // locationType\n                placeId: ''\n            };\n        }\n\n        var i = void 0,\n            c = void 0,\n            o = {},\n            data = results[0],\n            comps = data.address_components;\n\n        for (i = 0; i < comps.length; i += 1) {\n            c = comps[i];\n            if (c.types && c.types.length > 0) {\n                o[c.types[0]] = c.long_name;\n                o[c.types[0] + '_s'] = c.short_name;\n            }\n        }\n\n        var geometry = data.geometry;\n        return {\n            coords: geometry && geometry.location ? {\n                latitude: geometry.location.lat,\n                longitude: geometry.location.lng\n            } : null,\n            address: {\n                commonName: o.point_of_interest || o.premise || o.subpremise || o.colloquial_area || '',\n                streetNumber: o.street_number || '',\n                street: o.administrative_area_level_4 || o.administrative_area_level_3 || o.route || '',\n                route: o.route || '',\n                neighborhood: o.neighborhood || o.administrative_area_level_5 || o.administrative_area_level_4 || '',\n                town: o.sublocality || o.administrative_area_level_2 || '',\n                city: o.locality || o.administrative_area_level_1 || '',\n                region: o.administrative_area_level_2 || o.administrative_area_level_1 || '',\n                postalCode: o.postal_code || '',\n                state: o.administrative_area_level_1 || '',\n                stateCode: o.administrative_area_level_1_s || '',\n                country: o.country || '',\n                countryCode: o.country_s || ''\n            },\n            formattedAddress: data.formatted_address,\n            type: geometry.location_type || '',\n            placeId: data.place_id,\n            timestamp: _utils2.default.time()\n        };\n    },\n    geocode: function geocode(reverse, conf, options, callback) {\n        var opts = {};\n        if (_utils2.default.isString(options)) {\n            opts = {};\n            var prop = reverse ? 'placeId' : 'address';\n            opts[prop] = options;\n        } else if (_utils2.default.isPlainObject(options)) {\n            opts = options;\n        } else {\n            throw new _geo2.default(_geo2.default.Code.INVALID_PARAMETERS);\n        }\n\n        if (reverse) {\n            var coordsSet = _utils2.default.isNumber(options.latitude) && _utils2.default.isNumber(options.longitude);\n            if (!_utils2.default.isString(options.placeId) && !coordsSet) {\n                throw new _geo2.default(_geo2.default.Code.INVALID_PARAMETERS);\n            }\n        }\n\n        opts = _utils2.default.extend({\n            key: conf.google.key || '',\n            language: conf.language || 'en',\n            raw: false\n        }, opts);\n\n        var query = geoHelper.buildGeocodeParams(opts, reverse),\n            url = _utils2.default.setProtocol(_enums2.default.URL.GOOGLE_GEOCODE, conf.https),\n            xhrOpts = {\n            url: url + '?' + query\n        };\n\n        _fetch2.default.xhr(xhrOpts, function (err, xhr) {\n            if (err) return callback(_geo2.default.create(err), null);\n\n            var response = _utils2.default.safeJsonParse(xhr.responseText),\n                gErr = _geo2.default.fromResponse(response);\n\n            if (gErr) return callback(gErr, null);\n\n            response = options.raw ? response : geoHelper.formatGeocodeResults(response.results);\n            callback(null, response);\n        });\n    },\n\n\n    // See https://developers.google.com/maps/documentation/distance-matrix/intro\n    // Raw Result Example:\n    // {\n    //    \"destination_addresses\" : [ \"San Francisco, CA, USA\", \"Victoria, BC, Canada\" ],\n    //    \"origin_addresses\" : [ \"Vancouver, BC, Canada\", \"Seattle, WA, USA\" ],\n    //    \"rows\" : [\n    //       {\n    //          \"elements\" : [\n    //             {\n    //                \"distance\" : { \"text\" : \"1,704 km\", \"value\" : 1704324 },\n    //                \"duration\" : { \"text\" : \"3 days 19 hours\", \"value\" : 327061\n    //                },\n    //                \"status\" : \"OK\"\n    //             },\n    //             {\n    //                \"distance\" : { \"text\" : \"138 km\", \"value\" : 138295 },\n    //                \"duration\" : { \"text\" : \"6 hours 44 mins\", \"value\" : 24236 },\n    //                \"status\" : \"OK\"\n    //             }\n    //          ]\n    //       },\n    //       {\n    //          \"elements\" : [\n    //             {\n    //                \"distance\" : { \"text\" : \"1,452 km\", \"value\" : 1451623 },\n    //                \"duration\" : { \"text\" : \"3 days 4 hours\", \"value\" : 275062 },\n    //                \"status\" : \"OK\"\n    //             },\n    //             {\n    //                \"distance\" : { \"text\" : \"146 km\", \"value\" : 146496 },\n    //                \"duration\" : { \"text\" : \"2 hours 52 mins\", \"value\" : 10324 },\n    //                \"status\" : \"OK\"\n    //             }\n    //          ]\n    //       }\n    //    ],\n    //    \"status\" : \"OK\"\n    // }\n    // Formatted to:\n\n    formatDistanceResults: function formatDistanceResults(results) {\n        if (!_utils2.default.isPlainObject(results)) {\n            return null;\n        }\n\n        var arr = [],\n            origins = results.originAddresses,\n            dests = results.destinationAddresses,\n            rows = results.rows;\n\n        // [\n        //     {\n        //          from: 'Vancouver, BC, Canada',\n        //          to: 'San Francisco, CA, USA',\n        //          distance: { value: 1704107, text: \"1,704 km\" },\n        //          duration: { value: 327025, text: \"3 days 19 hours\" },\n        //          fare: { currency: \"USD\", value: 6, text: \"$6.00\" }\n        //     },\n        //     ...\n        // ]\n\n        var e = void 0;\n        origins.forEach(function (origin, oIndex) {\n            dests.forEach(function (dest, dIndex) {\n                e = rows[oIndex].elements[dIndex];\n                arr.push({\n                    from: origin,\n                    to: dest,\n                    distance: e.distance,\n                    duration: e.duration,\n                    fare: e.fare,\n                    timestamp: _utils2.default.time()\n                });\n            });\n        });\n\n        return arr;\n    },\n\n\n    // Converts a map-styles object in to static map styles (formatted query-string params).\n    // See https://developers.google.com/maps/documentation/static-maps/styling\n    mapStylesToParams: function mapStylesToParams(styles) {\n        if (!styles) return '';\n        if (!_utils2.default.isArray(styles)) styles = [styles];\n        var result = [];\n        styles.forEach(function (v, i, a) {\n            var style = '';\n            if (v.stylers) {\n                // only if there is a styler object\n                if (v.stylers.length > 0) {\n                    // Needs to have a style rule to be valid.\n                    style += (v.hasOwnProperty('featureType') ? 'feature:' + v.featureType : 'feature:all') + '|';\n                    style += (v.hasOwnProperty('elementType') ? 'element:' + v.elementType : 'element:all') + '|';\n                    v.stylers.forEach(function (val, i, a) {\n                        var propName = Object.keys(val)[0],\n                            propVal = val[propName].toString().replace('#', '0x');\n                        style += propName + ':' + propVal + '|';\n                    });\n                }\n            }\n            result.push('style=' + encodeURIComponent(style));\n        });\n        return result.join('&');\n    }\n};\n\nexports.default = geoHelper;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar GeoWatcher = function () {\n    function GeoWatcher(onChange, onError) {\n        var _this = this;\n\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        _classCallCheck(this, GeoWatcher);\n\n        this.isCleared = false;\n        this.cycle = 0;\n        this._timer = null;\n        this.id = navigator.geolocation.watchPosition(function (pos) {\n            _this.cycle++;\n            if (_utils2.default.isFunction(onChange)) onChange(pos);\n        }, function (err) {\n            _this.cycle++;\n            if (_utils2.default.isFunction(onError)) onError(err);\n            if (options.clearOnError) {\n                _this.clear();\n            }\n        }, options);\n    }\n\n    _createClass(GeoWatcher, [{\n        key: '_clear',\n        value: function _clear() {\n            navigator.geolocation.clearWatch(this.id);\n            this.isCleared = true;\n            this._timer = null;\n        }\n    }, {\n        key: 'clear',\n        value: function clear(delay, callback) {\n            var _this2 = this;\n\n            var d = _utils2.default.isNumber(delay) ? delay : 0,\n                cb = _utils2.default.isFunction(callback) ? callback : _utils2.default.isFunction(delay) ? delay : null;\n            // clear any previous timeout\n            if (this._timer) {\n                clearTimeout(this._timer);\n                this._timer = null;\n            }\n            // check if watcher is not cleared\n            if (!this.isCleared) {\n                if (d === 0) {\n                    this._clear();\n                    if (cb) cb();\n                    return;\n                }\n                this._timer = setTimeout(function () {\n                    _this2._clear();\n                    if (cb) cb();\n                }, d);\n            }\n        }\n    }]);\n\n    return GeoWatcher;\n}();\n\n// ---------------------------\n// EXPORT\n// ---------------------------\n\nexports.default = GeoWatcher;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _geolocator = __webpack_require__(4);\n\nvar _geolocator2 = _interopRequireDefault(_geolocator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// See https://github.com/onury/geolocator/issues/42\nif (typeof window !== 'undefined' && typeof window.geolocator === 'undefined') {\n        window.geolocator = _geolocator2.default;\n}\n\n// export default geolocator;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = _geolocator2.default;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// geolocator.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d48e29f068e0ebc407bd","\nlet _toString = Object.prototype.toString;\n\n/**\n * Simple utility methods; internally used within Geolocator core;\n * made publically accessible.\n * @type {Object}\n * @readonly\n *\n * @license MIT\n * @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nconst utils = {\n\n    noop() {},\n\n    // ---------------------------\n    // Validation\n    // ---------------------------\n\n    /**\n     * Checks if the type of the given value is `String`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isString(value) {\n        return typeof value === 'string';\n    },\n\n    isStringSet(value) {\n        return typeof value === 'string' && value.trim().length > 0;\n    },\n\n    /**\n     * Checks if the type of the given value is `Number`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isNumber(value) {\n        return typeof value === 'number';\n    },\n\n    /**\n     * Checks if the type of the given value is an `Object` or `Function`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isObject(value) {\n        let type = typeof value;\n        return Boolean(value) && (type === 'object' || type === 'function');\n    },\n\n    /**\n     * Checks if the type of the given value is `Function`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isFunction(value) {\n        return typeof value === 'function';\n    },\n\n    /**\n     * Checks if the type of the given value is `Array`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isArray(value) {\n        return Boolean(value) && _toString.call(value) === '[object Array]';\n    },\n\n    /**\n     * Checks if the given object is a non-empty `Array`.\n     * @memberof utils\n     *\n     * @param {*} array - Object to be checked.\n     * @returns {Boolean}\n     */\n    isFilledArray(array) {\n        return utils.isArray(array) && array.length > 0;\n    },\n\n    /**\n     * Checks if the given value is a plain `Object`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isPlainObject(value) {\n        return Boolean(value)\n            && typeof value === 'object'\n            && _toString.call(value) === '[object Object]';\n    },\n\n    /**\n     * Checks if the given value is a `Date`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isDate(value) {\n        return Boolean(value) && _toString.call(value) === '[object Date]';\n    },\n\n    /**\n     * Checks if the given object is a DOM element.\n     * @memberof utils\n     *\n     * @param {Object} object - Object to be checked.\n     * @returns {Boolean}\n     */\n    isElement(object) {\n        if (!object) return false;\n        return object instanceof HTMLElement\n            || (typeof object === 'object' && object.nodeType === 1);\n    },\n\n    /**\n     * Checks if the given object is a DOM node.\n     * @memberof utils\n     *\n     * @param {Object} object - Object to be checked.\n     * @returns {Boolean}\n     */\n    isNode(object) {\n        if (!object) return false;\n        return object instanceof Node\n            || (typeof object === 'object' && typeof object.nodeType === 'number');\n    },\n\n    /**\n     * Checks if the given object is a jQuery instance.\n     * This will still return `false` if the jQuery instance has no items.\n     * @memberof utils\n     *\n     * @param {Object} object - Object to be checked.\n     * @returns {Boolean}\n     */\n    isJQueryObject(object) {\n        if (!object) return false;\n        return ('jQuery' in window && object instanceof window.jQuery && Boolean(object[0]));\n            // http://api.jquery.com/jquery-2/\n            // || (typeof object === 'object' && Boolean(object.jquery));\n    },\n\n    /**\n     * Checks if the type of the given value is an HTML5 `PositionError`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isPositionError(value) {\n        return Boolean(value) && _toString.call(value) === '[object PositionError]';\n    },\n\n    /**\n     * Checks if the given value is an instance of `Error` or HTML5 `PositionError`.\n     * @memberof utils\n     *\n     * @param {*} value - Value to be checked.\n     * @returns {Boolean}\n     */\n    isError(value) {\n        return (value instanceof Error) || utils.isPositionError(value);\n    },\n\n    // ---------------------------\n    // String\n    // ---------------------------\n\n    /**\n     * Removes the query string portion from the given URL string.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the rest of the string.\n     */\n    removeQuery(str) {\n        return str.replace(/\\?.*$/, '');\n    },\n\n    /**\n     * Removes the protocol portion from the given URL string.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the rest of the string.\n     */\n    removeProtocol(str) {\n        return str.replace(/^(.*:)?\\/\\//, '');\n    },\n\n    /**\n     * Sets the protocol of the given URL.\n     * @memberof utils\n     *\n     * @param {String} url\n     *        The URL to be modified.\n     * @param {Boolean} [https]\n     *        Specifies whether to set the protocol to HTTPS.\n     *        If omitted, current page protocol will be used.\n     *\n     * @returns {String} - The modified URL string.\n     */\n    setProtocol(url, https) {\n        let p;\n        if (https === undefined || https === null) {\n            p = window.location.protocol;\n        } else {\n            p = https ? 'https:' : 'http:';\n        }\n        url = utils.removeProtocol(url);\n        return `${p}//${url}`;\n    },\n\n    /**\n     * Removes both the leading and trailing dots from the given string.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the rest of the string.\n     */\n    trimDots(str) {\n        return str.replace(/^\\.+?(.*?)\\.+?$/g, '$1');\n    },\n\n    /**\n     * URL-Encodes the given string. Note that the encoding is done Google's\n     * way; that is, spaces are replaced with `+` instead of `%20`.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the encoded string.\n     */\n    encodeURI(str) {\n        return encodeURIComponent(str).replace(/%20/g, '+');\n    },\n\n    /**\n     * URL-Decodes the given string. This is the reverse of `utils.encodeURI()`;\n     * so pluses (`+`) are replaced with spaces.\n     * @memberof utils\n     *\n     * @param {String} str - String to be processed.\n     * @returns {String} - Returns the decoded string.\n     */\n    decodeURI(str) {\n        return decodeURIComponent(str.replace(/\\+/g, '%20'));\n    },\n\n    /**\n     * Converts the given value to string.\n     * `null` and `undefined` converts to empty string.\n     * If value is a function, it's native `toString()` method is used.\n     * Otherwise, value is coerced.\n     * @memberof utils\n     *\n     * @param {*} value - String to be converted.\n     * @returns {String} - Returns the result string.\n     */\n    toString(value) {\n        if (value === null || value === undefined) return '';\n        if (value.toString && utils.isFunction(value.toString)) {\n            return value.toString();\n        }\n        return String(value);\n    },\n\n    /**\n     * Generates a random string with the number of characters.\n     * @memberof utils\n     *\n     * @param {Number} [len=1] - Length of the string.\n     * @returns {String} - Returns a random string.\n     */\n    randomString(len) {\n        if (!len || !utils.isNumber(len)) len = 1;\n        len = -Math.abs(len);\n        return Math.random().toString(36).slice(len);\n    },\n\n    /**\n     * Gets the abbreviation of the given phrase.\n     * @memberof utils\n     *\n     * @param {String} str\n     *        String to abbreviate.\n     * @param {Object} [options]\n     *        Abbreviation options.\n     *     @param {Boolean} [options.upper=true]\n     *            Whether to convert to upper-case.\n     *     @param {Boolean} [options.dots=true]\n     *            Whether to add dots after each abbreviation.\n     *\n     * @returns {String} - Returns the abbreviation of the given phrase.\n     */\n    abbr(str, options) {\n        options = utils.extend({\n            upper: true,\n            dots: true\n        }, options);\n        let d = options.dots ? '.' : '',\n            s = str.match(/(\\b\\w)/gi).join(d) + d;\n        return options.upper ? s.toUpperCase() : s;\n    },\n\n    /**\n     * Builds URI parameters from the given object.\n     * Note: This does not iterate deep objects.\n     * @memberof utils\n     *\n     * @param {Object} obj - Object to be processed.\n     * @param {Object} options - Parameterize options.\n     *     @param {Boolean} [options.encode=true]\n     *            Whether to encode URI components.\n     *     @param {String} [options.operator=\"=\"]\n     *     @param {String} [options.separator=\"&\"]\n     *     @param {Array} [options.include]\n     *            Keys to be included in the output params. If defined,\n     *            `options.exclude` is ignored.\n     *     @param {Array} [options.exclude]\n     *            Keys to be excluded from the output params.\n     *\n     * @returns {String} - URI parameters string.\n     */\n    params(obj, options) {\n        if (!utils.isPlainObject(obj) || Object.keys(obj).length === 0) {\n            return '';\n        }\n\n        options = utils.extend({\n            encode: true,\n            operator: '=',\n            separator: '&',\n            include: undefined,\n            exclude: undefined\n        }, options);\n\n        let params = [],\n            inc = utils.isArray(options.include) ? options.include : null,\n            exc = !inc && utils.isArray(options.exclude) ? options.exclude : null;\n        utils.forIn(obj, (value, key) => {\n            if ((!inc || inc.indexOf(key) >= 0)\n                    && (!exc || exc.indexOf(key) < 0)) {\n                let v = utils.toString(value);\n                v = options.encode ? utils.encodeURI(v) : v;\n                let k = options.encode ? utils.encodeURI(key) : key;\n                params.push(k + options.operator + v);\n            }\n        });\n\n        return params.join(options.separator);\n    },\n\n    /**\n     * Gets the object from the given object notation string.\n     * @private\n     *\n     * @param {String} notation - Object notation.\n     * @returns {*} - Any existing object.\n     */\n    notateGlobalObj(notation) {\n        notation = utils.trimDots(notation);\n        let levels = notation.split('.'),\n            o = window;\n        if (levels[0] === 'window' || levels[0] === 'document') {\n            levels.shift();\n        }\n        levels.forEach(note => {\n            o = o[note];\n        });\n        return o;\n    },\n\n    // ---------------------------\n    // Object\n    // ---------------------------\n\n    /**\n     * Iterates over own properties of an object invoking a callback for each\n     * property.\n     * @memberof utils\n     *\n     * @param {Object} obj\n     *        Object to be processed.\n     * @param {Function} callback\n     *        Callback function with the following signature:\n     *        `function (value, key, object) { ... }`.\n     *        Explicitly returning `false` will exit the iteration early.\n     * @returns {void}\n     */\n    forIn(obj, callback) {\n        let k;\n        for (k in obj) {\n            // if (obj.hasOwnProperty(k)) {} // Do this inside callback if needed.\n            if (callback(obj[k], k, obj) === false) break;\n        }\n    },\n\n    /**\n     * Extends the given object with the specified sources.\n     * Right most source overwrites the previous.\n     * NOTE: This is not a full implementation. Use with caution.\n     * @memberof utils\n     *\n     * @param {Object} destination\n     *        Destionation Object that will be extended and holds the default\n     *        values.\n     * @param {...Object} sources\n     *        Source objects to be merged.\n     *\n     * @returns {Object} - Returns the extended object.\n     */\n    extend(destination, ...sources) {\n        if (!utils.isObject(destination)) return {};\n        let key, value;\n        sources.forEach(source => {\n            for (key in source) { // eslint-disable-line\n                value = source[key];\n                if (utils.isArray(value)) {\n                    destination[key] = value.concat();\n                } else if (utils.isDate(value)) {\n                    destination[key] = new Date(value);\n                } else if (utils.isFunction(value)) { // should be before object\n                    destination[key] = value;\n                } else if (utils.isObject(value)) {\n                    destination[key] = utils.extend({}, value);\n                } else {\n                    destination[key] = value;\n                }\n            }\n        });\n        return destination;\n    },\n\n    /**\n     * Clones the given object.\n     * NOTE: This is not a full implementation. Use with caution.\n     * @memberof utils\n     *\n     * @param {Object} obj\n     *        Target Object to be cloned.\n     * @param {Object|Array} [options]\n     *        Clone options or array of keys to be cloned.\n     *     @param {Array} [options.keys]\n     *            Keys of the properties to be cloned.\n     *     @param {Boolean} [options.own=true]\n     *            Whether to clone own properties only. This is only effective\n     *            if `keys` is not defined.\n     *\n     * @returns {Object} - Returns the cloned object.\n     */\n    clone(obj, options) {\n        if (!obj) return {};\n\n        if (utils.isArray(options)) {\n            options = { keys: options };\n        }\n        options = utils.extend({\n            keys: null,\n            own: true\n        }, options);\n\n        let include,\n            cloned = {};\n\n        utils.forIn(obj, (value, key) => {\n            include = options.keys\n                ? options.keys.indexOf(key) >= 0\n                : (options.own && obj.hasOwnProperty(key)) || !options.own;\n            if (include) {\n                if (utils.isObject(value)) {\n                    cloned[key] = utils.clone(value, options);\n                } else {\n                    cloned[key] = value;\n                }\n            }\n        });\n        return cloned;\n    },\n\n    /**\n     *  Maps the values of the given object to a schema to re-structure a new\n     *  object.\n     *  @memberof utils\n     *\n     *  @param {Object} obj\n     *         Original object to be mapped.\n     *  @param {Object} schema\n     *         Schema to be used to map the object.\n     *\n     *  @returns {Object} - Mapped object.\n     */\n    mapToSchema(obj, schema) {\n        let mapped = {};\n        utils.forIn(schema, (value, key) => {\n            if (utils.isPlainObject(value)) {\n                mapped[key] = utils.mapToSchema(obj, value);\n            } else {\n                mapped[key] = obj[value];\n            }\n        });\n        return mapped;\n    },\n\n    // ---------------------------\n    // Misc\n    // ---------------------------\n\n    /**\n     * Safely parses the given JSON `String` into an `Object`.\n     * The only difference from `JSON.parse()` is that this method does not\n     * throw for invalid input. Instead, returns `null`.\n     * @memberof utils\n     *\n     * @param {String} str - JSON string to be parsed\n     * @returns {Object|null} - Returns the parsed `Object` or `null` if the\n     * input is invalid.\n     */\n    safeJsonParse(str) {\n        let o = null;\n        try {\n            o = JSON.parse(str);\n        } catch (e) {}\n        return o;\n    },\n\n    /**\n     * Gets a timestamp that is seconds or milliseconds since midnight,\n     * January 1, 1970 UTC.\n     * @memberof utils\n     *\n     * @param {Boolean} [seconds=false]\n     *        Specifies whether seconds should be returned instead of\n     *        milliseconds.\n     *\n     * @returns {Number} - Returns seconds or milliseconds since midnight,\n     * January 1, 1970 UTC.\n     */\n    time(seconds) {\n        let ts = Date.now();\n        return seconds ? parseInt(ts / 1000, 10) : ts;\n    }\n\n};\n\nexport default utils;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/utils.js","const GOOGLE_MAPS_API_BASE = '//maps.googleapis.com/maps/api';\n\n/**\n * This file only includes partial documentation about `geolocator` enumerations.\n * Note that these enumerations are mostly an aggregation of\n * {@link https://developers.google.com/maps/documentation/javascript|Google Maps API} constants.\n *\n * @private\n * @readonly\n */\nconst enums = Object.freeze({\n    /**\n     * Enumerates API endpoints used within Geolocator core.\n     *\n     * @enum {String}\n     * @readonly\n     * @private\n     */\n    URL: {\n        /**\n         *  Public IP retrieval (free) service.\n         *  @type {String}\n         *  @private\n         */\n        IP: '//api.ipify.org',\n        /**\n         *  Country SVG flags.\n         *  e.g. <url>/tr.svg for Turkey flag.\n         *  @type {String}\n         *  @private\n         */\n        FLAG: '//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/',\n        /**\n         * Google Maps API bootstrap endpoint that loads all of the main\n         * Javascript objects and symbols for use in the Maps API.\n         * Some Maps API features are also available in self-contained\n         * libraries which are not loaded unless you specifically request them.\n         * See {@link https://developers.google.com/maps/documentation/javascript/libraries|details}.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_MAPS_API: GOOGLE_MAPS_API_BASE + '/js',\n        /**\n         * Google Maps API Static Map endpoint.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_SATATIC_MAP: GOOGLE_MAPS_API_BASE + '/staticmap',\n        /**\n         * Google Geolocation API endpoint.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_GEOLOCATION: '//www.googleapis.com/geolocation/v1/geolocate',\n        /**\n         * Google Geocode API endpoint.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_GEOCODE: '//maps.googleapis.com/maps/api/geocode/json',\n        /**\n         * Google TimeZone API endpoint.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_TIMEZONE: '//maps.googleapis.com/maps/api/timezone/json',\n        /**\n         * Google Distance Matrix API endpoint.\n         * @type {String}\n         * @private\n         */\n        GOOGLE_DISTANCE_MATRIX: '//maps.googleapis.com/maps/api/distancematrix/json'\n    },\n    /**\n     * Enumerates Google map types.\n     * @memberof! geolocator\n     *\n     * @enum {String}\n     * @readonly\n     */\n    MapTypeId: {\n        /**\n         * Map type that displays a transparent layer of major streets on\n         * satellite images.\n         * @type {String}\n         */\n        HYBRID: 'hybrid',\n        /**\n         * Map type that displays a normal street map.\n         * @type {String}\n         */\n        ROADMAP: 'roadmap',\n        /**\n         * Map type that displays satellite images.\n         * @type {String}\n         */\n        SATELLITE: 'satellite',\n        /**\n         * Map type displays maps with physical features such as terrain and\n         * vegetation.\n         * @type {String}\n         */\n        TERRAIN: 'terrain'\n    },\n    /**\n     * Enumerates Google location types.\n     * @memberof! geolocator\n     *\n     * @enum {String}\n     * @readonly\n     */\n    LocationType: {\n        /**\n         * Indicates that the returned result is a precise geocode for which\n         * we have location information accurate down to street address\n         * precision.\n         * @type {String}\n         */\n        ROOFTOP: 'ROOFTOP',\n        /**\n         * Indicates that the returned result reflects an approximation\n         * (usually on a road) interpolated between two precise points (such as\n         * intersections). Interpolated results are generally returned when\n         * rooftop geocodes are unavailable for a street address.\n         * @type {String}\n         */\n        RANGE_INTERPOLATED: 'RANGE_INTERPOLATED',\n        /**\n         * Indicates that the returned result is the geometric center of a\n         * result such as a polyline (for example, a street) or polygon\n         * (region).\n         * @type {String}\n         */\n        GEOMETRIC_CENTER: 'GEOMETRIC_CENTER',\n        /**\n         * Indicates that the returned result is approximate.\n         * @type {String}\n         */\n        APPROXIMATE: 'APPROXIMATE'\n    },\n    /**\n     * Enumerates Google travel modes.\n     * @memberof! geolocator\n     *\n     * @enum {String}\n     * @readonly\n     */\n    TravelMode: {\n        /**\n         * Indicates distance calculation using the road network.\n         * @type {String}\n         */\n        DRIVING: 'DRIVING',\n        /**\n         * Requests distance calculation for walking via pedestrian paths &\n         * sidewalks (where available).\n         * @type {String}\n         */\n        WALKING: 'WALKING',\n        /**\n         * Requests distance calculation for bicycling via bicycle paths &\n         * preferred streets (where available).\n         * @type {String}\n         */\n        BICYCLING: 'BICYCLING',\n        /**\n         * Requests distance calculation via public transit routes (where\n         * available). This value may only be specified if the request includes\n         * an API key or a Google Maps APIs Premium Plan client ID. If you set\n         * the mode to transit you can optionally specify either a\n         * `departureTime` or an `arrivalTime`. If neither time is specified,\n         * the `departureTime` defaults to now (that is, the departure time defaults\n         * to the current time). You can also optionally include a `transitMode`\n         * and/or a `transitRoutingPreference`.\n         * @type {String}\n         */\n        TRANSIT: 'TRANSIT'\n    },\n    // /**\n    //  * Enumerates Google route restrictions.\n    //  * @memberof! geolocator\n    //  *\n    //  * @enum {String}\n    //  * @readonly\n    //  */\n    // RouteRestriction: {\n    //     TOLLS: 'tolls',\n    //     HIGHWAYS: 'highways',\n    //     FERRIES: 'ferries',\n    //     INDOOR: 'indoor'\n    // },\n    /**\n     * Enumerates Google unit systems.\n     * @memberof! geolocator\n     *\n     * @enum {Number}\n     * @readonly\n     */\n    UnitSystem: {\n        /**\n         * Distances in kilometers and meters.\n         * @type {Number}\n         */\n        METRIC: 0,\n        /**\n         * Distances defined in miles and feet.\n         * @type {Number}\n         */\n        IMPERIAL: 1\n    },\n    /**\n     * Enumerates mobile radio types.\n     * @memberof! geolocator\n     *\n     * @enum {String}\n     * @readonly\n     */\n    RadioType: {\n        /**\n         * LTE (Long-Term Evolution) mobile radio type.\n         * @type {String}\n         */\n        LTE: 'lte',\n        /**\n         * GSM (Global System for Mobile Communications) mobile radio type.\n         * @type {String}\n         */\n        GSM: 'gsm',\n        /**\n         * CDMA (Code division multiple access) mobile radio access technology.\n         * @type {String}\n         */\n        CDMA: 'cdma',\n        /**\n         * Wideband CDMA mobile radio access technology.\n         * @type {String}\n         */\n        WCDMA: 'wcdma'\n    },\n    /**\n     * Enumerates formulas/algorithms for calculating the distance between two\n     * lat/lng points.\n     * @memberof! geolocator\n     *\n     * @readonly\n     * @enum {String}\n     *\n     * @todo {@link https://en.wikipedia.org/wiki/Vincenty%27s_formulae|Vincenty's Formula}\n     */\n    DistanceFormula: {\n        /**\n         * Haversine formula for calculating the distance between two lat/lng points\n         * by relating the sides and angles of spherical triangles.\n         * @see {@link http://en.wikipedia.org/wiki/Haversine_formula|Haversine_formula}.\n         * @type {String}\n         */\n        HAVERSINE: 'haversine',\n        /**\n         * Formula based on the Pythagoras Theorem for calculating the\n         * distance between two lat/lng points on a Equirectangular projection\n         * to account for curvature of the longitude lines.\n         * @see {@link https://en.wikipedia.org/wiki/Pythagorean_theorem|Pythagorean_theorem}\n         * @type {String}\n         */\n        PYTHAGOREAN: 'pythagorean'\n    },\n    /**\n     *  Enumerates the image formats used for getting static Google Map images.\n     *  @memberof! geolocator\n     *\n     *  @readonly\n     *  @enum {String}\n     */\n    ImageFormat: {\n        /**\n         *  Specifies the PNG image format.\n         *  Same as `PNG_8`.\n         *  @type {String}\n         */\n        PNG: 'png',\n        /**\n         *  Specifies the 8-bit PNG image format.\n         *  Same as `PNG`.\n         *  @type {String}\n         */\n        PNG_8: 'png8',\n        /**\n         *  Specifies the 32-bit PNG image format.\n         *  @type {String}\n         */\n        PNG_32: 'png32',\n        /**\n         *  Specifies the GIF image format.\n         *  @type {String}\n         */\n        GIF: 'gif',\n        /**\n         *  Specifies the JPEG compressed image format.\n         *  @type {String}\n         */\n        JPG: 'jpg',\n        /**\n         *  Specifies a non-progressive JPEG compression image format.\n         *  @type {String}\n         */\n        JPG_BASELINE: 'jpg-baseline'\n    }\n});\n\nexport default enums;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/enums.js","import utils from '../lib/utils';\n\n/**\n * Geolocator Error class that provides a common type of error object for the\n * various APIs implemented in Geolocator. All callbacks of Geolocator will\n * include an instance of this object as the first argument; if the\n * corresponding operation fails. Also all thrown errors will be an instance of\n * this object.\n *\n * This object can be publicly accessed via `geolocator.Error`.\n *\n * @extends Error\n */\nclass GeoError { // extends Error (doesn't work with transpilers)\n\n    /**\n     * Costructs a new instance of `GeoError`.\n     *\n     * @param {String} [code=\"UNKNOWN_ERROR\"]\n     *        Any valid Geolocator Error code.\n     *        See {@link #GeoError.Code|`GeoError.Code` enumeration} for\n     *        possible values.\n     * @param {String} [message]\n     *        Error message. If omitted, this will be set to `code`.\n     *\n     * @returns {GeoError}\n     *\n     * @example\n     * var GeoError = geolocator.Error,\n     *     error = new GeoError(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n     * console.log(error.code); // \"GEOLOCATION_NOT_SUPPORTED\"\n     * console.log(error instanceof GeoError); // true\n     */\n    constructor(code = GeoError.Code.UNKNOWN_ERROR, message) {\n        message = message || String(code);\n\n        /**\n         *  Gets the name of the Error object.\n         *  This always returns `\"GeoError\"`.\n         *  @name GeoError#name\n         *  @type {String}\n         */\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            writable: false,\n            value: 'GeoError' // this.constructor.name\n        });\n\n        /**\n         *  Gets the error code set for this instance.\n         *  This will return one of\n         *  {@link #GeoError.Code|`GeoError.Code` enumeration}.\n         *  @name GeoError#code\n         *  @type {String}\n         */\n        Object.defineProperty(this, 'code', {\n            enumerable: false,\n            writable: true,\n            value: code\n        });\n\n        /**\n         *  Gets the error message set for this instance.\n         *  If no message is set, this will return the error code value.\n         *  @name GeoError#message\n         *  @type {String}\n         */\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            /**\n             *  Gets the error stack for this instance.\n             *  @name GeoError#stack\n             *  @type {String}\n             */\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: (new Error(message)).stack\n            });\n        }\n    }\n\n    /**\n     * Creates a new instance of `GeoError` from the given value.\n     *\n     * @param {*} [err]\n     *        Value to be transformed. This is used to determine the proper\n     *        error code for the created instance. If an `Error` or `Object` is\n     *        passed, its `message` property is checked if it matches any of the\n     *        valid error codes. If omitted or no match is found, error code\n     *        `GeoError.Code.UNKNOWN_ERROR` will be used as default.\n     *\n     * @returns {GeoError}\n     *\n     * @example\n     * var GeoError = geolocator.Error,\n     * \t   error = GeoError.create();\n     * console.log(error.code); // \"UNKNOWN_ERROR\"\n     * error = GeoError.create(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n     * console.log(error.code); // \"GEOLOCATION_NOT_SUPPORTED\"\n     */\n    static create(err) {\n        if (err instanceof GeoError) {\n            return err;\n        }\n\n        let code, msg;\n\n        if (utils.isPositionError(err) && err.code) {\n            switch (err.code) {\n                case 1:\n                    code = GeoError.Code.PERMISSION_DENIED;\n                    break;\n                case 2:\n                    code = GeoError.Code.POSITION_UNAVAILABLE;\n                    break;\n                case 3:\n                    code = GeoError.Code.TIMEOUT;\n                    break;\n                default:\n                    code = GeoError.Code.UNKNOWN_ERROR;\n                    break;\n            }\n            return new GeoError(code, err.message || '');\n        }\n\n        if (typeof err === 'string') {\n            code = msg = err;\n        } else if (typeof err === 'object') {\n            code = err.code || err.message;\n            msg = err.message || err.code;\n        }\n        if (code && GeoError.isValidErrorCode(code)) {\n            return new GeoError(code, msg);\n        }\n\n        return new GeoError(GeoError.Code.UNKNOWN_ERROR, msg);\n    }\n\n    /**\n     * Creates a new instance of `GeoError` from the given response object.\n     * Since Geolocator implements various Google APIs, we might receive\n     * responses if different structures. For example, some APIs return a\n     * response object with a `status:String` property (such as the TimeZone\n     * API) and some return responses with an `error:Object` property. This\n     * method will determine the correct reason or message and return a\n     * consistent error object.\n     *\n     * @param {Object|String} response\n     *        Response (Object) or status (String) to be transformed.\n     * @param {String} [message=null]\n     *        Error message.\n     *\n     * @returns {GeoError}\n     *          `GeoError` instance if response contains an error. Otherwise,\n     *          returns `null`.\n     *\n     * @example\n     * var error = geolocator.Error.fromResponse(googleResponse);\n     * console.log(error.code); // \"GOOGLE_KEY_INVALID\"\n     */\n    static fromResponse(response, message = '') {\n        // example Google Geolocation API response:\n        // https://developers.google.com/maps/documentation/geolocation/intro#errors\n        // {\n        //      \"error\": {\n        //          \"errors\": [\n        //              {\n        //                  \"domain\": \"global\",\n        //                  \"reason\": \"parseError\",\n        //                  \"message\": \"Parse Error\",\n        //              }\n        //          ],\n        //      \"code\": 400,\n        //      \"message\": \"Parse Error\"\n        //      }\n        // }\n        // example Google TimeZone API response:\n        // {\n        //     \"status\": \"REQUEST_DENIED\"\n        // }\n\n        if (!response) return new GeoError(GeoError.Code.INVALID_RESPONSE);\n\n        let errCode;\n\n        if (utils.isString(response)) {\n            errCode = errorCodeFromStatus(response);\n            if (errCode) return new GeoError(errCode, message || response);\n        }\n\n        if (!utils.isObject(response)) return null;\n\n        let errMsg = response.error_message\n            || response.errorMessage\n            || ((response.error && response.error.message) || '')\n            || '';\n\n        if (response.status) {\n            errCode = errorCodeFromStatus(response.status);\n            if (errCode) return new GeoError(errCode, errMsg || message || response.status);\n        }\n\n        if (response.error) {\n            let reason = response.reason || response.error.reason;\n            if (!reason) {\n                let errors = response.error.errors;\n                if (utils.isArray(errors) && errors.length > 0) {\n                    reason = errors[0].reason; // get the first reason only\n                    errMsg = errMsg || errors[0].message; // update errMsg\n                }\n            }\n            errCode = errorCodeFromReason(reason) || GeoError.Code.UNKNOWN_ERROR;\n            return new GeoError(errCode, errMsg || reason || message);\n        }\n\n        if (errMsg) {\n            errCode = errorCodeFromStatus(errMsg) || GeoError.Code.UNKNOWN_ERROR;\n            return new GeoError(errCode, errMsg || message);\n        }\n\n        return null;\n    }\n\n    /**\n     *  Checks whether the given value is an instance of `GeoError`.\n     *\n     *  @param {*} err - Object to be checked.\n     *\n     *  @returns {Boolean}\n     */\n    static isGeoError(err) {\n        return err instanceof GeoError;\n    }\n\n    /**\n     *  Checks whether the given value is a valid Geolocator Error code.\n     *\n     *  @param {String} errorCode - Error code to be checked.\n     *\n     *  @returns {Boolean}\n     */\n    static isValidErrorCode(errorCode) {\n        let prop;\n        for (prop in GeoError.Code) {\n            if (GeoError.Code.hasOwnProperty(prop)\n                    && errorCode === GeoError.Code[prop]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n *  Gets the string representation of the error instance.\n *\n *  @returns {String}\n */\nGeoError.prototype.toString = function () {\n    var msg = this.code !== this.message ? ` (${this.message})` : '';\n    return `${this.name}: ${this.code}${msg}`;\n};\n\n// `class x extends Error` doesn't work when using an ES6 transpiler, such as\n// Babel, since subclasses must extend a class. With Babel 6, we need\n// transform-builtin-extend plugin for this to work. So we're extending from\n// Error the old way. Now, `err instanceof Error` also returns `true`.\nif (typeof Object.setPrototypeOf === 'function') {\n    Object.setPrototypeOf(GeoError.prototype, Error.prototype);\n} else {\n    GeoError.prototype = Object.create(Error.prototype);\n}\n\n// ---------------------------\n// ERROR CODES\n// ---------------------------\n\n/**\n *  Enumerates Geolocator error codes.\n *  This enumeration combines Google API status (error) codes, HTML5 Geolocation\n *  position error codes and other Geolocator-specific error codes.\n *  @enum {String}\n */\nGeoError.Code = {\n    /**\n     *  Indicates that HTML5 Geolocation API is not supported by the browser.\n     *  @type {String}\n     */\n    GEOLOCATION_NOT_SUPPORTED: 'GEOLOCATION_NOT_SUPPORTED',\n    /**\n     *  Indicates that Geolocation-IP source is not set or invalid.\n     *  @type {String}\n     */\n    INVALID_GEO_IP_SOURCE: 'INVALID_GEO_IP_SOURCE',\n    /**\n     *  The acquisition of the geolocation information failed because the\n     *  page didn't have the permission to do it.\n     *  @type {String}\n     */\n    PERMISSION_DENIED: 'PERMISSION_DENIED',\n    /**\n     *  The acquisition of the geolocation failed because at least one\n     *  internal source of position returned an internal error.\n     *  @type {String}\n     */\n    POSITION_UNAVAILABLE: 'POSITION_UNAVAILABLE',\n    /**\n     *  The time allowed to acquire the geolocation, defined by\n     *  PositionOptions.timeout information was reached before\n     *  the information was obtained.\n     *  @type {String}\n     */\n    TIMEOUT: 'TIMEOUT',\n    /**\n     * Indicates that the request had one or more invalid parameters.\n     * @type {String}\n     */\n    INVALID_PARAMETERS: 'INVALID_PARAMETERS',\n    /**\n     * Indicates that the service returned invalid response.\n     * @type {String}\n     */\n    INVALID_RESPONSE: 'INVALID_RESPONSE',\n    /**\n     * Generally indicates that the query (address, components or latlng)\n     * is missing.\n     * @type {String}\n     */\n    INVALID_REQUEST: 'INVALID_REQUEST',\n    /**\n     * Indicates that the request was denied by the service.\n     * This will generally occur because of a missing API key or because the request\n     * is sent over HTTP instead of HTTPS.\n     * @type {String}\n     */\n    REQUEST_DENIED: 'REQUEST_DENIED',\n    /**\n     * Indicates that the request has failed.\n     * This will generally occur because of an XHR error.\n     * @type {String}\n     */\n    REQUEST_FAILED: 'REQUEST_FAILED',\n    /**\n     * Indicates that Google API could not be loaded.\n     * @type {String}\n     */\n    GOOGLE_API_FAILED: 'GOOGLE_API_FAILED',\n    /**\n     * Indicates that you are over your Google API quota.\n     * @type {String}\n     */\n    OVER_QUERY_LIMIT: 'OVER_QUERY_LIMIT',\n    /**\n     * Indicates that you've exceeded the requests per second per user limit that\n     * you configured in the Google Developers Console. This limit should be\n     * configured to prevent a single or small group of users from exhausting your\n     * daily quota, while still allowing reasonable access to all users.\n     * @type {String}\n     */\n    USER_RATE_LIMIT_EXCEEDED: 'USER_RATE_LIMIT_EXCEEDED',\n    /**\n     * Indicates that you've exceeded your daily limit for Google API(s).\n     * @type {String}\n     */\n    DAILY_LIMIT_EXCEEDED: 'DAILY_LIMIT_EXCEEDED',\n    /**\n     * Indicates that your Google API key is not valid. Please ensure that you've\n     * included the entire key, and that you've either purchased the API or have\n     * enabled billing and activated the API to obtain the free quota.\n     * @type {String}\n     */\n    GOOGLE_KEY_INVALID: 'GOOGLE_KEY_INVALID',\n    /**\n     * Indicates that maximum number of elements limit is exceeded. For\n     * example, for the Distance Matrix API; occurs when the product of\n     * origins and destinations exceeds the per-query limit.\n     * @type {String}\n     */\n    MAX_ELEMENTS_EXCEEDED: 'MAX_ELEMENTS_EXCEEDED',\n    /**\n     * Indicates that the request contained more than 25 origins,\n     * or more than 25 destinations.\n     * @type {String}\n     */\n    MAX_DIMENSIONS_EXCEEDED: 'MAX_DIMENSIONS_EXCEEDED',\n    /**\n     * Indicates that the request contained more than allowed waypoints.\n     * @type {String}\n     */\n    MAX_WAYPOINTS_EXCEEDED: 'MAX_WAYPOINTS_EXCEEDED',\n    /**\n     * Indicates that the request body is not valid JSON.\n     * @type {String}\n     */\n    PARSE_ERROR: 'PARSE_ERROR',\n    /**\n     * Indicates that the requested resource could not be found.\n     * Note that this also covers `ZERO_RESULTS`.\n     * @type {String}\n     */\n    NOT_FOUND: 'NOT_FOUND',\n    /**\n     * Indicates that an internal error (such as XHR cross-domain, etc) has occured.\n     * @type {String}\n     */\n    INTERNAL_ERROR: 'INTERNAL_ERROR',\n    /**\n     * Indicates that an unknown error has occured.\n     * @type {String}\n     */\n    UNKNOWN_ERROR: 'UNKNOWN_ERROR'\n};\n\n// ---------------------------\n// HELPER METHODS\n// ---------------------------\n\n/**\n *  @private\n */\nfunction errorCodeFromStatus(status) {\n    if (!status) return GeoError.Code.INVALID_RESPONSE;\n    if (status === 'OK') return null;\n    if (status === 'ZERO_RESULTS') return GeoError.Code.NOT_FOUND;\n    if (GeoError.Code.hasOwnProperty(status)) return status;\n    return null;\n}\n\n/**\n *  Gets `GeoError.Code` from the given response error reason.\n *  @private\n *\n *  @param {String} reason\n *         Google response error reason.\n *\n *  @returns {String}\n */\nfunction errorCodeFromReason(reason) {\n    switch (reason) {\n        case 'invalid':\n            return GeoError.Code.INVALID_REQUEST;\n        case 'dailyLimitExceeded':\n            return GeoError.Code.DAILY_LIMIT_EXCEEDED;\n        case 'keyInvalid':\n            return GeoError.Code.GOOGLE_KEY_INVALID;\n        case 'userRateLimitExceeded':\n            return GeoError.Code.USER_RATE_LIMIT_EXCEEDED;\n        case 'notFound':\n            return GeoError.Code.NOT_FOUND;\n        case 'parseError':\n            return GeoError.Code.PARSE_ERROR;\n        default:\n            return null;\n    }\n}\n\n// ---------------------------\n// EXPORT\n// ---------------------------\n\nexport default GeoError;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/geo.error.js","import utils from './utils';\n\n/**\n * Utility for making `XMLHttpRequest` and `JSONP` requests.\n *\n * @license MIT\n * @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nclass fetch {\n\n    // https://html.spec.whatwg.org/multipage/scripting.html#script\n\n    /**\n     * Makes a JSONP (GET) request by injecting a script tag in the browser.\n     * Note that using JSONP has some security implications. As JSONP is really\n     * javascript, it can do everything else javascript can do, so you need to\n     * trust the provider of the JSONP data.\n     * @see https://en.wikipedia.org/wiki/JSONP\n     * @memberof fetch\n     *\n     * @param {Object|String} options - Required. Either the URL string which\n     *     will set other options to defaults or an options object with the\n     *     following properties.\n     *     @param {String} options.url\n     *            Source URL to be called.\n     *     @param {String} [options.type]\n     *            The MIME type that identifies the scripting language of the\n     *            code referenced within the script element.\n     *            e.g. `\"text/javascript\"`\n     *     @param {String} [options.charset]\n     *            Indicates the character encoding of the external resource.\n     *            e.g. `\"utf-8\"`.\n     *     @param {Boolean} [options.async=true]\n     *            Indicates whether or not to perform the operation\n     *            asynchronously. See {@link http://caniuse.com/#feat=script-async|browser support}.\n     *     @param {Boolean} [options.defer=false]\n     *            Indicates whether the script should be executed when the page\n     *            has finished parsing. See {@link http://caniuse.com/#feat=script-defer|browser support}.\n     *     @param {String} [options.crossorigin]\n     *            Indicates the CORS setting for the script element being\n     *            injected. Note that this attribute is not widely supported.\n     *            Valid values: `\"anonymous\"`, `\"use-credentials\"`.\n     *            See {@link https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes|CORS settings}.\n     *     @param {Number} [options.timeout=0]\n     *            The number of milliseconds a request can take before\n     *            automatically being terminated. `0` disables timeout.\n     *     @param {Boolean} [options.clean=false]\n     *            Whether to remove the loaded script from DOM when the\n     *            operation ends. Note that the initial source might load\n     *            additional sources which are not deteceted or removed. Only\n     *            the initial source is removed.\n     *     @param {Object} [options.params]\n     *            Optional query parameters to be appended at the end of the URL.\n     *            e.g. `{ key: \"MY-KEY\" }`\n     *            You can also include the JSONP callback name parameter here\n     *            but if you want the object to be passed to the callback\n     *            argument of this method, use `options.callbackParam` to set\n     *            the callback parameter.\n     *     @param {String} [options.callbackParam]\n     *            If the endpoint supports JSONP callbacks, you can set the\n     *            callback parameter with this setting. This will enable a\n     *            second `obj` argument in the callback of this method which is\n     *            useful if the JSONP source invokes the callback with an\n     *            argument.\n     *     @param {String} [options.rootName]\n     *            The name (or notation) of the object that the generated JSONP\n     *            callback function should be assigned to. By default, this is\n     *            the `window` object but you can set this to a custom object\n     *            notation; for example, to prevent global namespace polution.\n     *            Note that this root object has to be globally accessible for\n     *            this to work. e.g. `\"window.myObject\"` (as string)\n     * @param {Function} [callback]\n     *        The callback function that will be executed when the script is\n     *        loaded. This callback has the following signature:\n     *        `function (err, obj) { ... }`. Note that the second argument\n     *        `obj` will always be `undefined` if the source endpoint does not\n     *        support JSONP callbacks or a callback param is not set explicitly\n     *        via `options.callbackParam` (or if the source does not invoke the\n     *        jsonp with an argument). However, the function will always execute\n     *        when the script loads or an error occurs.\n     *\n     * @returns {void}\n     *\n     * @example\n     * var opts1 = {\n     * \t   url: 'some/api',\n     * \t   callbackParam: 'jsonCallback',\n     * \t   params: { key: 'MY-KEY' }\n     * };\n     * // This will load the following source:\n     * // some/api?jsonCallback={auto-generated-fn-name}&key=MY-KEY\n     * fetch.jsonp(opts1, function (err, obj) {\n     * \t   console.log(obj); // some object\n     * });\n     *\n     * var opts2 = {\n     * \t   url: 'some/api',\n     * \t   params: {\n     * \t\t   key: 'MY-KEY',\n     * \t\t   jsonCallback: 'my-fn-name'\n     * \t   }\n     * };\n     * // This will load the following source:\n     * // some/api?jsonCallback=my-fn-name&key=MY-KEY\n     * fetch.jsonp(options, function (err, obj) {\n     * \t   console.log(obj); // undefined\n     * \t   // still executes, catch errors here\n     * });\n     * // JSON callback should be explicitly set.\n     * window['my-fn-name'] = function (obj) {\n     * \t   console.log(obj); // some object\n     * };\n     */\n    static jsonp(options, callback) {\n        let timeout;\n\n        callback = utils.isFunction(callback)\n            ? callback\n            : utils.noop;\n\n        if (utils.isString(options)) {\n            options = { url: options };\n        }\n\n        if (utils.isPlainObject(options)) {\n            options = utils.extend({\n                // type: undefined,\n                async: true,\n                defer: false,\n                // crossorigin: undefined,\n                timeout: 0,\n                params: {},\n                // callbackParam: undefined,\n                // rootName: undefined,\n                clean: true\n            }, options);\n        } else {\n            return callback(new Error('No options or target URL is provided.'));\n        }\n\n        if (utils.isString(options.url) === false || options.url.trim() === '') {\n            return callback(new Error('No target URL is provided.'));\n        }\n\n        let script = document.createElement('script'),\n            cbParamSet = utils.isString(options.callbackParam)\n                && options.callbackParam.trim() !== '',\n            cbFnName,\n            root,\n            rootNameSet = utils.isString(options.rootName)\n                && options.rootName !== 'window'\n                && options.rootName !== 'document'\n                && options.rootName.trim() !== '';\n\n        if (cbParamSet) {\n            cbFnName = '_jsonp_' + utils.randomString(10);\n            options.params[options.callbackParam] = rootNameSet\n                ? `${options.rootName}.${cbFnName}`\n                : cbFnName;\n        }\n        let query = utils.params(options.params) || '',\n            qMark = options.url.indexOf('?') >= 0 ? '&' : '?',\n            url = query ? `${options.url}${qMark}${query}` : options.url;\n        // console.log(url);\n\n        function execCb(err, timeUp, obj) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            if ((timeUp || options.clean) && script.parentNode) {\n                script.parentNode.removeChild(script);\n            }\n            // delete the jsonp callback function\n            if (rootNameSet) {\n                delete root[cbFnName];\n            }\n            callback(err, obj);\n        }\n\n        if (cbFnName) {\n            let fn = obj => {\n                execCb(null, false, obj);\n            };\n            root = rootNameSet\n                // ? window[options.rootName][cbFnName] = fn;\n                ? utils.notateGlobalObj(options.rootName) // if rootName is dot-notation.\n                : window;\n            root[cbFnName] = fn;\n        } else if (script.readyState) { // IE < 11\n            script.onreadystatechange = () => {\n                if (script.readyState === 'loaded'\n                        || script.readyState === 'complete') {\n                    script.onreadystatechange = null;\n                    execCb(null);\n                }\n            };\n        } else { // IE 11+\n            script.onload = () => {\n                execCb(null);\n            };\n        }\n\n        script.onerror = error => {\n            let errMsg = 'Could not load source at ' + utils.removeQuery(options.url);\n            if (error) {\n                errMsg += '\\n' + (error.message || error);\n            }\n            execCb(new Error(errMsg));\n        };\n\n        if (options.type) {\n            script.type = options.type;\n        }\n        if (options.charset) {\n            script.charset = options.charset;\n        }\n        if (options.async) {\n            script.async = true;\n        }\n        if (options.defer) {\n            script.defer = true;\n        }\n        if (options.crossorigin) {\n            script.crossorigin = options.crossorigin;\n        }\n\n        script.src = url;\n        document.getElementsByTagName('head')[0].appendChild(script);\n\n        // Timeout\n        if (utils.isNumber(options.timeout) && options.timeout > 0) {\n            timeout = setTimeout(() => {\n                script.src = '';\n                execCb(new Error('Operation timed out.'), true);\n            }, options.timeout);\n        }\n    }\n\n    /**\n     * Makes an XMLHttpRequest with the given parameters.\n     * Note that `\"Access-Control-Allow-Origin\"` header should be present on\n     * the requested resource. Otherwise, the request will not be allowed.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}.\n     * @memberof fetch\n     *\n     * @param {Object|String} options\n     *        Either the URL string which will set other options to defaults or\n     *        the full options object.\n     *     @param {String} options.url\n     *            Target URL to be called.\n     *     @param {String} [options.method=\"GET\"]\n     *            HTTP method.\n     *     @param {*} [options.data]\n     *            Data to be sent with the request.\n     *     @param {Number} [options.timeout]\n     *            The number of milliseconds a request can take before\n     *            automatically being terminated. `0` disables timeout.\n     *     @param {Boolean} [options.withCredentials=false]\n     *            Indicates whether or not cross-site Access-Control requests\n     *            should be made using credentials such as cookies or\n     *            authorization headers.\n     *     @param {Boolean} [options.async=true]\n     *            Indicating whether or not to perform the operation\n     *            asynchronously. If this value is false, the `send()` method\n     *            does not return until the response is received. If `true`,\n     *            notification of a completed transaction is provided using\n     *            event listeners. This must be `true` if the multipart\n     *            attribute is `true`, or an exception will be thrown.\n     *     @param {String} [options.mimeType]\n     *            If set, overrides the MIME type returned by the server. This\n     *            may be used, for example, to force a stream to be treated and\n     *            parsed as `text/xml`, even if the server does not report it as\n     *            such.\n     *     @param {Object} [options.headers]\n     *            Sets the HTTP request headers. Each key should be a header\n     *            name with a value. e.g. `{ 'Content-Length': 50 }`. For\n     *            security reasons, some headers cannot be set and can only be\n     *            controlled by the user agent.\n     *     @param {String} [options.username=\"\"]\n     *            User name to use for authentication purposes.\n     *     @param {String} [options.password=\"\"]\n     *            Password to use for authentication purposes.\n     * @param {Function} [callback]\n     *        The callback function in the following signature:\n     *        `function (err, xhr) { ... }`\n     *        Note that `xhr` object is always passed regardless of an error.\n     *\n     * @returns {void}\n     */\n    static xhr(options, callback) {\n        let xhr, err;\n\n        if ('XMLHttpRequest' in window) {\n            xhr = new XMLHttpRequest();\n        } else {\n            throw new Error('XMLHttpRequest is not supported!');\n        }\n\n        let hasCallback = utils.isFunction(callback);\n        callback = hasCallback\n            ? callback\n            : utils.noop;\n\n        if (utils.isString(options)) {\n            options = { url: options };\n        }\n\n        if (utils.isPlainObject(options)) {\n            options = utils.extend({\n                method: 'GET',\n                data: undefined,\n                async: true,\n                timeout: 0, // no timeout\n                withCredentials: false,\n                mimeType: undefined,\n                username: '',\n                password: ''\n            }, options);\n        } else {\n            callback(new Error('No options or target URL is provided.'));\n        }\n\n        if (utils.isString(options.url) === false) {\n            callback(new Error('No target URL is provided.'));\n        }\n\n        options.username = String(options.username);\n        options.password = String(options.password);\n        options.method = options.method.toUpperCase();\n        if (options.method !== 'POST' && options.method !== 'PUT') {\n            options.data = undefined;\n        }\n        // console.log(JSON.stringify(options));\n\n        if (hasCallback) {\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState === fetch.XHR_READY_STATE.DONE) {\n                    if (xhr.status === 200) {\n                        callback(null, xhr);\n                    } else {\n                        // let response = utils.safeJsonParse(xhr.responseText);\n                        // if (response && response.error)\n                        let crossDomain = xhr.status === 0\n                            ? '. Make sure you have permission if this is a cross-domain request.'\n                            : '';\n                        err = new Error(`The request returned status: ${xhr.status}${crossDomain}`);\n                        // console.log(xhr);\n                        callback(err, xhr);\n                    }\n                }\n            };\n\n            if (utils.isNumber(options.timeout) && options.timeout > 0) {\n                xhr.timeout = options.timeout;\n                xhr.ontimeout = () => {\n                    // xhr.abort();\n                    err = new Error('The request had timed out.');\n                    callback(err, xhr);\n                };\n            }\n        }\n        // console.log(options);\n        xhr.open(options.method, options.url, options.async, options.username, options.password);\n\n        // xhr.setRequestHeader() method should b called œafter open(), but\n        // before send().\n        if (utils.isPlainObject(options.headers)) {\n            Object.keys(options.headers).forEach(key => {\n                let value = options.headers[key];\n                xhr.setRequestHeader(key, value);\n            });\n        }\n\n        // xhr.overrideMimeType() method must be called before send().\n        if (options.mimeType) {\n            xhr.overrideMimeType(options.mimeType);\n        }\n\n        xhr.send(options.data);\n    }\n\n    /**\n     * Alias of `fetch.xhr()` with request method set to `\"GET\"` by default.\n     * @memberof fetch\n     *\n     * @param {Object} options\n     *        Either the URL string which will set other options to defaults or\n     *        the full options object. See `fetch.xhr()` method options for\n     *        details.\n     * @param {Function} [callback]\n     *        The callback function in the following signature:\n     *        `function (err, xhr) { ... }`\n     *        Note that `xhr` object is always passed regardless of an error.\n     * @returns {void}\n     */\n    static get(options, callback) {\n        return fetch.xhr(options, callback);\n    }\n\n    /**\n     * Alias of `fetch.xhr()` with request method set to `\"POST\"` by default.\n     * @memberof fetch\n     *\n     * @param {Object} options\n     *        Either the URL string which will set other options to defaults or\n     *        the full options object. See `fetch.xhr()` method options for\n     *        details.\n     * @param {Function} [callback]\n     *        The callback function in the following signature:\n     *        `function (err, xhr) { ... }`\n     *        Note that `xhr` object is always passed regardless of an error.\n     * @returns {void}\n     */\n    static post(options, callback) {\n        return _xhr('POST', options, callback);\n    }\n\n    /**\n     * Alias of `fetch.xhr()` with request method set to `\"PUT\"` by default.\n     * @memberof fetch\n     *\n     * @param {Object} options\n     *        Either the URL string which will set other options to defaults or\n     *        the full options object. See `fetch.xhr()` method options for\n     *        details.\n     * @param {Function} [callback]\n     *        The callback function in the following signature:\n     *        `function (err, xhr) { ... }`\n     *        Note that `xhr` object is always passed regardless of an error.\n     * @returns {void}\n     */\n    static put(options, callback) {\n        return _xhr('PUT', options, callback);\n    }\n\n    /**\n     * Alias of `fetch.xhr()` with request method set to `\"DELETE\"` by default.\n     * @memberof fetch\n     *\n     * @param {Object} options\n     *        Either the URL string which will set other options to defaults or\n     *        the full options object. See `fetch.xhr()` method options for\n     *        details.\n     * @param {Function} [callback]\n     *        The callback function in the following signature:\n     *        `function (err, xhr) { ... }`\n     *        Note that `xhr` object is always passed regardless of an error.\n     * @returns {void}\n     */\n    static delete(options, callback) {\n        return _xhr('DELETE', options, callback);\n    }\n}\n\n/**\n *  @private\n */\nfunction _xhr(method, options, callback) {\n    options = utils.isString(options)\n        ? { url: options }\n        : options || {};\n    options.method = method;\n    return fetch.xhr(options, callback);\n}\n\n/**\n * Enumerates `XMLHttpRequest` ready states.\n * Not to be confused with `script.readyState`.\n * @memberof fetch\n *\n * @enum {Number}\n */\nfetch.XHR_READY_STATE = {\n    /**\n     * `xhr.open()` has not been called yet.\n     * @type {Number}\n     */\n    UNSENT: 0,\n    /**\n     * `xhr.send()` has been called.\n     * @type {Number}\n     */\n    OPENED: 1,\n    /**\n     * `xhr.send()` has been called, and headers and status are available.\n     * @type {Number}\n     */\n    HEADERS_RECEIVED: 2,\n    /**\n     * Downloading; responseText holds partial data.\n     * @type {Number}\n     */\n    LOADING: 3,\n    /**\n     * The operation is complete.\n     * @type {Number}\n     */\n    DONE: 4\n};\n\nexport default fetch;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/fetch.js","import utils from '../lib/utils';\nimport fetch from '../lib/fetch';\nimport geoHelper from './geo.helper';\nimport GeoError from './geo.error';\nimport GeoWatcher from './geo.watcher';\nimport enums from './enums';\n\n/**\n *  Radius of earth in kilometers.\n *  @private\n *  @type {Number}\n */\nconst EARTH_RADIUS_KM = 6371;\n\n/**\n *  Radius of earth in miles.\n *  @private\n *  @type {Number}\n */\nconst EARTH_RADIUS_MI = 3959;\n\n/**\n *  Storage for Geolocator default configuration.\n *\n *  @readonly\n *  @private\n */\nconst defaultConfig = {\n    language: 'en',\n    https: true,\n    google: {\n        version: '3', // latest 3.x\n        key: '',\n        styles: null\n    }\n};\n\n/**\n *  Geolocator library that provides methods for getting geo-location information,\n *  geocoding, address look-ups, distance & durations, timezone information and more...\n *  This library makes use of HTML5 position feautures, implements Google APIs\n *  and other services.\n *\n *  <b>Important Notes:</b>\n *\n *  Although some calls might work without a key, it is generally required by\n *  most {@link https://developers.google.com/maps/faq#using-google-maps-apis|Goolge APIs}\n *  (such as Time Zone API). To get a free (or premium) key,\n *  {@link https://developers.google.com/maps/documentation/javascript/|click here}.\n *  After getting a key, you can enable multiple APIs for it. Make sure you\n *  {@link https://console.developers.google.com|enable}\n *  all the APIs supported by Geolocator.\n *\n *  Note that browser API keys cannot have referer restrictions when used\n *  with some Google APIs.\n *\n *  Make sure your doctype is HTML5 and you're calling Geolocation APIs from an\n *  HTTPS page. Geolocation API is removed from unsecured origins in Chrome 50.\n *  Other browsers are expected to follow.\n *\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n */\nclass geolocator {\n\n    // ---------------------------\n    // PROPERTIES\n    // ---------------------------\n\n    /**\n     *  Geolocator Error class that provides a common type of error object for\n     *  the various APIs implemented in Geolocator. All callbacks of Geolocator\n     *  will include an instance of this object as the first argument; if the\n     *  corresponding operation fails. Also all thrown errors will be an instance\n     *  of this object.\n     *\n     *  This object also enumerates\n     *  {@link ?api=geolocator-error#GeoError.Code|Geolocator Error codes}.\n     *\n     *  @see {@link ?api=geolocator-error|`GeoError` documentation}\n     *  @type {GeoError}\n     *  @readonly\n     */\n    static get Error() {\n        return GeoError;\n    }\n\n    /**\n     *  Documented separately in enums.js\n     *  @private\n     */\n    static get MapTypeId() {\n        return enums.MapTypeId;\n    }\n\n    /**\n     *  Documented separately in enums.js\n     *  @private\n     */\n    static get LocationType() {\n        return enums.LocationType;\n    }\n\n    /**\n     *  Documented separately in enums.js\n     *  @private\n     */\n    static get TravelMode() {\n        return enums.TravelMode;\n    }\n\n    /**\n     *  Documented separately in enums.js\n     *  @private\n     */\n    static get UnitSystem() {\n        return enums.UnitSystem;\n    }\n\n    /**\n     *  Documented separately in enums.js\n     *  @private\n     */\n    static get RadioType() {\n        return enums.RadioType;\n    }\n\n    /**\n     *  Documented separately in enums.js\n     *  @private\n     */\n    static get DistanceFormula() {\n        return enums.DistanceFormula;\n    }\n\n    /**\n     *  Documented separately in enums.js\n     *  @private\n     */\n    static get ImageFormat() {\n        return enums.ImageFormat;\n    }\n\n    // ---------------------------\n    // STATIC METHODS\n    // ---------------------------\n\n    /**\n     *  Sets or gets the geolocator configuration object.\n     *  Make sure you configure Geolocator before calling other methods that\n     *  require a Google API key.\n     *\n     *  @param {Object} [options]\n     *         Configuration object. If omitted, this method returns the current\n     *         configuration.\n     *      @param {String} [options.language=\"en\"]\n     *             Language to be used for API requests that supports language\n     *             configurations. This is generally used for Google APIs.\n     *             See {@link https://developers.google.com/maps/faq#languagesupport|supported languages}.\n     *      @param {Boolean} [options.https=true]\n     *             As Google recommends; using HTTPS encryption makes your site\n     *             more secure, and more resistant to snooping or tampering.\n     *             If set to `true`, the API calls are made over HTTPS, at all\n     *             times. Setting to `false` will switch to HTTP (even if the\n     *             page is on HTTPS). And if set to `null`, current protocol will\n     *             be used. Note that some APIs might not work with HTTP such as\n     *             Google Maps TimeZone API.\n     *      @param {Object} [options.google]\n     *             Google specific options.\n     *          @param {String} [options.google.version=\"3\"]\n     *                 Google Maps API version to be used (with\n     *                 `geolocator.createMap()`) method. The default version\n     *                 value is tested and works with Geolocator. You can set a\n     *                 greater value or the latest version number and it should\n     *                 work; but it's not guaranteed. Find out the\n     *                 {@link https://developers.google.com/maps/documentation/javascript/versions|latest version here}.\n     *          @param {String} [options.google.key=\"\"]\n     *                 API key to be used with Google API calls. Although some\n     *                 calls might work without a key, it is generally required\n     *                 by most Goolge APIs. To get a free (or premium) key,\n     *                 {@link https://developers.google.com/maps/documentation/javascript/|click here}.\n     *          @param {Array} [options.google.styles]\n     *                 An array of objects to customize the presentation of the\n     *                 Google base maps, changing the visual display of such\n     *                 elements as roads, parks, and built-up areas.\n     *                 See {@link https://developers.google.com/maps/documentation/javascript/styling|Styling Maps}.\n     *\n     *  @returns {Object} - Returns the current or updated configuration object.\n     *\n     *  @example\n     *  geolocator.config({\n     *      language: \"en\",\n     *      google: {\n     *          version: \"3\",\n     *          key: \"YOUR-GOOGLE-API-KEY\"\n     *      }\n     *  });\n     */\n    static config(options) {\n        if (options) {\n            geolocator._.config = utils.extend(defaultConfig, options);\n        }\n        return geolocator._.config;\n    }\n\n    /**\n     *  Gets a static map image URL which can be embeded via an `<img />` tag\n     *  on the page.\n     *\n     *  Note that, if `options.center` is set to an address (instead of\n     *  coordinates) and `options.marker` is also set; we will need to geocode\n     *  that address to get center coordinates for the marker.\n     *  In this case, you must use the `callback` parameter to get the async\n     *  result. Otherwise, this method will directly return a `String`.\n     *\n     *  Make sure you have enabled Static Maps API (and Geocoding API if\n     *  `marker` is enabled) in your Google Developers console.\n     *\n     *  For interactive map, see {@link #geolocator.createMap|`geolocator.createMap()` method}.\n     *\n     *  @see {@link https://developers.google.com/maps/documentation/static-maps/intro|Static Maps}\n     *  @see {@link https://developers.google.com/maps/documentation/static-maps/usage-limits|Usage Limits}\n     *\n     *  @param {Object} options\n     *         Static map options.\n     *         @param {String|Object} options.center\n     *                Defines the center of the map and the location.\n     *                Either an address `String` or an coordinates `Object` with\n     *                `latitude:Number` and `longitude:Number` properties.\n     *         @param {String} [options.mapTypeId=\"roadmap\"]\n     *                Type of the map to be created.\n     *                See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n     *                for possible values.\n     *         @param {String|Object} [options.size=\"600x300\"]\n     *                Defines the size (in pixels) of the returned image.\n     *                Either a string in `widthxheight` format or an Object\n     *                with `width:Number` and `height:Number` properties.\n     *         @param {Number} [options.scale=1]\n     *                Affects the number of pixels that are returned. scale=2\n     *                returns twice as many pixels as scale=1 while retaining\n     *                the same coverage area and level of detail (i.e. the\n     *                contents of the map don't change). Accepted values are 1,\n     *                2 and 4 (4 is only available to Google Maps APIs Premium\n     *                Plan customers.)\n     *         @param {Number} [options.zoom=9]\n     *                Zoom level to be set for the map.\n     *         @param {String} [options.format=png]\n     *                Defines the format of the resulting image.\n     *                See {@link #geolocator.ImageFormat|`geolocator.ImageFormat` enumeration}\n     *                for possible values.\n     *         @param {Boolean|String} [options.marker=true]\n     *                Specifies whether to add a marker to the center of the map.\n     *                You can define the color of the marker by passing a color\n     *                `String` instead of a `Boolean`. Color can be a predefined\n     *                color from the set `red` (default), `black`, `brown`,\n     *                `green`, `purple`, `yellow`, `blue`, `gray`, `orange` and\n     *                `white`; or a HEX 24-bit color (e.g. `\"0xFF0000\"`).\n     *                Note that marker will not be visible if `center` is set to\n     *                a `String` address and you don't use the callback.\n     *         @param {String} [options.region]\n     *                Defines the appropriate borders to display, based on\n     *                geo-political sensitivities. Accepts a region code\n     *                specified as a two-character ccTLD (top-level domain)\n     *                value. e.g. `\"us\"`.\n     *         @param {Array} [options.styles]\n     *                An array of objects to customize the presentation of the\n     *                Google base maps, changing the visual display of such\n     *                elements as roads, parks, and built-up areas.\n     *                This will default to the global styles set via\n     *                {@link #geolocator.config|`geolocator.config()` method}, if any.\n     *                See {@link https://developers.google.com/maps/documentation/javascript/styling|Styling Maps}.\n     *\n     *  @param {Function} [callback]\n     *         Callback function to be executed when the static map URL is built.\n     *         This takes 2 arguments: `function (err, url) { ... }`.\n     *         If omitted, this method will directly return the static map\n     *         image URL; but (if enabled) the marker will not be visible if\n     *         `options.center` is set to an address `String` instead of a\n     *         coordinates `Object`.\n     *\n     *  @returns {String|void}\n     *           If a callback is passed, this will return `void`.\n     *           Otherwise, a `String` that represents the URL of the static map.\n     *\n     *  @example\n     *  // Async example (with address and marker)\n     *  var options = {\n     *      center: \"Los Angles, CA, US\",\n     *      mapTypeId: geolocator.MapTypeId.ROADMAP,\n     *      size: \"600x300\",\n     *      scale: 1,\n     *      zoom: 5,\n     *      marker: \"0xFFCC00\",\n     *      format: geolocator.ImageFormat.PNG\n     *  };\n     *  geolocator.getStaticMap(options, function (err, url) {\n     *      if (!err) {\n     *          document.getElementById('my-img').src = url;\n     *      }\n     *  });\n     *\n     *  @example\n     *  // Sync example (with coordinates)\n     *  var options = {\n     *      center: {\n     *          longitude: 34.0522342,\n     *          latitude: -118.2436849\n     *      },\n     *      mapTypeId: geolocator.MapTypeId.ROADMAP,\n     *      size: \"600x300\",\n     *      scale: 1,\n     *      zoom: 5,\n     *      marker: \"0xFFCC00\",\n     *      format: geolocator.ImageFormat.PNG\n     *  };\n     *  document.getElementById('my-img').src = geolocator.getStaticMap(options);\n     */\n    static getStaticMap(options, callback) {\n        if (!utils.isPlainObject(options) || !options.center) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS,\n                'A center address or coordinates are required.');\n        }\n\n        if (utils.isString(options.center)) {\n            return geolocator.geocode(options.center, (err, location) => {\n                if (err) callback(err);\n                options.center = location.coords;\n                callback(null, geolocator.getStaticMap(options));\n            });\n        }\n\n        let conf = geolocator._.config;\n        let opts = utils.extend({\n            mapTypeId: enums.MapTypeId.ROADMAP,\n            size: {\n                width: 600,\n                height: 300\n            },\n            scale: 1, // 1 | 2 | (4 for business customers of google maps)\n            zoom: 9,\n            marker: 'red',\n            format: enums.ImageFormat.PNG,\n            language: conf.language || 'en',\n            region: null\n        }, options);\n\n        let center = utils.isPlainObject(opts.center)\n            ? `${opts.center.latitude},${opts.center.longitude}`\n            : String(opts.center);\n\n        let size = utils.isPlainObject(opts.size)\n            ? `${opts.size.width}x${opts.size.height}`\n            : String(opts.size);\n\n        let url = enums.URL.GOOGLE_SATATIC_MAP // not using utils.setProtocol() here\n            + `?center=${center}&maptype=${opts.mapTypeId}`\n            + `&size=${size}&scale=${opts.scale}&zoom=${opts.zoom}`\n            + `&format=${opts.format}&language=${opts.language}`;\n\n        if (opts.marker) {\n            let color = utils.isString(opts.marker) ? opts.marker : 'red';\n            url += '&markers=' + encodeURIComponent(`color:${color}|${center}`);\n        }\n        if (opts.region) url += '&region=' + opts.region;\n        if (conf.google.key) url += '&key=' + conf.google.key;\n\n        let styles = getStyles(opts);\n        if (styles) url += '&' + geoHelper.mapStylesToParams(styles);\n\n        if (utils.isFunction(callback)) return callback(null, url);\n        return url;\n    }\n\n    /**\n     *  Creates an interactive Google Map within the given element.\n     *  Make sure you have enabled Google Static Maps API in your Google Developers console.\n     *  For static map, see {@link #geolocator.getStaticMap|`geolocator.getStaticMap()` method}.\n     *  @see {@link https://developers.google.com/maps/documentation/javascript/reference|Google Maps JavaScript API}\n     *  @see {@link https://developers.google.com/maps/documentation/javascript/usage|Usage Limits}\n     *\n     *  @param {Object|String|HTMLElement|Map} options\n     *         Either map options object with the following properties or; the ID\n     *         of a DOM element, or element itself which the map will be\n     *         created within; or a previously created `google.maps.Map` instance.\n     *         If a map instance is set, this only will apply the options without\n     *         re-creating it.\n     *      @param {String|HTMLElement|Map} options.element\n     *             Either the ID of a DOM element or the element itself;\n     *             which the map will be created within; or a previously created\n     *             `google.maps.Map` instance. If a map instance is set, this\n     *             only will apply the options without re-creating it.\n     *      @param {Object} options.center\n     *             Center coordinates for the map to be created.\n     *          @param {Number} options.center.latitude\n     *                 Latitude of the center point coordinates.\n     *          @param {Number} options.center.longitude\n     *                 Longitude of the center point coordinates.\n     *      @param {String} [options.mapTypeId=\"roadmap\"]\n     *             Type of the map to be created.\n     *             See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n     *             for possible values.\n     *      @param {String} [options.title]\n     *             Title text to be displayed within an `InfoWindow`, when the\n     *             marker is clicked. This only take effect if `marker` is\n     *             enabled.\n     *      @param {Boolean} [options.marker=true]\n     *             Whether to place a marker at the given coordinates.\n     *             If `title` is set, an `InfoWindow` will be opened when the\n     *             marker is clicked.\n     *      @param {Number} [options.zoom=9]\n     *             Zoom level to be set for the map.\n     *      @param {Array} [options.styles]\n     *             An array of objects to customize the presentation of the\n     *             Google base maps, changing the visual display of such\n     *             elements as roads, parks, and built-up areas.\n     *             This will default to the global styles set via\n     *             {@link #geolocator.config|`geolocator.config` method}`, if any.\n     *             See {@link https://developers.google.com/maps/documentation/javascript/styling|Styling Maps}.\n     *\n     *  @param {Function} callback\n     *         Callback function to be executed when the map is created.\n     *         This takes 2 arguments: `function (err, map) { ... }`.\n     *         See {@link #geolocator~MapData|`geolocator~MapData` type} for details.\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var options = {\n     *      element: \"my-map\",\n     *      center: {\n     *          latitude: 48.8534100,\n     *          longitude: 2.3488000\n     *  \t},\n     *  \tmarker: true,\n     *  \ttitle: \"Paris, France\",\n     *  \tzoom: 12\n     *  };\n     *  geolocator.createMap(options, function (err, map) {\n     *      if (map && map.infoWindow) {\n     *          map.infoWindow.open(map.instance, map.marker);\n     *      }\n     *  });\n     */\n    static createMap(options, callback) {\n        // if options is not a plain object, consider element ID, `HTMLElement`,\n        // `jQuery` instance or `google.maps.Map` instance.\n        if (!utils.isPlainObject(options)) {\n            options = { element: options };\n        }\n\n        options = utils.extend({\n            element: null,\n            mapTypeId: enums.MapTypeId.ROADMAP,\n            title: undefined,\n            marker: true,\n            zoom: 9\n        }, options);\n\n        let e = options.element,\n            elem;\n        if (utils.isString(e)) {\n            elem = document.getElementById(e);\n        } else if (utils.isJQueryObject(e)) {\n            elem = e[0];\n        } else if (geolocator.isGoogleLoaded() && e instanceof google.maps.Map) {\n            elem = e.getDiv();\n        }\n\n        if (!utils.isElement(elem) && !utils.isNode(elem)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS,\n                'A valid DOM element or element ID is required to create a map.');\n        }\n\n        if (!utils.isPlainObject(options.center)\n                || !utils.isNumber(options.center.latitude)\n                || !utils.isNumber(options.center.longitude)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS,\n                'Center coordinates are required to create a map.');\n        }\n\n        options.element = elem;\n\n        let conf = geolocator._.config,\n            key = conf.google.key;\n        options.styles = getStyles(options);\n\n        geolocator.ensureGoogleLoaded(key, err => {\n            if (err) {\n                throw new GeoError(GeoError.Code.GOOGLE_API_FAILED, String(err.message || err));\n            }\n\n            let mapData = configCreateMap(options);\n            callback(null, mapData);\n        });\n    }\n\n    /**\n     *  Locates the user's location via HTML5 geolocation. This may\n     *  require/prompt for user's permission. If the permission is granted we'll\n     *  get the most accurate location information. Otherwise, we'll fallback to\n     *  locating via user's IP (if enabled).\n     *\n     *  For better accuracy, Geolocator implements a different approach than the\n     *  `getCurrentPosition` API; which generally triggers before the device's\n     *  GPS hardware can provide anything accurate. Thanks to\n     *  {@link https://github.com/gwilson/getAccurateCurrentPosition#background|Greg Wilson}\n     *  for the idea.\n     *\n     *  Also note that HTML5 Geolocation feature no more allows insecure origins.\n     *  See {@link https://goo.gl/rStTGz|this} for more details.\n     *  This means if you don't call this method from an HTTPS page, it will\n     *  fail. And if `options.fallbackToIP` is enabled, this will locate by IP.\n     *\n     *  @param {Object} [options]\n     *         HTML5 geo-location settings with some additional options.\n     *      @param {Boolean} [options.enableHighAccuracy=true]\n     *             Specifies whether the device should provide the most accurate\n     *             position it can. Note that setting this to `true` might\n     *             consume more CPU and/or battery power; and result in slower\n     *             response times.\n     *      @param {Number} [options.desiredAccuracy=30]\n     *             Minimum accuracy desired, in meters. Position will not be\n     *             returned until this is met, before the timeout. This only\n     *             takes effect if `enableHighAccuracy` is set to `true`.\n     *      @param {Number} [options.timeout=5000]\n     *             HTML5 position timeout setting in milliseconds. Setting this\n     *             to `Infinity` means that Geolocator won't return until the\n     *             position is available.\n     *      @param {Number} [options.maximumWait=10000]\n     *             Maximum time to wait (in milliseconds) for the desired\n     *             accuracy (which should be greater than `timeout`).\n     *             This only takes effect if `enableHighAccuracy` is set to\n     *             `true`.\n     *      @param {Number} [options.maximumAge=0]\n     *             HTML5 position maximum age. Indicates the maximum age in\n     *             milliseconds of a possible cached position that is acceptable\n     *             to return. `0` means, the device cannot use a cached position\n     *             and must attempt to retrieve the real current position. If set\n     *             to `Infinity` the device must return a cached position\n     *             regardless of its age. Note that if `enableHighAccuracy` is\n     *             set to `true`, `maximumAge` will be forced to `0`.\n     *      @param {Function} [options.onProgress]\n     *             If `enableHighAccuracy` is set to `true`, you can use this\n     *             callback to check the progress of the location accuracy;\n     *             while waiting for the final, best accurate location.\n     *      @param {Boolean} [options.fallbackToIP=false]\n     *             Specifies whether to fallback to IP geolocation if the HTML5\n     *             geolocation fails (e.g. user rejection).\n     *      @param {Boolean} [options.addressLookup=false]\n     *             Specifies whether to run a reverse-geocode operation for the\n     *             fetched coordinates to retrieve detailed address information.\n     *             Note that this means an additional request which requires a\n     *             Google API key to be set in the Geolocator configuration.\n     *             See {@link #geolocator.config|`geolocator.config()`}.\n     *      @param {Boolean} [options.timezone=false]\n     *             Specifies whether to also fetch the time zone information for\n     *             the receieved coordinates. Note that this means an additional\n     *             request which requires a Google API key to be set in the\n     *             Geolocator configuration.\n     *             See {@link #geolocator.config|`geolocator.config()`}.\n     *      @param {String|MapOptions} [options.map]\n     *             In order to create an interactive map from the fetched\n     *             location coordinates; either set this to a\n     *             {@link #geolocator~MapOptions|`MapOptions` object}\n     *             or; the ID of a DOM element or DOM element itself which the\n     *             map will be created within.\n     *      @param {Boolean|Object} [options.staticMap=false]\n     *             Set to `true` to get a static Google Map image URL (with\n     *             default options); or pass a static map options object.\n     *\n     *  @param {Function} callback\n     *         Callback function to be executed when the request completes.\n     *         This takes 2 arguments: `function (err, location) { ... }`.\n     *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var options = {\n     *      enableHighAccuracy: true,\n     *      desiredAccuracy: 30,\n     *      timeout: 5000,\n     *      maximumWait: 10000,\n     *      maximumAge: 0,\n     *      fallbackToIP: true,\n     *      addressLookup: true,\n     *      timezone: true,\n     *      map: \"my-map\",\n     *      staticMap: true\n     *  };\n     *  geolocator.locate(options, function (err, location) {\n     *      console.log(err || location);\n     *  });\n     *\n     * @example\n     *  // location result:\n     *  {\n     *      coords: {\n     *          latitude: 37.4224764,\n     *          longitude: -122.0842499,\n     *          accuracy: 30,\n     *          altitude: null,\n     *          altitudeAccuracy: null,\n     *          heading: null,\n     *          speed: null\n     *      },\n     *      address: {\n     *          commonName: \"\",\n     *          street: \"Amphitheatre Pkwy\",\n     *          route: \"Amphitheatre Pkwy\",\n     *          streetNumber: \"1600\",\n     *          neighborhood: \"\",\n     *          town: \"\",\n     *          city: \"Mountain View\",\n     *          region: \"Santa Clara County\",\n     *          state: \"California\",\n     *          stateCode: \"CA\",\n     *          postalCode: \"94043\",\n     *          country: \"United States\",\n     *          countryCode: \"US\"\n     *      },\n     *      formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n     *      type: \"ROOFTOP\",\n     *      placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n     *      timezone: {\n     *          id: \"America/Los_Angeles\",\n     *          name: \"Pacific Standard Time\",\n     *          abbr: \"PST\",\n     *          dstOffset: 0,\n     *          rawOffset: -28800\n     *      },\n     *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n     *      map: {\n     *          element: HTMLElement,\n     *          instance: Object, // google.maps.Map\n     *          marker: Object, // google.maps.Marker\n     *          infoWindow: Object, // google.maps.InfoWindow\n     *          options: Object // map options\n     *      },\n     *      staticMap: \"//maps.googleapis.com/maps/api/staticmap?center=37.4224764,-122.0842499&maptype=roadmap&size=600x300&scale=1&zoom=9&format=png&language=en&markers=color%3Ared%7C37.4224764%2C2-122.0842499&key=YOUR-GOOGLE-API-KEY\",\n     *      timestamp: 1456795956380\n     *  }\n     */\n    static locate(options, callback) {\n        options = utils.extend({\n            enableHighAccuracy: true,\n            timeout: 5000,\n            maximumWait: 10000,\n            maximumAge: 0,\n            desiredAccuracy: 30,\n            onProgress: utils.noop,\n            fallbackToIP: false,\n            addressLookup: false,\n            timezone: false,\n            map: undefined,\n            staticMap: false\n        }, options);\n\n        // force disable cache if high-accuracy is enabled\n        if (options.enableHighAccuracy) options.maximumAge = 0;\n        // set a min value for timeout\n        if (options.timeout < 1000) options.timeout = 1000;\n        // max wait should not be less than timeout\n        if (options.maximumWait < options.timeout) options.maximumWait = options.timeout;\n\n        // check options and Google key\n        checkGoogleKey(options);\n\n        let cb = callbackMap(options, callback);\n\n        function fallbackToIP(error) {\n            if (options.fallbackToIP) {\n                return geolocator.locateByIP(options, (err, location) => {\n                    if (err) return cb(err, null);\n                    return cb(null, location);\n                });\n            }\n            cb(error, null);\n        }\n        function onPositionReceived(location) {\n            fetchAddressAndTimezone(location, options, cb);\n        }\n        function onPositionError(err) {\n            err = GeoError.create(err);\n            fallbackToIP(err);\n        }\n\n        if (geolocator.isGeolocationSupported()) {\n            if (options.enableHighAccuracy) {\n                locateAccurate(options, onPositionReceived, onPositionError);\n            } else {\n                navigator.geolocation.getCurrentPosition(onPositionReceived, onPositionError, options);\n            }\n        } else {\n            let err = new GeoError(GeoError.Code.GEOLOCATION_NOT_SUPPORTED);\n            fallbackToIP(err);\n        }\n    }\n\n    /**\n     *  Returns a location and accuracy radius based on information about cell\n     *  towers and WiFi nodes that the mobile client can detect; via the Google\n     *  Maps Geolocation API.\n     *  @see {@link https://developers.google.com/maps/documentation/geolocation/intro|Google Maps Geolocation API}\n     *  @see {@link https://developers.google.com/maps/documentation/geolocation/usage-limits|Usage Limits}\n     *\n     *  @param {Object} [options]\n     *         Geolocation options.\n     *      @param {Number} [options.homeMobileCountryCode]\n     *             The mobile country code (MCC) for the device's home network.\n     *      @param {Number} [options.homeMobileNetworkCode]\n     *             The mobile network code (MNC) for the device's home network.\n     *      @param {String} [options.radioType]\n     *             The mobile radio type.\n     *             See {@link #geolocator.RadioType|`geolocator.RadioType` enumeration}\n     *             for possible values. While this field is optional, it should\n     *             be included if a value is available, for more accurate results.\n     *      @param {string} [options.carrier]\n     *             The carrier name. e.g. \"Vodafone\"\n     *      @param {Boolean} [options.fallbackToIP=false]\n     *             Specifies whether to fallback to IP geolocation if wifi and\n     *             cell tower signals are not available. Note that the IP address\n     *             in the request header may not be the IP of the device. Set\n     *             `fallbackToIP` to `false` to disable fall back.\n     *      @param {Array} [options.cellTowers]\n     *             An array of cell tower objects.\n     *             See {@link https://developers.google.com/maps/documentation/geolocation/intro#cell_tower_object|Cell tower objects} for details.\n     *      @param {Array} [options.wifiAccessPoints]\n     *             An array of WiFi access point objects.\n     *             See {@link https://developers.google.com/maps/documentation/geolocation/intro#wifi_access_point_object|WiFi access point objects} for details.\n     *      @param {Boolean} [options.addressLookup=false]\n     *             Specifies whether to run a reverse-geocode operation for the\n     *             fetched coordinates to retrieve detailed address information.\n     *             Note that this means an additional request which requires a\n     *             Google API key to be set in the Geolocator configuration.\n     *             See {@link #geolocator.config|`geolocator.config()`}.\n     *      @param {Boolean} [options.timezone=false]\n     *             Specifies whether to also fetch the time zone information for\n     *             the receieved coordinates. Note that this means an additional\n     *             request which requires a Google API key to be set in the\n     *             Geolocator configuration.\n     *             See {@link #geolocator.config|`geolocator.config()`}.\n     *      @param {String|MapOptions} [options.map]\n     *             In order to create an interactive map from the fetched\n     *             location coordinates; either set this to a\n     *             {@link #geolocator~MapOptions|`MapOptions` object}\n     *             or; the ID of a DOM element or DOM element itself which the\n     *             map will be created within.\n     *      @param {Boolean|Object} [options.staticMap=false]\n     *             Set to `true` to get a static Google Map image URL (with\n     *             default options); or pass a static map options object.\n     *      @param {Boolean} [options.raw=false]\n     *      \t      Whether to return the raw Google API result.\n     *  @param {Function} callback\n     *         Callback function to be executed when the request completes.\n     *         This takes 2 arguments: `function (err, location) { ... }`.\n     *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var options = {\n     *      homeMobileCountryCode: 310,\n     *      homeMobileNetworkCode: 410,\n     *      carrier: 'Vodafone',\n     *      radioType: geolocator.RadioType.GSM,\n     *      fallbackToIP: true,\n     *      addressLookup: false,\n     *      timezone: false,\n     *      map: \"my-map\",\n     *      staticMap: false\n     *  };\n     *  geolocator.locateByMobile(options, function (err, location) {\n     *      console.log(err || location);\n     *  });\n     */\n    static locateByMobile(options, callback) {\n        if (!utils.isPlainObject(options)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS);\n        }\n\n        let cb = callbackMap(options, callback);\n\n        options = utils.extend({\n            homeMobileCountryCode: undefined,\n            homeMobileNetworkCode: undefined,\n            radioType: undefined,\n            carrier: undefined,\n            fallbackToIP: false,\n            cellTowers: undefined,\n            wifiAccessPoints: undefined,\n            addressLookup: false,\n            timezone: false,\n            map: undefined,\n            raw: false\n        }, options);\n\n        options.considerIp = options.fallbackToIP;\n        // check Google key\n        checkGoogleKey();\n\n        let conf = geolocator._.config,\n            key = conf.google.key || '',\n            url = utils.setProtocol(enums.URL.GOOGLE_GEOLOCATION, conf.https),\n            xhrOpts = {\n                url: `${url}?key=${key}`,\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                data: JSON.stringify(options)\n            };\n        // console.log(xhrOpts.data);\n\n        fetch.post(xhrOpts, (err, xhr) => {\n            let response = getXHRResponse(err, xhr);\n            if (GeoError.isGeoError(response)) return cb(response, null);\n\n            response = options.raw ? response : {\n                coords: {\n                    latitude: response.location.lat,\n                    longitude: response.location.lng,\n                    accuracy: response.accuracy\n                },\n                timestamp: utils.time()\n            };\n\n            fetchAddressAndTimezone(response, options, cb);\n\n            // e.g. raw response\n            // {\n            //     \"location\": {\n            //         \"lat\": 51.0,\n            //         \"lng\": -0.1\n            //     },\n            //     \"accuracy\": 1200.4\n            // }\n        });\n    }\n\n    /**\n     *  Locates the user's location by the client's IP.\n     *\n     *  This method uses FreeGeoIP's lookup service, by default.\n     *  In order to change the source provider, you can use\n     *  {@link #geolocator.setGeoIPSource|`geolocator.setGeoIPSource()` method}.\n     *\n     *  @param {Object} [options]\n     *         Locate options.\n     *      @param {Boolean} [options.addressLookup=false]\n     *             Specifies whether to run a reverse-geocode operation for the\n     *             fetched coordinates to retrieve detailed address information.\n     *             Since no precise address can be fetched from an IP addres; you\n     *             should only enable this if the Geo-IP Source returns no useful\n     *             address information other than coordinates. Also, note that\n     *             this means an additional request which requires a Google API\n     *             key to be set in the Geolocator configuration.\n     *             See {@link #geolocator.config|`geolocator.config()`}.\n     *      @param {Boolean} [options.timezone=false]\n     *             Specifies whether to also fetch the time zone information for\n     *             the receieved coordinates. Note that this means an additional\n     *             request which requires a Google API key to be set in the\n     *             Geolocator configuration.\n     *             See {@link #geolocator.config|`geolocator.config()`}.\n     *      @param {String|MapOptions} [options.map]\n     *             In order to create an interactive map from the fetched\n     *             location coordinates; either set this to a\n     *             {@link #geolocator~MapOptions|`MapOptions` object}\n     *             or; the ID of a DOM element or DOM element itself which the\n     *             map will be created within.\n     *      @param {Boolean|Object} [options.staticMap=false]\n     *             Set to `true` to get a static Google Map image URL (with\n     *             default options); or pass a static map options object.\n     *  @param {Function} callback\n     *         Callback function to be executed when the request completes.\n     *         This takes 2 arguments: `function (err, location) { ... }`.\n     *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var options = {\n     *  \taddressLookup: true,\n     *  \ttimezone: true,\n     *  \tmap: \"my-map\",\n     *  \tstaticMap: true\n     *  };\n     *  geolocator.locateByIP(options, function (err, location) {\n     *  \tconsole.log(err || location);\n     *  });\n     *\n     *  @example\n     *  // location result:\n     *  {\n     *      coords: {\n     *          latitude: 41.0214,\n     *          longitude: 28.9948,\n     *      },\n     *      address: {\n     *          city: \"Istanbul\",\n     *          region: \"34\",\n     *          state: \"34\",\n     *          country: \"Turkey\",\n     *          countryCode: \"TR\"\n     *      },\n     *      formattedAddress: \"Demirtaş, Tesviyeci Sk. No:7, 34134 Fatih/İstanbul, Turkey\",\n     *      type: \"ROOFTOP\",\n     *      placeId: \"ChIJ-ZRLfO25yhQRBi5YJxX80Q0\",\n     *      timezone: {\n     *          id: \"Europe/Istanbul\",\n     *          name: \"Eastern European Summer Time\",\n     *          abbr: \"EEST\",\n     *          dstOffset: 3600,\n     *          rawOffset: 7200\n     *      },\n     *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/tr.svg\",\n     *      map: {\n     *          element: HTMLElement,\n     *          instance: Object, // google.maps.Map\n     *          marker: Object, // google.maps.Marker\n     *          infoWindow: Object, // google.maps.InfoWindow\n     *          options: Object // map options\n     *      },\n     *      staticMap: \"//maps.googleapis.com/maps/api/staticmap?center=41.0214,28.9948&maptype=roadmap&size=600x300&scale=1&zoom=9&format=png&language=en&markers=color%3Ared%7C41.0214%2C228.9948&key=YOUR-GOOGLE-API-KEY\",\n     *      provider: \"freegeoip\",\n     *      timestamp: 1466216325223\n     *  }\n     */\n    static locateByIP(options, callback) {\n        // passed source can be a string or object\n        let source = geolocator._.geoIpSource;\n\n        if (!utils.isPlainObject(source)) {\n            throw new GeoError(\n                GeoError.Code.INVALID_GEO_IP_SOURCE,\n                'Please set a valid Geo-IP Source via geolocator.setGeoIPSource(options).'\n            );\n        }\n\n        // check options and Google key\n        checkGoogleKey(options || {});\n\n        let jsonpOpts = {\n            url: source.url,\n            async: true,\n            clean: true\n            // params: {}\n        };\n        if (source.callbackParam) {\n            jsonpOpts.callbackParam = source.callbackParam;\n            jsonpOpts.rootName = 'geolocator._.cb';\n        } else if (!source.globalVar) {\n            throw new GeoError(\n                GeoError.Code.INVALID_GEO_IP_SOURCE,\n                'Either callbackParam or globalVar should be set for Geo-IP source.'\n            );\n        }\n        return fetch.jsonp(jsonpOpts, (err, response) => {\n            if (err) {\n                return callback(GeoError.create(err), null);\n            }\n            if (source.globalVar) {\n                if (window[source.globalVar]) {\n                    response = utils.clone(window[source.globalVar]);\n                    delete window[source.globalVar];\n                } else {\n                    response = null;\n                }\n            }\n            if (!response) {\n                err = new GeoError(GeoError.Code.INVALID_RESPONSE);\n                return callback(err, null);\n            }\n            if (utils.isPlainObject(source.schema)) {\n                response = utils.mapToSchema(response, source.schema);\n            }\n            response.provider = source.provider || 'unknown';\n            setLocationURLs(response, options);\n            if (response.coords) {\n                response.coords.latitude = Number(response.coords.latitude);\n                response.coords.longitude = Number(response.coords.longitude);\n            }\n            let cb = callbackMap(options, callback);\n            fetchAddressAndTimezone(response, options, cb);\n        });\n    }\n\n    /**\n     *  Sets the Geo-IP source to be used for fetching location information\n     *  by user's IP; which is internally used by\n     *  {@link #geolocator.locateByIP|`geolocator.locateByIP()` method}.\n     *\n     *  By default, Geolocator uses FreeGeoIP as the Geo-IP source provider.\n     *  You can use this method to change this; or you can choose from\n     *  ready-to-use\n     *  {@link https://github.com/onury/geolocator/tree/master/src/geo-ip-sources|Geo-IP sources}.\n     *\n     *  @param {Object} options\n     *         Geo-IP Source options.\n     *      @param {String} [options.provider]\n     *             Source or service provider's name.\n     *      @param {String} options.url\n     *             Source URL without the callback query parameter. The callback\n     *             name (if supported) should be set via `options.callbackParam`.\n     *             Also, make sure the service supports the protocol you use in\n     *             the enums.URL. If it supports both HTTP and HTTPS, you can omit the\n     *             protocol. In this case, it will be determined via Geolocator\n     *             configuration.\n     *             See {@link #geolocator.config|`geolocator.config()`}.\n     *             NOTE: Do not forget to include your API key in the query\n     *             parameters of the URL, if you have one.\n     *      @param {String} [options.callbackParam]\n     *             If JSON callback is supported, pass the name of the callback\n     *             parameter, defined by the provider.\n     *      @param {Object} [options.globalVar]\n     *             Set this instead of `options.callbackParam` if the service\n     *             does not support JSON callbacks, but weirdly set a global\n     *             variable in the document. For example, if the response is\n     *             `Geo = { lat, lng }`, you should set this to `\"Geo\"`.\n     *      @param {Object} [options.schema]\n     *             Schema object to be used to re-structure the response returned\n     *             from the service. Set the response object's keys as values of\n     *             a custom object to map the format to the `location` object.\n     *             For example; if the service returns a response like\n     *             `{ lat: 40.112233, lng: 10.112233, otherProp: 'hello' }`.\n     *             Then you should set the following schema:\n     *             `{ coords: { latitude: 'lat', longitude: 'lng' } }`.\n     *\n     *  @return {geolocator}\n     */\n    static setGeoIPSource(options) {\n        if (!utils.isPlainObject(options)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS, 'Geo-IP source options is invalid.');\n        }\n        if (!utils.isStringSet(options.url)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS, 'Geo-IP source should have a valid URI.');\n        }\n        // if (!utils.isStringSet(options.callbackParam) && !utils.isStringSet(options.globalVar)) {\n        //     throw new GeoError(GeoError.Code.INVALID_PARAMETERS, 'No \\'callbackParam\\' or \\'globalVar\\' is provided for the Geo-IP Source options.');\n        // }\n        geolocator._.geoIpSource = Object.freeze(options);\n    }\n\n    /**\n     *  Registers a handler for watching the user's location via HTML5\n     *  geolocation; that is triggered each time the position of the device\n     *  changes. This may require/prompt for user's permission.\n     *\n     *  @param {Object} [options]\n     *         HTML5 geo-location settings.\n     *      @param {Boolean} [options.enableHighAccuracy=true]\n     *             Specifies whether the device should provide the most accurate\n     *             position it can. Note that setting this to `true` might consume\n     *             more CPU and/or battery power; and result in slower response\n     *             times.\n     *      @param {Number} [options.timeout=6000]\n     *             HTML5 position timeout setting in milliseconds. Setting this\n     *             to `Infinity` means that Geolocator won't return until the\n     *             position is available.\n     *      @param {Number} [options.maximumAge=0]\n     *             HTML5 position maximum age. Indicates the maximum age in\n     *             milliseconds of a possible cached position that is acceptable\n     *             to return. `0` means, the device cannot use a cached position\n     *             and must attempt to retrieve the real current position. If set\n     *             to `Infinity` the device must return a cached position\n     *             regardless of its age.\n     *      @param {Boolean} [options.clearOnError=false]\n     *             Specifies whether to clear the watcher on first error so that\n     *             it does not execute any more callbacks.\n     *      @param {Object} [options.target]\n     *             Object that defines the target location and settings; that\n     *             when the location is reached, the watcher will auto-clear\n     *             itself and invoke the callback.\n     *      @param {Number} options.target.latitude\n     *             The `latitude` of the target location.\n     *      @param {Number} options.target.longitude\n     *             The `longitude` of the target location.\n     *      @param {Number} [options.target.radius=0.5]\n     *             The radius, in other words; the minimum distance (in\n     *             kilometers or miles) to the target point that should be\n     *             reached.\n     *      @param {Number} [options.target.unitSystem=0]\n     *             Unit system to be used for target radius.\n     *             See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}\n     *             for possible values.\n     *  @param {Function} callback\n     *         Callback function to be executed when the request completes.\n     *         This takes 2 arguments: `function (err, location) { ... }`.\n     *         If `options.target` is set, `location` will also\n     *         include a `targetReached:Boolean` property.\n     *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     *  @returns {GeoWatcher} - A watcher object that provides a\n     *  `.clear(delay:Number, callback:Function)` method to clear the watcher\n     *  when needed. Optional `delay` argument can be set (in milliseconds) to\n     *  clear in a later time. Omitting this argument will clear the watcher\n     *  immediately. You should always call this method, except if you've set up\n     *  a target; which will auto-clear the watcher when reached.\n     *\n     *  @example\n     *  // Watch my position for 5 minutes.\n     *  var options = { enableHighAccuracy: true, timeout: 6000, maximumAge: 0 };\n     *  var watcher = geolocator.watch(options, function (err, location) {\n     *      console.log(err || location);\n     *  });\n     *  console.log(watcher.id); // ID of the watcher\n     *  watcher.clear(300000); // clear after 5 minutes.\n     *\n     *  @example\n     *  // Watch my position until I'm 350 meters near Disneyland Park.\n     *  options.target = {\n     *      latitude: 33.8120918,\n     *      longitude: -117.9233569,\n     *      radius: 0.35,\n     *      unitSystem: geolocator.UnitSystem.METRIC\n     *  };\n     *  watcher = geolocator.watch(options, function (err, location) {\n     *      if (err) {\n     *          console.log(err);\n     *          return;\n     *      }\n     *      if (location.targetReached) {\n     *          console.log(watcher.isCleared); // true\n     *          console.log(watcher.cycle); // 15 — target reached after 15 cycles\n     *      } else {\n     *          console.log(watcher.isCleared); // false — watcher is active.\n     *      }\n     *  });\n     */\n    static watch(options, callback) {\n        if (!geolocator.isGeolocationSupported()) {\n            callback(new GeoError(GeoError.Code.GEOLOCATION_NOT_SUPPORTED), null);\n            return {};\n        }\n\n        let watcher, target;\n\n        options = utils.extend({\n            enableHighAccuracy: true,\n            timeout: 6000,\n            maximumAge: 0,\n            clearOnError: false\n        }, options);\n\n        if (utils.isPlainObject(options.target)) {\n            target = utils.extend({\n                radius: 0.5,\n                unitSystem: geolocator.UnitSystem.METRIC\n            }, options.target);\n        }\n\n        function onPositionChanged(location) {\n            let pos = utils.clone(location, { own: false });\n            if (target) {\n                let distance = geolocator.calcDistance({\n                    from: location.coords,\n                    to: target,\n                    formula: geolocator.DistanceFormula.HAVERSINE,\n                    unitSystem: target.unitSystem\n                });\n                pos.targetReached = distance <= target.radius;\n                if (watcher && pos.targetReached) {\n                    watcher.clear(() => {\n                        return callback(null, pos);\n                    });\n                }\n            }\n            return callback(null, pos);\n        }\n        function onPositionError(err) {\n            callback(GeoError.create(err), null);\n        }\n        return new GeoWatcher(onPositionChanged, onPositionError, options);\n    }\n\n    /**\n     *  Converts a given address (or address components) into geographic\n     *  coordinates (i.e. latitude, longitude); and gets detailed address\n     *  information.\n     *  @see {@link https://developers.google.com/maps/documentation/geocoding/intro|Google Maps Geocoding API}\n     *  @see {@link https://developers.google.com/maps/documentation/geocoding/usage-limits|Usage Limits}\n     *\n     *  @param {String|Object} options\n     *         Either the address to geocode or geocoding options with the\n     *         following properties.\n     *      @param {String} options.address\n     *             The street address to geocode, in the format used by the\n     *             national postal service of the country concerned. Additional\n     *             address elements such as business names and unit, suite or\n     *             floor numbers should be avoided. Note that any address\n     *             component (route, locality, administrativeArea, postalCode and\n     *             country) should be specified either in address or the\n     *             corresponding property - not both. Doing so may result in\n     *             `ZERO_RESULTS`.\n     *      @param {String} [options.route]\n     *      \t      Long or short name of a route.\n     *      @param {String} [options.locality]\n     *      \t      Locality and sublocality of the location.\n     *      @param {String} [options.administrativeArea]\n     *      \t      Administrative area of the location.\n     *      @param {String} [options.postalCode]\n     *      \t      Postal code of the location.\n     *      @param {String} [options.country]\n     *      \t      A country name or a two letter ISO 3166-1 country code.\n     *      @param {String} [options.region]\n     *      \t      The region code, specified as a ccTLD (\"top-level domain\")\n     *      \t      two-character value. e.g.: `\"fr\"` for France.\n     *      @param {Array|Object} [options.bounds]\n     *      \t      The bounding box of the viewport within which to bias geocode\n     *      \t      results more prominently. e.g.:\n     *      \t      `[ southwestLat:Number, southwestLng:Number, northeastLat:Number, northeastLng:Number ]`\n     *      @param {String|MapOptions} [options.map]\n     *             In order to create an interactive map from the fetched\n     *             location coordinates; either set this to a\n     *             {@link #geolocator~MapOptions|`MapOptions` object}\n     *             or; the ID of a DOM element or DOM element itself which the\n     *             map will be created within.\n     *      @param {Boolean|Object} [options.staticMap=false]\n     *             Set to `true` to get a static Google Map image URL (with\n     *             default options); or pass a static map options object.\n     *      @param {Boolean} [options.raw=false]\n     *      \t      Whether to return the raw Google API result.\n     *  @param {Function} callback\n     *         Callback function to be executed when the request completes.\n     *         This takes 2 arguments: `function (err, location) { ... }`.\n     *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var address = '1600 Amphitheatre Parkway, CA';\n     *  geolocator.geocode(address, function (err, location) {\n     *      console.log(err || location);\n     *  });\n     *\n     *  @example\n     *  // location result:\n     *  {\n     *      coords: {\n     *          latitude: 37.4224764,\n     *          longitude: -122.0842499\n     *      },\n     *      address: {\n     *          commonName: \"\",\n     *          street: \"Amphitheatre Pkwy\",\n     *          route: \"Amphitheatre Pkwy\",\n     *          streetNumber: \"1600\",\n     *          neighborhood: \"\",\n     *          town: \"\",\n     *          city: \"Mountain View\",\n     *          region: \"Santa Clara County\",\n     *          state: \"California\",\n     *          stateCode: \"CA\",\n     *          postalCode: \"94043\",\n     *          country: \"United States\",\n     *          countryCode: \"US\"\n     *      },\n     *      formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n     *      type: \"ROOFTOP\",\n     *      placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n     *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n     *      map: {\n     *          element: HTMLElement,\n     *          instance: Object, // google.maps.Map\n     *          marker: Object, // google.maps.Marker\n     *          infoWindow: Object, // google.maps.InfoWindow\n     *          options: Object // map options\n     *      },\n     *      timestamp: 1456795956380\n     *  }\n     */\n    static geocode(options, callback) {\n        geocode(false, options, callback);\n    }\n\n    /**\n     *  Converts the given geographic coordinates into a human-readable address\n     *  information.\n     *  @see {@link https://developers.google.com/maps/documentation/geocoding/intro#ReverseGeocoding|Google Maps (Reverse) Geocoding API}\n     *  @see {@link https://developers.google.com/maps/documentation/geocoding/usage-limits|Usage Limits}\n     *  @alias geolocator.addressLookup\n     *\n     *  @param {Object|String} options\n     *         Either the `placeId` of the location or Reverse Geocoding options\n     *         with the following properties.\n     *      @param {Number} options.latitude\n     *      Latitude of the target location.\n     *      @param {Number} options.longitude\n     *      Longitude of the target location.\n     *      @param {String} [options.placeId]\n     *             Required if `latitude` and `longitude` are omitted. The place\n     *             ID of the place for which you wish to obtain the\n     *             human-readable address. The place ID is a unique identifier\n     *             that can be used with other Google APIs. Note that if\n     *             `placeId` is set, `latitude` and `longitude` are ignored.\n     *      @param {String|MapOptions} [options.map]\n     *             In order to create an interactive map from the fetched\n     *             location coordinates; either set this to a\n     *             {@link #geolocator~MapOptions|`MapOptions` object}\n     *             or; the ID of a DOM element or DOM element itself which the\n     *             map will be created within.\n     *      @param {Boolean|Object} [options.staticMap=false]\n     *             Set to `true` to get a static Google Map image URL (with\n     *             default options); or pass a static map options object.\n     *      @param {Boolean} [options.raw=false]\n     *             Whether to return the raw Google API result.\n     *  @param {Function} callback\n     *         Callback function to be executed when the request completes.\n     *         This takes 2 arguments: `function (err, location) { ... }`\n     *         See {@link #geolocator~Location|`geolocator~Location` type} for details.\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var coords = {\n     *      latitude: 37.4224764,\n     *      longitude: -122.0842499\n     *  };\n     *\n     *  geolocator.reverseGeocode(coords, function (err, location) {\n     *      console.log(err || location);\n     *  });\n     *\n     *  @example\n     *  // location result:\n     *  {\n     *      coords: {\n     *          latitude: 37.4224764,\n     *          longitude: -122.0842499\n     *      },\n     *      address: {\n     *          commonName: \"\",\n     *          street: \"Amphitheatre Pkwy\",\n     *          route: \"Amphitheatre Pkwy\",\n     *          streetNumber: \"1600\",\n     *          neighborhood: \"\",\n     *          town: \"\",\n     *          city: \"Mountain View\",\n     *          region: \"Santa Clara County\",\n     *          state: \"California\",\n     *          stateCode: \"CA\",\n     *          postalCode: \"94043\",\n     *          country: \"United States\",\n     *          countryCode: \"US\"\n     *      },\n     *      formattedAddress: \"1600 Amphitheatre Parkway, Mountain View, CA 94043, USA\",\n     *      type: \"ROOFTOP\",\n     *      placeId: \"ChIJ2eUgeAK6j4ARbn5u_wAGqWA\",\n     *      flag: \"//cdnjs.cloudflare.com/ajax/libs/flag-icon-css/2.3.1/flags/4x3/us.svg\",\n     *      map: {\n     *          element: HTMLElement,\n     *          instance: Object, // google.maps.Map\n     *          marker: Object, // google.maps.Marker\n     *          infoWindow: Object, // google.maps.InfoWindow\n     *          options: Object // map options\n     *      },\n     *      timestamp: 1456795956380\n     *  }\n     */\n    static reverseGeocode(options, callback) {\n        geocode(true, options, callback);\n    }\n\n    /**\n     *  Alias for `geolocator.reverseGeocode`\n     *  @private\n     */\n    static addressLookup(options, callback) {\n        geolocator.reverseGeocode(options, callback);\n    }\n\n    /**\n     *  Gets timezone information for the given coordinates.\n     *  Note: Google Browser API keys cannot have referer restrictions when used with this API.\n     *  @see {@link https://developers.google.com/maps/documentation/timezone/intro|Google Maps TimeZone API}\n     *  @see {@link https://developers.google.com/maps/documentation/timezone/usage-limits|Usage Limits}\n     *\n     *  @param {Object} options\n     *         Time zone options.\n     *      @param {Number} options.latitude\n     *             Latitude of location.\n     *      @param {Number} options.longitude\n     *             Longitude of location.\n     *      @param {Number} [options.timestamp=Date.now()]\n     *             Specifies the desired time as seconds since midnight, January\n     *             1, 1970 UTC. This is used to determine whether or not Daylight\n     *             Savings should be applied.\n     *      @param {Boolean} [options.raw=false]\n     *             Whether to return the raw Google API result.\n     *  @param {Function} callback\n     *         Callback function to be executed when the request completes, in\n     *         the following signature: `function (err, timezone) { ... }`.\n     *         See {@link #geolocator~TimeZone|`geolocator~TimeZone` type} for\n     *         details.\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var options = {\n     *      latitude: 48.8534100,\n     *      longitude: 2.3488000\n     *  };\n     *  geolocator.getTimeZone(options, function (err, timezone) {\n     *      console.log(err || timezone);\n     *  });\n     *\n     *  @example\n     *  // timezone result:\n     *  {\n     *      id: \"Europe/Paris\",\n     *      name: \"Central European Standard Time\",\n     *      abbr: \"CEST\",\n     *      dstOffset: 0,\n     *      rawOffset: 3600,\n     *      timestamp: 1455733120\n     *  }\n     */\n    static getTimeZone(options, callback) {\n        if (!utils.isPlainObject(options)\n                || !utils.isNumber(options.latitude)\n                || !utils.isNumber(options.longitude)) {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS);\n        }\n\n        checkGoogleKey();\n\n        let conf = geolocator._.config;\n        options = utils.extend({\n            key: conf.google.key || '',\n            language: conf.language || 'en',\n            timestamp: utils.time(true),\n            raw: false\n        }, options);\n\n        let url = utils.setProtocol(enums.URL.GOOGLE_TIMEZONE, conf.https),\n            xhrOpts = {\n                url: `${url}?location=${options.latitude},${options.longitude}&timestamp=${options.timestamp}&language=${options.language}&key=${options.key}`\n            };\n\n        fetch.xhr(xhrOpts, (err, xhr) => {\n            let response = getXHRResponse(err, xhr);\n            if (GeoError.isGeoError(response)) return callback(response, null);\n\n            response = options.raw ? response : {\n                id: response.timeZoneId,\n                name: response.timeZoneName,\n                abbr: utils.abbr(response.timeZoneName, { dots: false }),\n                dstOffset: response.dstOffset,\n                rawOffset: response.rawOffset,\n                timestamp: options.timestamp\n            };\n            callback(err, response);\n        });\n    }\n\n    /**\n     *  Gets the distance and duration values based on the recommended route\n     *  between start and end points.\n     *  @see {@link https://developers.google.com/maps/documentation/distance-matrix/intro|Google Maps Distance Matrix API}\n     *  @see {@link https://developers.google.com/maps/documentation/distance-matrix/usage-limits|Usage Limits}\n     *\n     *  @param {Object} options\n     *         Distance matrix options.\n     *      @param {String|Object|Array} options.origins\n     *             One or more addresses and/or an object of latitude/longitude\n     *             values, from which to calculate distance and time. If you pass\n     *             an address as a string, the service will geocode the string\n     *             and convert it to a latitude/longitude coordinate to calculate\n     *             distances. Following are valid examples:\n     *  <pre><code>options.origins = 'London';\n     *  options.origins = ['London', 'Paris'];\n     *  options.origins = { latitude: 51.5085300, longitude: -0.1257400 };\n     *  options.origins = [\n     *      { latitude: 51.5085300, longitude: -0.1257400 },\n     *      { latitude: 48.8534100, longitude: 2.3488000 }\n     *  ];\n     *  </code></pre>\n     *      @param {String|Object|Array} options.destinations\n     *             One or more addresses and/or an object of latitude/longitude\n     *             values, from which to calculate distance and time. If you pass\n     *             an address as a string, the service will geocode the string\n     *             and convert it to a latitude/longitude coordinate to calculate\n     *             distances.\n     *      @param {String} [options.travelMode=\"DRIVING\"]\n     *             Type of routing requested.\n     *             See {@link #geolocator.TravelMode|`geolocator.TravelMode` enumeration}\n     *             for possible values.\n     *      @param {Boolean} [options.avoidFerries]\n     *             If true, instructs the Distance Matrix service to avoid\n     *             ferries where possible.\n     *      @param {Boolean} [options.avoidHighways]\n     *             If true, instructs the Distance Matrix service to avoid\n     *             highways where possible.\n     *      @param {Boolean} [options.avoidTolls]\n     *             If true, instructs the Distance Matrix service to avoid toll\n     *             roads where possible.\n     *      @param {Number} [options.unitSystem=0]\n     *             Preferred unit system to use when displaying distance.\n     *             See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}\n     *             for possible values.\n     *      @param {String} [options.region]\n     *             Region code used as a bias for geocoding requests.\n     *  @param {Boolean} [options.raw=false]\n     *         Whether to return the raw Google API result.\n     *  @param {Function} callback\n     *         Callback function to be executed when the request completes,\n     *         in the following signature: `function (err, result) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  var options = {\n     *      origins: [{ latitude: 51.5085300, longitude: -0.1257400 }],\n     *      destinations: [{ latitude: 48.8534100, longitude: 2.3488000 }],\n     *      travelMode: geolocator.TravelMode.DRIVING,\n     *      unitSystem: geolocator.UnitSystem.METRIC\n     *  };\n     *  geolocator.getDistanceMatrix(options, function (err, result) {\n     *      console.log(err || result);\n     *  });\n     *\n     *  @example\n     *  // result:\n     *  [\n     *  \t{\n     *  \t\tfrom: \"449 Duncannon St, London WC2R 0DZ, UK\",\n     *  \t\tto: \"1 Parvis Notre-Dame - Pl. Jean-Paul II, 75004 Paris-4E-Arrondissement, France\",\n     *  \t\tdistance: {\n     *  \t\t\tvalue: 475104,\n     *  \t\t\ttext: \"475 km\"\n     *  \t\t},\n     *  \t\tduration: {\n     *  \t\t\tvalue: 20193,\n     *  \t\t\ttext: \"5 hours 37 mins\"\n     *  \t\t},\n     *  \t\tfare: undefined,\n     *  \t\ttimestamp: 1456795956380\n     *  \t}\n     *  ]\n     */\n    static getDistanceMatrix(options, callback) {\n        checkGoogleKey();\n\n        let key = geolocator._.config.google.key;\n        geolocator.ensureGoogleLoaded(key, err => {\n            if (err) {\n                throw new GeoError(GeoError.Code.GOOGLE_API_FAILED, String(err.message || err));\n            }\n\n            let o = options.origins || options.origin || options.from,\n                d = options.destinations || options.destination || options.to;\n            if (!utils.isPlainObject(options) || invalidOriginOrDest(o) || invalidOriginOrDest(d)) {\n                throw new GeoError(GeoError.Code.INVALID_PARAMETERS);\n            }\n            options.origins = geoHelper.toPointList(o);\n            options.destinations = geoHelper.toPointList(d);\n\n            options = utils.extend({\n                travelMode: google.maps.TravelMode.DRIVING,\n                avoidFerries: undefined,\n                avoidHighways: undefined,\n                avoidTolls: undefined,\n                unitSystem: google.maps.UnitSystem.METRIC\n            }, options);\n\n            let service = new google.maps.DistanceMatrixService();\n            service.getDistanceMatrix(options, (response, status) => {\n                let err = null;\n                if (status !== google.maps.DistanceMatrixStatus.OK) {\n                    err = GeoError.fromResponse(status)\n                        || GeoError.fromResponse(response);\n                    response = null;\n                } else {\n                    response = options.raw ? response : geoHelper.formatDistanceResults(response);\n                }\n                callback(err, response);\n            });\n        });\n    }\n\n    /**\n     *  Calculates the distance between two geographic points.\n     *\n     *  @param {Object} options\n     *         Calculation and display options.\n     *      @param {Object} options.from\n     *             Object containing the `latitude` and `longitude` of original\n     *             location.\n     *      @param {Object} options.to\n     *             Object containing the `latitude` and `longitude` of destination.\n     *      @param {String} [options.formula=\"haversine\"]\n     *             The algorithm or formula to calculate the distance.\n     *             See {@link #geolocator.DistanceFormula|`geolocator.DistanceFormula` enumeration}.\n     *      @param {Number} [options.unitSystem=0]\n     *             Preferred unit system to use when displaying distance.\n     *             See {@link #geolocator.UnitSystem|`geolocator.UnitSystem` enumeration}.\n     *\n     *  @returns {Number} - The calculated distance.\n     *\n     *  @example\n     *  // Calculate distance from London to Paris.\n     *  var result = geolocator.calcDistance({\n     *      from: {\n     *          latitude: 51.5085300,\n     *          longitude: -0.1257400\n     *      },\n     *      to: {\n     *          latitude: 48.8534100,\n     *          longitude: 2.3488000\n     *      },\n     *      formula: geolocator.DistanceFormula.HAVERSINE,\n     *      unitSystem: geolocator.UnitSystem.METRIC\n     *  });\n     *  // result: 366.41656039126093 (kilometers)\n     */\n    static calcDistance(options) {\n        options = utils.extend({\n            formula: geolocator.DistanceFormula.HAVERSINE,\n            unitSystem: geolocator.UnitSystem.METRIC\n        }, options);\n\n        let from = options.from,\n            to = options.to,\n            radius = options.unitSystem === geolocator.UnitSystem.METRIC\n                ? EARTH_RADIUS_KM : EARTH_RADIUS_MI;\n\n        if (options.formula === geolocator.DistanceFormula.HAVERSINE) {\n            let dLat = geolocator.degToRad(to.latitude - from.latitude),\n                dLng = geolocator.degToRad(to.longitude - from.longitude),\n                a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                    Math.cos(geolocator.degToRad(from.latitude)) *\n                    Math.cos(geolocator.degToRad(to.longitude)) *\n                    Math.sin(dLng / 2) * Math.sin(dLng / 2),\n                c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n            return radius * c;\n        }\n        // geolocator.DistanceFormula.PYTHAGOREAN\n        let latA = geolocator.degToRad(from.latitude),\n            latB = geolocator.degToRad(to.latitude),\n            lngA = geolocator.degToRad(from.longitude),\n            lngB = geolocator.degToRad(to.longitude),\n            x = (lngB - lngA) * Math.cos((latA + latB) / 2),\n            y = (latB - latA);\n        return Math.sqrt(x * x + y * y) * radius;\n    }\n\n    /**\n     *  Gets the current public IP of the client.\n     *\n     *  @param {Function} callback\n     *         Callback function to be executed when the request completes, in\n     *         the following signature: `function (err, result) { ... }`\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  geolocator.getIP(function (err, result) {\n     *      console.log(err || result);\n     *  });\n     *\n     *  @example\n     *  // result:\n     *  {\n     *      ip: \"176.232.71.155\",\n     *      timestamp: 1457573683427\n     *  }\n     */\n    static getIP(callback) {\n        let conf = geolocator._.config;\n\n        let jsonpOpts = {\n            url: utils.setProtocol(enums.URL.IP, conf.https),\n            async: true,\n            clean: true,\n            params: {\n                format: 'jsonp'\n            },\n            callbackParam: 'callback',\n            rootName: 'geolocator._.cb'\n        };\n        return fetch.jsonp(jsonpOpts, (err, response) => {\n            if (err) {\n                return callback(GeoError.create(err), null);\n            }\n            if (!response) {\n                err = new GeoError(GeoError.Code.INVALID_RESPONSE);\n                return callback(err, null);\n            }\n            if (typeof response === 'object') response.timestamp = utils.time();\n            callback(null, response);\n        });\n    }\n\n    /**\n     *  Ensures Google Maps API is loaded. If not, this will load all of the\n     *  main Javascript objects and symbols for use in the Maps API.\n     *\n     *  Note that, Google Maps API is loaded only when needed. For example,\n     *  the DistanceMatrix API does not support Web Service requests and\n     *  requires this API to be loaded. However, the TimeZone API requests are\n     *  made throught the Web Service without requiring a `google` object\n     *  within DOM.\n     *\n     *  Also note that this will not re-load the API if `google.maps` object\n     *  already exists. In this case, the `callback` is still executed and\n     *  no errors are passed.\n     *\n     *  You can use the following overload to omit the `key` argument altogether:\n     *\n     *  `geolocator.ensureGoogleLoaded(callback)`\n     *\n     *  @param {String} [key]\n     *         Google API key.\n     *  @param {Function} callback\n     *         Callback function to be executed when the operation ends.\n     *\n     *  @returns {void}\n     *\n     *  @example\n     *  geolocator.ensureGoogleLoaded(function (err) {\n     *      if (err) return;\n     *      console.log('google' in window); // true\n     *  });\n     */\n    static ensureGoogleLoaded(key, callback) {\n        let k;\n        if (utils.isFunction(key)) {\n            callback = key;\n        } else {\n            k = key;\n        }\n        if (!geolocator.isGoogleLoaded()) {\n            let jsonpOpts = {\n                url: enums.URL.GOOGLE_MAPS_API,\n                async: true,\n                callbackParam: 'callback',\n                params: {\n                    key: k || ''\n                    // callback: ''\n                },\n                rootName: 'geolocator._.cb'\n            };\n            return fetch.jsonp(jsonpOpts, callback);\n        }\n        callback();\n    }\n\n    /**\n     *  Checks whether the Google Maps API is loaded.\n     *\n     *  @returns {Boolean} - Returns `true` if already loaded.\n     */\n    static isGoogleLoaded() {\n        return ('google' in window) && google.maps;\n    }\n\n    /**\n     *  Checks whether the type of the given object is an HTML5 `PositionError`.\n     *\n     *  @param {*} obj - Object to be checked.\n     *  @return {Boolean}\n     */\n    static isPositionError(obj) {\n        return utils.isPositionError(obj);\n    }\n\n    /**\n     *  Checks whether the given value is an instance of `GeoError`.\n     *\n     *  @param {*} obj - Object to be checked.\n     *  @return {Boolean}\n     */\n    static isGeoError(obj) {\n        return GeoError.isGeoError(obj);\n    }\n\n    /**\n     *  Checks whether HTML5 Geolocation API is supported.\n     *\n     *  @return {Boolean}\n     */\n    static isGeolocationSupported() {\n        return navigator && ('geolocation' in navigator);\n    }\n\n    /**\n     *  Converts kilometers to miles.\n     *\n     *  @param {Number} km - Kilometers to be converted.\n     *  @returns {Number} - Miles.\n     */\n    static kmToMi(km) {\n        return km * 0.621371;\n    }\n\n    /**\n     *  Converts miles to kilometers.\n     *\n     *  @param {Number} mi - Miles to be converted.\n     *  @returns {Number} - Kilometers.\n     */\n    static miToKm(mi) {\n        return mi / 0.621371;\n    }\n\n    /**\n     *  Converts degrees to radians.\n     *\n     *  @param {Number} deg - Degrees to be converted.\n     *  @returns {Number} - Radians.\n     */\n    static degToRad(degrees) {\n        return degrees * (Math.PI / 180);\n    }\n\n    /**\n     *  Converts radians to degrees.\n     *\n     *  @param {Number} rad - Radians to be converted.\n     *  @returns {Number} - Degrees.\n     */\n    static radToDeg(radians) {\n        return radians * (180 / Math.PI);\n    }\n\n    /**\n     *  Converts decimal coordinates (either lat or lng) to degrees, minutes, seconds.\n     *\n     *  @param {Number} dec\n     *         Decimals to be converted.\n     *  @param {Boolean} [isLng=false]\n     *         Indicates whether the given decimals is longitude.\n     *\n     *  @returns {String} - Degrees, minutes, seconds.\n     */\n    static decToDegMinSec(dec, isLng = false) {\n        // Degrees Latitude must be in the range of -90. to 90.\n        // Degrees Longitude must be in the range of -180 to 180.\n        // +Latitude is North, -Latitude is South\n        // +Longitude is East, -Longitude is West\n        let sign = dec < 0 ? -1 : 1,\n            sn = dec < 0 ? 'S' : 'N',\n            we = dec < 0 ? 'W' : 'E',\n            nsew = !isLng ? sn : we,\n            absValue = Math.abs(Math.round(dec * 1000000.0));\n        return ((Math.floor(absValue / 1000000) * sign) + '° ' + Math.floor(((absValue / 1000000) - Math.floor(absValue / 1000000)) * 60) + '\\' ' +\n                (Math.floor(((((absValue / 1000000) - Math.floor(absValue / 1000000)) * 60) - Math.floor(((absValue / 1000000) - Math.floor(absValue / 1000000)) * 60)) * 100000) * 60 / 100000) + '\" ') + nsew;\n    }\n\n}\n\n// ---------------------------\n// HELPER METHODS\n// ---------------------------\n\n/**\n *  Used with distance matrix calls.\n *  @private\n */\nfunction invalidOriginOrDest(value) {\n    return !utils.isString(value)\n        && !utils.isArray(value)\n        && !utils.isPlainObject(value);\n}\n\n/**\n *  Check if XHR response is an error response and returns a `GeoError`.\n *  If not, returns the parsed response.\n *  @private\n *\n *  @param {Error} err\n *         XHR error.\n *  @param {Object} xhr\n *         XHR object to be checked.\n *\n *  @returns {GeoError|Object}\n */\nfunction getXHRResponse(err, xhr) {\n    if (err) return GeoError.create(err);\n    if (!xhr) return new GeoError(GeoError.Code.REQUEST_FAILED);\n    let response = utils.safeJsonParse(xhr.responseText);\n    // Check if XHR response is an error response.\n    // return response if not.\n    return GeoError.fromResponse(response) || response;\n}\n\n/**\n *  Checks the given options and determines if Google key is required.\n *  Throws if key is required but not set or valid.\n *  @private\n *\n *  @param {Object} [options]\n *         Options to be checked. If `undefined`, directly checks Googke key.\n */\nfunction checkGoogleKey(options) {\n    if (!options || (options.addressLookup || options.timezone || options.map || options.staticMap)) {\n        if (!geolocator._.config.google.key) {\n            throw new GeoError(GeoError.Code.GOOGLE_KEY_INVALID, 'A Google API key is required but it\\'s not set or valid.');\n        }\n    }\n}\n\n/**\n *  Checks and adds necessary properties to map options from the given location\n *  result object. This is used with methods that support `map` option; to\n *  create a map from the result coordinates; such as locate() method.\n *  @private\n *\n *  @param {Object|String} options\n *         Original options object.\n *  @param {Object} location\n *         Location result object.\n *\n *  @returns {Object} - Final map options object.\n */\nfunction getMapOpts(mapOptions, location) {\n    if (utils.isObject(mapOptions)) {\n        mapOptions.center = location.coords;\n    } else {\n        mapOptions = {\n            element: mapOptions,\n            center: location.coords\n        };\n    }\n    // this will enable infoWindow\n    if (location.formattedAddress) {\n        mapOptions.title = location.formattedAddress;\n    }\n    // if location has accuracy, (and zoom is not set) we can zoom in a bit more\n    if (!mapOptions.zoom\n            && location.coords\n            && utils.isNumber(location.coords.accuracy)\n            && location.coords.accuracy < 1500) {\n        mapOptions.zoom = 15;\n    }\n    return mapOptions;\n}\n\n/**\n *  Checks the HTMLElement to see whether a previous map and related objects\n *  (marker, infoWindow) are created for it; by checking our private property\n *  `_geolocatorMapData`. If there is a map, this does not re-create it (which\n *  will break the map) but only re-adjust center, zoom and re-create the marker\n *  if needed. We use this approach bec. Google maps has no feature to destroy\n *  a map. This is considered a bug by Google developers.\n *  @private\n *\n *  @param {Object} options\n *         Options for creating a map.\n */\nfunction configCreateMap(options) {\n    let elem = options.element,\n        // when geolocator creates a map, it will set a `_geolocatorMapData`\n        // property on the element. So we can use this map instance later,\n        // when the same HTMLElement is passed to create a map. So check if\n        // we have it here.\n        mapData = elem._geolocatorMapData,\n        map = (mapData && mapData.instance) || null,\n        marker = (mapData && mapData.marker) || null,\n        infoWindow = (mapData && mapData.infoWindow) || null,\n        center = new google.maps.LatLng(options.center.latitude, options.center.longitude),\n        mapOptions = {\n            mapTypeId: options.mapTypeId,\n            center: center,\n            zoom: options.zoom,\n            styles: options.styles || null\n        };\n\n    // if we have a map, we'll just configure it. otherwise, we'll create\n    // one.\n    if (map) {\n        map.setOptions(mapOptions);\n    } else {\n        map = new google.maps.Map(options.element, mapOptions);\n    }\n\n    // destroy marker and infoWindow if previously created for this element.\n    if (infoWindow) infoWindow = null;\n    if (marker && marker instanceof google.maps.Marker) {\n        google.maps.event.clearInstanceListeners(marker);\n        marker.setMap(null);\n        marker = null;\n    }\n\n    // check the new options to see if we need to re-create a marker for\n    // this.\n    if (options.marker) {\n        marker = new google.maps.Marker({\n            position: mapOptions.center,\n            map: map\n        });\n        if (options.title) {\n            infoWindow = new google.maps.InfoWindow();\n            infoWindow.setContent(options.title);\n            // infoWindow.open(map, marker);\n            google.maps.event.addListener(marker, 'click', () => {\n                infoWindow.open(map, marker);\n            });\n        }\n    }\n\n    mapData = {\n        element: elem,\n        instance: map,\n        marker: marker,\n        infoWindow: infoWindow,\n        options: mapOptions\n    };\n    // set the reference on the element for later use, if needed.\n    elem._geolocatorMapData = mapData;\n    return mapData;\n}\n\n/**\n *  Sets the `flag` and `staticMap` (if enabled) property of the given location.\n *  @private\n *\n *  @param {Object} location - Fetched location result.\n *  @param {Object} options - initial options.\n */\nfunction setLocationURLs(location, options) {\n    if (!location || !location.address) return;\n    let cc,\n        address = location.address;\n    if (utils.isString(address.countryCode) && address.countryCode.length === 2) {\n        cc = address.countryCode;\n    } else if (utils.isString(address.country) && address.country.length === 2) {\n        cc = address.country;\n    }\n    if (!cc) return;\n    location.flag = enums.URL.FLAG + cc.toLowerCase() + '.svg';\n    if (options.staticMap) {\n        let opts = utils.isPlainObject(options.staticMap)\n            ? utils.clone(options.staticMap)\n            : {};\n        opts.center = location.coords;\n        location.staticMap = geolocator.getStaticMap(opts);\n    }\n}\n\n/**\n *  Nests `createMap` callback within the given callback.\n *  @private\n *\n *  @param {Object} options\n *         Method options.\n *  @param {Function} callback\n *         Parent callback.\n *\n *  @returns {Function} - Nested callback.\n */\nfunction callbackMap(options, callback) {\n    return function cb(err, location) {\n        if (err) return callback(GeoError.create(err), null);\n        setLocationURLs(location, options);\n        if (!options.map) return callback(null, location);\n        options.map = getMapOpts(options.map, location);\n        geolocator.createMap(options.map, (error, map) => {\n            if (error) return callback(error, null);\n            location.map = map;\n            return callback(null, location);\n        });\n    };\n}\n\n/**\n *  Sends a geocode or reverse-geocode request with the given options.\n *  @private\n *\n *  @param {Boolean} reverse\n *         Whether to send reverse-geocode request.\n *  @param {Object} options\n *         Geocode options.\n *  @param {Function} callback\n *         Callback to be nested and executed with map callback.\n */\nfunction geocode(reverse, options, callback) {\n    checkGoogleKey();\n    geoHelper.geocode(\n        reverse,\n        geolocator._.config,\n        options,\n        callbackMap(options, callback)\n    );\n}\n\n/**\n *  Runs both an address and a timezone look-up for the given location.\n *  @private\n *\n *  @param {Object} location\n *         Location object.\n *  @param {Object} options\n *         Method options.\n *  @param {Function} callback\n *         Parent callback.\n */\nfunction fetchAddressAndTimezone(location, options, callback) {\n    let loc = utils.clone(location, { own: false });\n    if (!options.addressLookup && !options.timezone) {\n        return callback(null, loc);\n    }\n    function getTZ(cb) {\n        geolocator.getTimeZone(loc.coords, (err, timezone) => {\n            if (err) {\n                return cb(err, null);\n            }\n            delete timezone.timestamp;\n            loc.timezone = timezone;\n            loc.timestamp = utils.time(); // update timestamp\n            cb(null, loc);\n        });\n    }\n    if (options.addressLookup) {\n        geolocator.reverseGeocode(loc.coords, (err, result) => {\n            if (err) return callback(err, null);\n            loc = utils.extend({}, result, loc);\n            loc.address = result.address;\n            loc.timestamp = utils.time(); // update timestamp\n            if (!options.timezone) {\n                callback(err, loc);\n            } else {\n                getTZ(callback);\n            }\n        });\n    } else if (options.timezone) {\n        getTZ(callback);\n    } else {\n        callback(null, loc);\n    }\n}\n\n/**\n *  Gets the position with better accuracy.\n *  See https://github.com/gwilson/getAccurateCurrentPosition#background\n *  @private\n *\n *  @param {Object} options\n *         Locate options.\n *  @param {Function} onPositionReceived\n *         Success callback.\n *  @param {Function} onPositionError\n *         Error callback.\n */\nfunction locateAccurate(options, onPositionReceived, onPositionError) {\n    let loc,\n        watcher,\n        onProgress = !utils.isFunction(options.onProgress)\n            ? utils.noop\n            : options.onProgress;\n\n    function complete() {\n        if (!loc) {\n            onPositionError(new GeoError(GeoError.Code.POSITION_UNAVAILABLE));\n        } else {\n            onPositionReceived(loc);\n        }\n    }\n\n    watcher = geolocator.watch(options, (err, location) => {\n        if (err) {\n            return watcher.clear(() => {\n                onPositionError(err);\n            });\n        }\n        loc = location;\n        // ignore the first event if not the only result; for more accuracy.\n        if ((watcher.cycle > 1) && (loc.coords.accuracy <= options.desiredAccuracy)) {\n            watcher.clear(complete);\n        } else {\n            onProgress(loc);\n        }\n    });\n    watcher.clear(options.maximumWait + 100, complete);\n}\n\nfunction getStyles(options) {\n    let conf = geolocator._.config;\n    return !utils.isFilledArray(options.styles)\n        ? (utils.isFilledArray(conf.google.styles) ? conf.google.styles : null)\n        : options.styles;\n}\n\n// ---------------------------\n// INITIALIZE\n// ---------------------------\n\n/**\n *  @private\n *  @type {Object}\n */\ngeolocator._ = {\n    config: utils.extend({}, defaultConfig),\n    // Storage for global callbacks.\n    cb: {}\n};\n\n// setting default Geo-IP source, FreeGeoIP\ngeolocator.setGeoIPSource({\n    provider: 'freegeoip',\n    url: 'https://freegeoip.net/json',\n    callbackParam: 'callback',\n    schema: {\n        ip: 'ip',\n        coords: {\n            latitude: 'latitude',\n            longitude: 'longitude'\n        },\n        address: {\n            city: 'city',\n            state: 'region_name',\n            stateCode: 'region_code',\n            postalCode: 'zip_code',\n            countryCode: 'country_code',\n            country: 'country_name',\n            region: 'region_name'\n        },\n        timezone: {\n            id: 'time_zone'\n        }\n    }\n});\n\n// ---------------------------\n// EXPORT\n// ---------------------------\n\nexport default geolocator;\n\n// ---------------------------\n// ADDITIONAL DOCUMENTATION\n// ---------------------------\n\n/**\n *  `Coordinates` inner type that specifies the geographic position of the\n *  device. The position is expressed as a set of geographic coordinates\n *  together with information about heading and speed.\n *\n *  This is generally returned as part of the\n *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n *\n *  @typedef geolocator~Coordinates\n *  @type Object\n *\n *  @property {Number} latitude\n *         Specifies the latitude estimate in decimal degrees. The value\n *         range is [-90.00, +90.00].\n *  @property {Number} longitude\n *         Specifies the longitude estimate in decimal degrees. The value\n *         range is [-180.00, +180.00].\n *  @property {Number} altitude\n *         Specifies the altitude estimate in meters above the WGS 84\n *         ellipsoid.\n *  @property {Number} accuracy\n *         Specifies the accuracy of the latitude and longitude estimates in\n *         meters.\n *  @property {Number} altitudeAccuracy\n *         Specifies the accuracy of the altitude estimate in meters.\n *  @property {Number} heading\n *         Specifies the device's current direction of movement in degrees\n *         counting clockwise relative to true north.\n *  @property {Number} speed\n *         Specifies the device's current ground speed in meters per second.\n */\n\n/**\n *\t`Address` inner type that specifies the address of the fetched location.\n *\tThe address is expressed as a set of political and locality components.\n *\n *  This is generally returned as part of the\n *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n *\n *  @typedef geolocator~Address\n *  @type Object\n *\n *  @property {String} commonName\n *         Indicates a point of interest, a premise or colloquial area name for\n *         the fetched location, if any.\n *  @property {String} streetNumber\n *         Indicates the precise street number of the fetched location, if any.\n *  @property {String} street\n *         Indicates the street name of the fetched location, if any.\n *  @property {String} route\n *         Indicates the route name of the fetched location, if any.\n *  @property {String} neighborhood\n *         Indicates the neighborhood name of the fetched location, if any.\n *  @property {String} town\n *         Indictes the town of the fetched location, if any.\n *  @property {String} city\n *         Indicates the city of the fetched location.\n *  @property {String} region\n *         Indicates the political region name of the fetched location, if any.\n *  @property {String} postalCode\n *         Indicates the postal code of the fetched location, if any.\n *  @property {String} state\n *         Indicates the state of the fetched location, if any.\n *  @property {String} stateCode\n *         Indicates the state code of the fetched location, if any.\n *  @property {String} country\n *         Indicates the national political entity of the fetched location.\n *  @property {String} countryCode\n *         Indicates the ISO alpha-2 country code of the fetched location.\n */\n\n/**\n *\t`TimeZone` inner type that specifies time offset data for the fetched\n *\tlocation on the surface of the earth.\n *\n *  This is generally returned as part of the\n *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n *\n *  @typedef geolocator~TimeZone\n *  @type Object\n *\n *  @property {String} id\n *         The ID of the time zone, such as `\"America/Los_Angeles\"` or\n *         `\"Australia/Sydney\"`. These IDs are defined in the\n *         {@link http://www.iana.org/time-zones|IANA Time Zone Database},\n *         which is also available in searchable format in Wikipedia's\n *         {@link http://en.wikipedia.org/wiki/List_of_tz_database_time_zones|List of tz database time zones}.\n *  @property {String} name\n *         The long form name of the time zone. This field will be localized if\n *         the Geolocator `language` is configured. e.g. `\"Pacific Daylight Time\"`\n *         or `\"Australian Eastern Daylight Time\"`.\n *  @property {String} abbr\n *         The abbreviation of the time zone.\n *  @property {Number} dstOffset\n *         The offset for daylight-savings time in seconds. This will be zero\n *         if the time zone is not in Daylight Savings Time during the specified\n *         timestamp.\n *  @property {Number} rawOffset\n *         The offset from UTC (in seconds) for the given location. This does\n *         not take into effect daylight savings.\n */\n\n/**\n *\t`MapData` inner type that provides references to the components of a\n *\tcreated Google Maps `Map` and the containing DOM element.\n *\n *  This is generally returned as part of the\n *  {@link ?api=geolocator#geolocator~Location|`Location` result object}.\n *\n *  @typedef geolocator~MapData\n *  @type Object\n *\n *  @property {HTMLElement} element\n *         DOM element which a (Google) map is created within.\n *  @property {google.maps.Map} instance\n *         Instance of a Google Maps `Map` object.\n *  @property {google.maps.Marker} marker\n *         Instance of a Google Maps `Marker` object, if any.\n *  @property {google.maps.InfoWindow} infoWindow\n *         Instance of a Google Maps `InfoWindow` object, if any.\n *  @property {Object} options\n *         Arbitrary object of applied map options.\n */\n\n/**\n *\t`Location` inner type that specifies geographic coordinates, address and\n *\ttime zone information for the fetched location.\n *\n *  This result object is passed to the callbacks of the corresponding\n *  asynchronous Geolocator methods (such as `.locate()` method), as the second\n *  argument. The contents of this object will differ for various  Geolocator\n *  methods, depending on the configured method options.\n *\n *  @typedef geolocator~Location\n *  @type Object\n *\n *  @property {Coordinates} coords\n *         Specifies the geographic location of the device. The location is\n *         expressed as a set of geographic coordinates together with\n *         information about heading and speed.\n *         See {@link #geolocator~Coordinates|`geolocator~Coordinates` type}\n *         for details.\n *  @property {Address} address\n *         Specifies the address of the fetched location. The address is\n *         expressed as a set of political and locality components.\n *         This property might be `undefined` if `addressLookup` option is not\n *         enabled for the corresponding method.\n *         See {@link #geolocator~Address|`geolocator~Address` type}\n *         for details.\n *  @property {String} formattedAddress\n *         The human-readable address of this location. Often this address is\n *         equivalent to the \"postal address,\" which sometimes differs from\n *         country to country.\n *  @property {Boolean} targetReached\n *         Specifies whether the defined target coordinates is reached.\n *         This property is only available for\n *         {@link #geolocator.watch|`geolocator.watch()`} method when `target`\n *         option is defined.\n *  @property {String} type\n *         Type of the location. See\n *         {@link #geolcoator.LocationType|`geolcoator.LocationType` enumeration}\n *         for details.\n *  @property {String} placeId\n *         A unique identifier that can be used with other Google APIs.\n *  @property {String} flag\n *         URL of the country flag image, in SVG format. This property exists\n *         only if address information is available.\n *  @property {TimeZone} timezone\n *         Specifies time offset data for the fetched location on the surface of\n *         the earth. See {@link #geolocator~TimeZone|`geolocator~TimeZone` type}\n *         for details.\n *  @property {MapData} map\n *         Provides references to the components of a created Google Maps `Map`\n *         and the containing DOM element. See\n *         {@link #geolocator~MapData|`geolocator~MapData` type} for details.\n *  @property {String} staticMap\n *         URL of a static Google map image, for the location.\n *  @property {Number} timestamp\n *         Specifies the time when the location information was retrieved and\n *         the `Location` object created.\n */\n\n/**\n *  `MapOptions` inner type that specifies options for the map to be created.\n *\n *  @typedef geolocator~MapOptions\n *  @type Object\n *\n *  @property {String|HTMLElement|Map} element\n *         Either the ID of a DOM element or the element itself;\n *         which the map will be created within; or a previously created\n *         `google.maps.Map` instance. If a map instance is set, this\n *         only will apply the options without re-creating it.\n *  @property {Object} center\n *         Center coordinates for the map to be created.\n *      @property {Number} center.latitude\n *             Latitude of the center point coordinates.\n *      @property {Number} center.longitude\n *             Longitude of the center point coordinates.\n *  @property {String} mapTypeId\n *         Type of the map to be created.\n *         See {@link #geolocator.MapTypeId|`geolocator.MapTypeId` enumeration}\n *         for possible values.\n *  @property {String} title\n *         Title text to be displayed within an `InfoWindow`, when the\n *         marker is clicked. This only take effect if `marker` is\n *         enabled.\n *  @property {Boolean} marker\n *         Whether to place a marker at the given coordinates.\n *         If `title` is set, an `InfoWindow` will be opened when the\n *         marker is clicked.\n *  @property {Number} zoom\n *             Zoom level to be set for the map.\n */\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/geolocator.js","import utils from '../lib/utils';\nimport fetch from '../lib/fetch';\nimport enums from './enums';\nimport GeoError from './geo.error';\n\n/**\n *  Helper methods.\n *\n *  @license MIT\n *  @copyright 2016, Onur Yıldırım (onur@cutepilot.com)\n *  @type {Object}\n *  @private\n */\nconst geoHelper = {\n\n    toGoogleCoords(coords) {\n        return {\n            lat: coords.lat || coords.latitude,\n            lng: coords.lng || coords.longitude\n        };\n    },\n\n    fromGoogleCoords(coords) {\n        return {\n            latitude: coords.latitude || coords.lat,\n            longitude: coords.longitude || coords.lng\n        };\n    },\n\n    // used for distance matrix origins and destinations\n    toPointList(arr) {\n        arr = utils.isArray(arr) ? arr : [arr];\n        return arr.map(o => {\n            return utils.isString(o) ? o : geoHelper.toGoogleCoords(o);\n        });\n    },\n\n    getGeocodeComps(comp) {\n        return {\n            route: comp.route,\n            locality: comp.locality,\n            administrative_area: comp.administrativeArea, // eslint-disable-line camelcase\n            postal_code: comp.postalCode, // eslint-disable-line camelcase\n            country: comp.country,\n            region: comp.region\n        };\n    },\n\n    // Geocode examples:\n    // address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&key=API_KEY\n    // address=Winnetka&bounds=34.172684,-118.604794|34.236144,-118.500938&key=API_KEY\n    // address=santa+cruz&components=country:ES&key=API_KEY\n    // components=administrative_area:TX|country:US&key=API_KEY\n    // Reverse Geocode examples:\n    // latlng=40.714224,-73.961452&key=API_KEY\n    // place_id=ChIJd8BlQ2BZwokRAFUEcm_qrcA&key=API_KEY\n    buildGeocodeParams(options, reverse) {\n        let params = [],\n            e = utils.encodeURI;\n\n        if (reverse) {\n            if (options.placeId) {\n                params.push(`place_id=${options.placeId}`);\n            } else if (options.latitude && options.longitude) {\n                params.push(`latlng=${options.latitude},${options.longitude}`);\n            }\n        } else {\n            if (options.address) {\n                params.push(`address=${e(options.address)}`);\n            }\n\n            let geoComps = geoHelper.getGeocodeComps(options);\n            geoComps = utils.params(geoComps, { operator: ':', separator: '|' });\n            params.push(`components=${geoComps}`);\n\n            let b = options.bounds;\n            if (utils.isArray(b) && b.length === 4) {\n                params.push(`bounds=${b[0]},${b[1]}|${b[2]},${b[3]}`);\n            } else if (utils.isPlainObject(b) && Object.keys(b).length === 4) {\n                params.push(`bounds=${b.southwestLat},${b.southwestLng}|${b.northeastLat},${b.northeastLng}`);\n            }\n        }\n\n        params.push(`language=${options.language}`);\n        params.push(`key=${options.key}`);\n        return params.join('&');\n    },\n\n    // See https://developers.google.com/maps/documentation/geocoding/intro\n    formatGeocodeResults(results) {\n        if (!utils.isArray(results) || results.length <= 0) {\n            return {\n                location: null,\n                address: null,\n                formattedAddress: '',\n                type: null, // locationType\n                placeId: ''\n            };\n        }\n\n        let i, c,\n            o = {},\n            data = results[0],\n            comps = data.address_components;\n\n        for (i = 0; i < comps.length; i += 1) {\n            c = comps[i];\n            if (c.types && c.types.length > 0) {\n                o[c.types[0]] = c.long_name;\n                o[c.types[0] + '_s'] = c.short_name;\n            }\n        }\n\n        let geometry = data.geometry;\n        return {\n            coords: geometry && geometry.location ? {\n                latitude: geometry.location.lat,\n                longitude: geometry.location.lng\n            } : null,\n            address: {\n                commonName: o.point_of_interest\n                    || o.premise\n                    || o.subpremise\n                    || o.colloquial_area\n                    || '',\n                streetNumber: o.street_number || '',\n                street: o.administrative_area_level_4\n                    || o.administrative_area_level_3\n                    || o.route\n                    || '',\n                route: o.route || '',\n                neighborhood: o.neighborhood\n                    || o.administrative_area_level_5\n                    || o.administrative_area_level_4\n                    || '',\n                town: o.sublocality || o.administrative_area_level_2 || '',\n                city: o.locality || o.administrative_area_level_1 || '',\n                region: o.administrative_area_level_2\n                    || o.administrative_area_level_1\n                    || '',\n                postalCode: o.postal_code || '',\n                state: o.administrative_area_level_1 || '',\n                stateCode: o.administrative_area_level_1_s || '',\n                country: o.country || '',\n                countryCode: o.country_s || ''\n            },\n            formattedAddress: data.formatted_address,\n            type: geometry.location_type || '',\n            placeId: data.place_id,\n            timestamp: utils.time()\n        };\n    },\n\n    geocode(reverse, conf, options, callback) {\n        let opts = {};\n        if (utils.isString(options)) {\n            opts = {};\n            let prop = reverse ? 'placeId' : 'address';\n            opts[prop] = options;\n        } else if (utils.isPlainObject(options)) {\n            opts = options;\n        } else {\n            throw new GeoError(GeoError.Code.INVALID_PARAMETERS);\n        }\n\n        if (reverse) {\n            let coordsSet = utils.isNumber(options.latitude)\n                && utils.isNumber(options.longitude);\n            if (!utils.isString(options.placeId) && !coordsSet) {\n                throw new GeoError(GeoError.Code.INVALID_PARAMETERS);\n            }\n        }\n\n        opts = utils.extend({\n            key: conf.google.key || '',\n            language: conf.language || 'en',\n            raw: false\n        }, opts);\n\n        let query = geoHelper.buildGeocodeParams(opts, reverse),\n            url = utils.setProtocol(enums.URL.GOOGLE_GEOCODE, conf.https),\n            xhrOpts = {\n                url: `${url}?${query}`\n            };\n\n        fetch.xhr(xhrOpts, (err, xhr) => {\n            if (err) return callback(GeoError.create(err), null);\n\n            let response = utils.safeJsonParse(xhr.responseText),\n                gErr = GeoError.fromResponse(response);\n\n            if (gErr) return callback(gErr, null);\n\n            response = options.raw\n                ? response\n                : geoHelper.formatGeocodeResults(response.results);\n            callback(null, response);\n        });\n    },\n\n    // See https://developers.google.com/maps/documentation/distance-matrix/intro\n    // Raw Result Example:\n    // {\n    //    \"destination_addresses\" : [ \"San Francisco, CA, USA\", \"Victoria, BC, Canada\" ],\n    //    \"origin_addresses\" : [ \"Vancouver, BC, Canada\", \"Seattle, WA, USA\" ],\n    //    \"rows\" : [\n    //       {\n    //          \"elements\" : [\n    //             {\n    //                \"distance\" : { \"text\" : \"1,704 km\", \"value\" : 1704324 },\n    //                \"duration\" : { \"text\" : \"3 days 19 hours\", \"value\" : 327061\n    //                },\n    //                \"status\" : \"OK\"\n    //             },\n    //             {\n    //                \"distance\" : { \"text\" : \"138 km\", \"value\" : 138295 },\n    //                \"duration\" : { \"text\" : \"6 hours 44 mins\", \"value\" : 24236 },\n    //                \"status\" : \"OK\"\n    //             }\n    //          ]\n    //       },\n    //       {\n    //          \"elements\" : [\n    //             {\n    //                \"distance\" : { \"text\" : \"1,452 km\", \"value\" : 1451623 },\n    //                \"duration\" : { \"text\" : \"3 days 4 hours\", \"value\" : 275062 },\n    //                \"status\" : \"OK\"\n    //             },\n    //             {\n    //                \"distance\" : { \"text\" : \"146 km\", \"value\" : 146496 },\n    //                \"duration\" : { \"text\" : \"2 hours 52 mins\", \"value\" : 10324 },\n    //                \"status\" : \"OK\"\n    //             }\n    //          ]\n    //       }\n    //    ],\n    //    \"status\" : \"OK\"\n    // }\n    // Formatted to:\n\n    formatDistanceResults(results) {\n        if (!utils.isPlainObject(results)) {\n            return null;\n        }\n\n        let arr = [],\n            origins = results.originAddresses,\n            dests = results.destinationAddresses,\n            rows = results.rows;\n\n        // [\n        //     {\n        //          from: 'Vancouver, BC, Canada',\n        //          to: 'San Francisco, CA, USA',\n        //          distance: { value: 1704107, text: \"1,704 km\" },\n        //          duration: { value: 327025, text: \"3 days 19 hours\" },\n        //          fare: { currency: \"USD\", value: 6, text: \"$6.00\" }\n        //     },\n        //     ...\n        // ]\n\n        let e;\n        origins.forEach((origin, oIndex) => {\n            dests.forEach((dest, dIndex) => {\n                e = rows[oIndex].elements[dIndex];\n                arr.push({\n                    from: origin,\n                    to: dest,\n                    distance: e.distance,\n                    duration: e.duration,\n                    fare: e.fare,\n                    timestamp: utils.time()\n                });\n            });\n        });\n\n        return arr;\n    },\n\n    // Converts a map-styles object in to static map styles (formatted query-string params).\n    // See https://developers.google.com/maps/documentation/static-maps/styling\n    mapStylesToParams(styles) {\n        if (!styles) return '';\n        if (!utils.isArray(styles)) styles = [styles];\n        let result = [];\n        styles.forEach((v, i, a) => {\n            let style = '';\n            if (v.stylers) { // only if there is a styler object\n                if (v.stylers.length > 0) { // Needs to have a style rule to be valid.\n                    style += (v.hasOwnProperty('featureType') ? 'feature:' + v.featureType : 'feature:all') + '|';\n                    style += (v.hasOwnProperty('elementType') ? 'element:' + v.elementType : 'element:all') + '|';\n                    v.stylers.forEach((val, i, a) => {\n                        let propName = Object.keys(val)[0],\n                            propVal = val[propName].toString().replace('#', '0x');\n                        style += propName + ':' + propVal + '|';\n                    });\n                }\n            }\n            result.push('style=' + encodeURIComponent(style));\n        });\n        return result.join('&');\n    }\n\n};\n\nexport default geoHelper;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/geo.helper.js","import utils from '../lib/utils';\n\nclass GeoWatcher {\n\n    constructor(onChange, onError, options = {}) {\n        this.isCleared = false;\n        this.cycle = 0;\n        this._timer = null;\n        this.id = navigator.geolocation.watchPosition(\n            pos => {\n                this.cycle++;\n                if (utils.isFunction(onChange)) onChange(pos);\n            },\n            err => {\n                this.cycle++;\n                if (utils.isFunction(onError)) onError(err);\n                if (options.clearOnError) {\n                    this.clear();\n                }\n            },\n            options\n        );\n    }\n\n    _clear() {\n        navigator.geolocation.clearWatch(this.id);\n        this.isCleared = true;\n        this._timer = null;\n    }\n\n    clear(delay, callback) {\n        let d = utils.isNumber(delay) ? delay : 0,\n            cb = utils.isFunction(callback) ? callback\n                : utils.isFunction(delay) ? delay : null;\n        // clear any previous timeout\n        if (this._timer) {\n            clearTimeout(this._timer);\n            this._timer = null;\n        }\n        // check if watcher is not cleared\n        if (!this.isCleared) {\n            if (d === 0) {\n                this._clear();\n                if (cb) cb();\n                return;\n            }\n            this._timer = setTimeout(() => {\n                this._clear();\n                if (cb) cb();\n            }, d);\n        }\n    }\n\n}\n\n// ---------------------------\n// EXPORT\n// ---------------------------\n\nexport default GeoWatcher;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/geo.watcher.js","import geolocator from './core/geolocator';\n\n// See https://github.com/onury/geolocator/issues/42\nif (typeof window !== 'undefined'\n        && typeof window.geolocator === 'undefined') {\n    window.geolocator = geolocator;\n}\n\n// export default geolocator;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = geolocator;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}